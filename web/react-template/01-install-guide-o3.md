## 1  Bootstrap the project (Bun 1.1+)

```bash
# install Bun once (macOS / Linux)
/bin/bash -c "$(curl -fsSL https://bun.sh/install)"

# scaffold a React+TS app pre-wired for Vite+SWC
bun create vite my-app
#   › framework: React
#   › variant:  TypeScript + SWC
cd my-app
bun install        # resolves with Bun's native package manager
```

([Bun][1])

### Add Redux Toolkit + bindings

```bash
bun add @reduxjs/toolkit react-redux
```

---

## 2  Wire up Storybook (Vite builder)

```bash
# Storybook CLI understands bunx the same way it understands npx
bunx storybook@latest init --type react --builder vite
```

This drops a `.storybook/` folder.  Ensure `main.ts` (Storybook 8+) points to the Vite/React framework:

```ts
// .storybook/main.ts
import { StorybookConfig } from '@storybook/react-vite';
const config: StorybookConfig = {
  stories: ['../src/**/*.stories.@(js|jsx|ts|tsx)'],
  framework: { name: '@storybook/react-vite', options: {} },
};
export default config;
```

([Storybook][2])

Run Storybook alongside Vite dev server:

```bash
bun run storybook     # localhost:6006
bun run dev           # Vite dev server (see §4 for proxy)
```

---

## 3  Add a minimal Redux slice (example)

```ts
// src/store.ts
import { configureStore, createSlice } from '@reduxjs/toolkit';

const counter = createSlice({
  name: 'counter',
  initialState: 0,
  reducers: { inc: s => s + 1, dec: s => s - 1 },
});

export const { inc, dec } = counter.actions;
export const store = configureStore({ reducer: counter.reducer });
export type RootState = ReturnType<typeof store.getState>;
```

Wire it in `main.tsx` with `<Provider store={store}>…`.

---

## 4  Proxy API calls to your Go backend during dev

Edit `vite.config.ts`:

```ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react-swc';

export default defineConfig({
  plugins: [react()],
  server: {
    proxy: {
      '/api': {         // anything starting with /api →
        target: 'http://localhost:8080',
        changeOrigin: true,
        secure: false,  // allow self-signed HTTPS while you iterate
      },
    },
  },
});
```

([Stack Overflow][3], [Medium][4])

Now `fetch('/api/users')` (or axios, RTK Query, etc.) will hit `localhost:8080` where your Go service runs, without CORS complaints.

---

## 5  Build production assets

```bash
bun run build        # internally runs vite build
# → dist/
```

* `index.html` sits at the root
* hashed JS/CSS bundles live in `dist/assets/`
  ([vitejs][5])

---

## 6  Embed *dist/* into a Go binary

### Project layout (suggested)

```
my-app/
  frontend/          # everything created so far
    dist/            # generated by bun run build
  cmd/server/
    main.go
```

### `main.go`

```go
package main

import (
	"embed"
	"io/fs"
	"net/http"
	"strings"
)

//go:embed all:../frontend/dist
var dist embed.FS

func spa() http.Handler {
	sub, _ := fs.Sub(dist, "frontend/dist") // root of built assets
	fileServer := http.FileServer(http.FS(sub))

	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		path := strings.TrimPrefix(r.URL.Path, "/")
		_, err := sub.Open(path)
		if err != nil { // client-side route → fallback to index.html
			r.URL.Path = "/index.html"
		}
		fileServer.ServeHTTP(w, r)
	})
}

func main() {
	mux := http.NewServeMux()
	mux.Handle("/api/", apiRoutes()) // your JSON handlers
	mux.Handle("/", spa())           // React SPA
	http.ListenAndServe(":8080", mux)
}
```

([ofeng.org][6], [iamyadav.com][7])

### Build everything

```bash
make build          # see sample Makefile
./server            # single self-contained binary
```

*A minimal Makefile*

```make
frontend-build:
	cd frontend && bun run build
backend-build:
	go build -o server ./cmd/server
build: frontend-build backend-build
```

---

## 7  Iterate fast

1. **Frontend**: `bun run dev` (with proxy) — instant HMR.
2. **Backend**: run `go run ./cmd/server` (or use \[air] for auto-reload).
3. When ready to ship, run `bun run build && go build …` again.

---

### What you now have

* Vite + SWC dev server (React 19) hot-reloading in \~10 ms
* Redux Toolkit pre-configured
* Storybook isolated component sandbox running on its own port
* A Go API reachable at `/api/**` both in development (via proxy) and production (embedded assets + native handlers)

Enjoy coding!

[1]: https://bun.sh/guides/ecosystem/vite?utm_source=chatgpt.com "Build a frontend using Vite and Bun | Bun Examples"
[2]: https://storybook.js.org/docs/get-started/frameworks/react-vite?utm_source=chatgpt.com "Storybook for React & Vite"
[3]: https://stackoverflow.com/questions/64677212/how-to-configure-proxy-in-vite?utm_source=chatgpt.com "How to configure proxy in Vite? - Stack Overflow"
[4]: https://medium.com/%40eric_abell/simplifying-api-proxies-in-vite-a-guide-to-vite-config-js-a5cc3a091a2f?utm_source=chatgpt.com "Simplifying API Proxies in Vite: A Guide to vite.config.js | by Eric Abell"
[5]: https://vite.dev/guide/backend-integration?utm_source=chatgpt.com "Backend Integration - Vite"
[6]: https://ofeng.org/posts/go-embed-vite/?utm_source=chatgpt.com "Go Embed Vite - Feng's Notes"
[7]: https://www.iamyadav.com/blogs/a-guide-to-embedding-static-files-in-go?utm_source=chatgpt.com "A Guide to Embedding Static Files in Go using go:embed | iamyadav"

---

Below is the smallest set of changes you need to

1. add **Mock Service Worker (MSW)** to the Storybook you already bootstrapped;
2. expose the MSW handlers to every story; and
3. write a single **WidgetList** component + Story that fetches data through **RTK Query**, which MSW intercepts.

---

## 1  Install MSW and the Storybook addon (dev-only)

```bash
bun add -D msw msw-storybook-addon      # Storybook 8 + MSW ≥ 2.0
```

The addon wraps Storybook’s environment with a service-worker automatically. ([GitHub][1])

---

## 2  Wire the addon into Storybook

### `.storybook/main.ts`

```ts
import { StorybookConfig } from '@storybook/react-vite';

const config: StorybookConfig = {
  stories: ['../src/**/*.stories.@(ts|tsx)'],
  addons: ['msw-storybook-addon'],     // ← one-liner
  framework: { name: '@storybook/react-vite', options: {} },
  staticDirs: ['../public'],           // MSW injects worker script here
};
export default config;
```

([Storybook][2])

### `.storybook/preview.ts`

```ts
import { initialize, mswDecorator } from 'msw-storybook-addon';
import { Provider } from 'react-redux';
import { store } from '../src/store';

initialize();               // registers the service-worker once

export const decorators = [
  mswDecorator,             // MSW first
  Story => <Provider store={store}><Story /></Provider>,
];
```

---

## 3  Create a tiny RTK Query slice

```ts
// src/services/widgetsApi.ts
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

export interface Widget { id: number; name: string }

export const widgetsApi = createApi({
  reducerPath: 'widgetsApi',
  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
  endpoints: builder => ({
    getWidgets: builder.query<Widget[], void>({
      query: () => 'widgets',   // GET /api/widgets
    }),
  }),
});

export const { useGetWidgetsQuery } = widgetsApi;
```

Add the reducer + middleware to your existing `store.ts`:

```ts
import { configureStore } from '@reduxjs/toolkit';
import { widgetsApi } from './services/widgetsApi';

export const store = configureStore({
  reducer: {
    [widgetsApi.reducerPath]: widgetsApi.reducer,
  },
  middleware: gDM => gDM().concat(widgetsApi.middleware),
});
```

---

## 4  A minimal component that consumes the hook

```tsx
// src/components/WidgetList.tsx
import { useGetWidgetsQuery } from '../services/widgetsApi';

export const WidgetList = () => {
  const { data, isLoading, error } = useGetWidgetsQuery();

  if (isLoading) return <>Loading…</>;
  if (error)     return <>Error</>;

  return (
    <ul>
      {data!.map(w => <li key={w.id}>{w.name}</li>)}
    </ul>
  );
};
```

---

## 5  Define MSW handlers once (re-usable)

```ts
// src/mocks/handlers.ts
import { rest } from 'msw';
import type { Widget } from '../services/widgetsApi';

const widgets: Widget[] = [
  { id: 1, name: 'Foo' },
  { id: 2, name: 'Bar' },
];

export const handlers = [
  rest.get('/api/widgets', (_req, res, ctx) =>
    res(ctx.status(200), ctx.json(widgets))
  ),
];
```

---

## 6  Write the Story

```tsx
// src/components/WidgetList.stories.tsx
import type { Meta, StoryObj } from '@storybook/react';
import { WidgetList } from './WidgetList';
import { handlers } from '../mocks/handlers';

const meta: Meta<typeof WidgetList> = {
  title: 'Widgets/WidgetList',
  component: WidgetList,
  parameters: { msw: { handlers } },   // ← plug MSW in
};
export default meta;

export const Default: StoryObj<typeof WidgetList> = {};
```

When Storybook renders **Default**, the `GET /api/widgets` request created by RTK Query is intercepted by MSW, which returns the fake list—no real backend required. ([Storybook][2], [GitHub][3])

---

### Run

```bash
bun run storybook   # localhost:6006 – WidgetList should show Foo, Bar
```

### Re-use the mock in Vite dev (optional)

If you want the same mock while hacking on the actual app, start MSW in `src/main.tsx`:

```ts
if (import.meta.env.DEV) {
  const { worker } = await import('./mocks/browser');
  worker.start();
}
```

where `browser.ts` just re-exports the same `handlers`:

```ts
import { setupWorker } from 'msw';
import { handlers } from './handlers';
export const worker = setupWorker(...handlers);
```

That’s all you need: RTK Query calls your API slice, MSW stubs the network, and Storybook (plus your Vite dev server) renders predictable UI every time.

[1]: https://github.com/mswjs/msw-storybook-addon?utm_source=chatgpt.com "mswjs/msw-storybook-addon: Mock API requests in ... - GitHub"
[2]: https://storybook.js.org/docs/writing-stories/mocking-data-and-modules/mocking-network-requests?utm_source=chatgpt.com "Mocking network requests | Storybook docs"
[3]: https://github.com/mswjs/msw-storybook-addon/releases?utm_source=chatgpt.com "Releases · mswjs/msw-storybook-addon - GitHub"
