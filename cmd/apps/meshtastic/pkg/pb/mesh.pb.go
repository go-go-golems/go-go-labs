// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: meshtastic/mesh.proto

package generated

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Note: these enum names must EXACTLY match the string used in the device
// bin/build-all.sh script.
// Because they will be used to find firmware filenames in the android app for OTA updates.
// To match the old style filenames, _ is converted to -, p is converted to .
type HardwareModel int32

const (
	// TODO: REPLACE
	HardwareModel_UNSET HardwareModel = 0
	// TODO: REPLACE
	HardwareModel_TLORA_V2 HardwareModel = 1
	// TODO: REPLACE
	HardwareModel_TLORA_V1 HardwareModel = 2
	// TODO: REPLACE
	HardwareModel_TLORA_V2_1_1P6 HardwareModel = 3
	// TODO: REPLACE
	HardwareModel_TBEAM HardwareModel = 4
	// The original heltec WiFi_Lora_32_V2, which had battery voltage sensing hooked to GPIO 13
	// (see HELTEC_V2 for the new version).
	HardwareModel_HELTEC_V2_0 HardwareModel = 5
	// TODO: REPLACE
	HardwareModel_TBEAM_V0P7 HardwareModel = 6
	// TODO: REPLACE
	HardwareModel_T_ECHO HardwareModel = 7
	// TODO: REPLACE
	HardwareModel_TLORA_V1_1P3 HardwareModel = 8
	// TODO: REPLACE
	HardwareModel_RAK4631 HardwareModel = 9
	// The new version of the heltec WiFi_Lora_32_V2 board that has battery sensing hooked to GPIO 37.
	// Sadly they did not update anything on the silkscreen to identify this board
	HardwareModel_HELTEC_V2_1 HardwareModel = 10
	// Ancient heltec WiFi_Lora_32 board
	HardwareModel_HELTEC_V1 HardwareModel = 11
	// New T-BEAM with ESP32-S3 CPU
	HardwareModel_LILYGO_TBEAM_S3_CORE HardwareModel = 12
	// RAK WisBlock ESP32 core: https://docs.rakwireless.com/Product-Categories/WisBlock/RAK11200/Overview/
	HardwareModel_RAK11200 HardwareModel = 13
	// B&Q Consulting Nano Edition G1: https://uniteng.com/wiki/doku.php?id=meshtastic:nano
	HardwareModel_NANO_G1 HardwareModel = 14
	// TODO: REPLACE
	HardwareModel_TLORA_V2_1_1P8 HardwareModel = 15
	// TODO: REPLACE
	HardwareModel_TLORA_T3_S3 HardwareModel = 16
	// B&Q Consulting Nano G1 Explorer: https://wiki.uniteng.com/en/meshtastic/nano-g1-explorer
	HardwareModel_NANO_G1_EXPLORER HardwareModel = 17
	// B&Q Consulting Nano G2 Ultra: https://wiki.uniteng.com/en/meshtastic/nano-g2-ultra
	HardwareModel_NANO_G2_ULTRA HardwareModel = 18
	// LoRAType device: https://loratype.org/
	HardwareModel_LORA_TYPE HardwareModel = 19
	// wiphone https://www.wiphone.io/
	HardwareModel_WIPHONE HardwareModel = 20
	// WIO Tracker WM1110 family from Seeed Studio. Includes wio-1110-tracker and wio-1110-sdk
	HardwareModel_WIO_WM1110 HardwareModel = 21
	// RAK2560 Solar base station based on RAK4630
	HardwareModel_RAK2560 HardwareModel = 22
	// Heltec HRU-3601: https://heltec.org/project/hru-3601/
	HardwareModel_HELTEC_HRU_3601 HardwareModel = 23
	// Heltec Wireless Bridge
	HardwareModel_HELTEC_WIRELESS_BRIDGE HardwareModel = 24
	// B&Q Consulting Station Edition G1: https://uniteng.com/wiki/doku.php?id=meshtastic:station
	HardwareModel_STATION_G1 HardwareModel = 25
	// RAK11310 (RP2040 + SX1262)
	HardwareModel_RAK11310 HardwareModel = 26
	// Makerfabs SenseLoRA Receiver (RP2040 + RFM96)
	HardwareModel_SENSELORA_RP2040 HardwareModel = 27
	// Makerfabs SenseLoRA Industrial Monitor (ESP32-S3 + RFM96)
	HardwareModel_SENSELORA_S3 HardwareModel = 28
	// Canary Radio Company - CanaryOne: https://canaryradio.io/products/canaryone
	HardwareModel_CANARYONE HardwareModel = 29
	// Waveshare RP2040 LoRa - https://www.waveshare.com/rp2040-lora.htm
	HardwareModel_RP2040_LORA HardwareModel = 30
	// B&Q Consulting Station G2: https://wiki.uniteng.com/en/meshtastic/station-g2
	HardwareModel_STATION_G2 HardwareModel = 31
	// ---------------------------------------------------------------------------
	// Less common/prototype boards listed here (needs one more byte over the air)
	// ---------------------------------------------------------------------------
	HardwareModel_LORA_RELAY_V1 HardwareModel = 32
	// TODO: REPLACE
	HardwareModel_NRF52840DK HardwareModel = 33
	// TODO: REPLACE
	HardwareModel_PPR HardwareModel = 34
	// TODO: REPLACE
	HardwareModel_GENIEBLOCKS HardwareModel = 35
	// TODO: REPLACE
	HardwareModel_NRF52_UNKNOWN HardwareModel = 36
	// TODO: REPLACE
	HardwareModel_PORTDUINO HardwareModel = 37
	// The simulator built into the android app
	HardwareModel_ANDROID_SIM HardwareModel = 38
	// Custom DIY device based on @NanoVHF schematics: https://github.com/NanoVHF/Meshtastic-DIY/tree/main/Schematics
	HardwareModel_DIY_V1 HardwareModel = 39
	// nRF52840 Dongle : https://www.nordicsemi.com/Products/Development-hardware/nrf52840-dongle/
	HardwareModel_NRF52840_PCA10059 HardwareModel = 40
	// Custom Disaster Radio esp32 v3 device https://github.com/sudomesh/disaster-radio/tree/master/hardware/board_esp32_v3
	HardwareModel_DR_DEV HardwareModel = 41
	// M5 esp32 based MCU modules with enclosure, TFT and LORA Shields. All Variants (Basic, Core, Fire, Core2, CoreS3, Paper) https://m5stack.com/
	HardwareModel_M5STACK HardwareModel = 42
	// New Heltec LoRA32 with ESP32-S3 CPU
	HardwareModel_HELTEC_V3 HardwareModel = 43
	// New Heltec Wireless Stick Lite with ESP32-S3 CPU
	HardwareModel_HELTEC_WSL_V3 HardwareModel = 44
	// New BETAFPV ELRS Micro TX Module 2.4G with ESP32 CPU
	HardwareModel_BETAFPV_2400_TX HardwareModel = 45
	// BetaFPV ExpressLRS "Nano" TX Module 900MHz with ESP32 CPU
	HardwareModel_BETAFPV_900_NANO_TX HardwareModel = 46
	// Raspberry Pi Pico (W) with Waveshare SX1262 LoRa Node Module
	HardwareModel_RPI_PICO HardwareModel = 47
	// Heltec Wireless Tracker with ESP32-S3 CPU, built-in GPS, and TFT
	// Newer V1.1, version is written on the PCB near the display.
	HardwareModel_HELTEC_WIRELESS_TRACKER HardwareModel = 48
	// Heltec Wireless Paper with ESP32-S3 CPU and E-Ink display
	HardwareModel_HELTEC_WIRELESS_PAPER HardwareModel = 49
	// LilyGo T-Deck with ESP32-S3 CPU, Keyboard and IPS display
	HardwareModel_T_DECK HardwareModel = 50
	// LilyGo T-Watch S3 with ESP32-S3 CPU and IPS display
	HardwareModel_T_WATCH_S3 HardwareModel = 51
	// Bobricius Picomputer with ESP32-S3 CPU, Keyboard and IPS display
	HardwareModel_PICOMPUTER_S3 HardwareModel = 52
	// Heltec HT-CT62 with ESP32-C3 CPU and SX1262 LoRa
	HardwareModel_HELTEC_HT62 HardwareModel = 53
	// EBYTE SPI LoRa module and ESP32-S3
	HardwareModel_EBYTE_ESP32_S3 HardwareModel = 54
	// Waveshare ESP32-S3-PICO with PICO LoRa HAT and 2.9inch e-Ink
	HardwareModel_ESP32_S3_PICO HardwareModel = 55
	// CircuitMess Chatter 2 LLCC68 Lora Module and ESP32 Wroom
	// Lora module can be swapped out for a Heltec RA-62 which is "almost" pin compatible
	// with one cut and one jumper Meshtastic works
	HardwareModel_CHATTER_2 HardwareModel = 56
	// Heltec Wireless Paper, With ESP32-S3 CPU and E-Ink display
	// Older "V1.0" Variant, has no "version sticker"
	// E-Ink model is DEPG0213BNS800
	// Tab on the screen protector is RED
	// Flex connector marking is FPC-7528B
	HardwareModel_HELTEC_WIRELESS_PAPER_V1_0 HardwareModel = 57
	// Heltec Wireless Tracker with ESP32-S3 CPU, built-in GPS, and TFT
	// Older "V1.0" Variant
	HardwareModel_HELTEC_WIRELESS_TRACKER_V1_0 HardwareModel = 58
	// unPhone with ESP32-S3, TFT touchscreen,  LSM6DS3TR-C accelerometer and gyroscope
	HardwareModel_UNPHONE HardwareModel = 59
	// Teledatics TD-LORAC NRF52840 based M.2 LoRA module
	// Compatible with the TD-WRLS development board
	HardwareModel_TD_LORAC HardwareModel = 60
	// CDEBYTE EoRa-S3 board using their own MM modules, clone of LILYGO T3S3
	HardwareModel_CDEBYTE_EORA_S3 HardwareModel = 61
	// TWC_MESH_V4
	// Adafruit NRF52840 feather express with SX1262, SSD1306 OLED and NEO6M GPS
	HardwareModel_TWC_MESH_V4 HardwareModel = 62
	// NRF52_PROMICRO_DIY
	// Promicro NRF52840 with SX1262/LLCC68, SSD1306 OLED and NEO6M GPS
	HardwareModel_NRF52_PROMICRO_DIY HardwareModel = 63
	// RadioMaster 900 Bandit Nano, https://www.radiomasterrc.com/products/bandit-nano-expresslrs-rf-module
	// ESP32-D0WDQ6 With SX1276/SKY66122, SSD1306 OLED and No GPS
	HardwareModel_RADIOMASTER_900_BANDIT_NANO HardwareModel = 64
	// Heltec Capsule Sensor V3 with ESP32-S3 CPU, Portable LoRa device that can replace GNSS modules or sensors
	HardwareModel_HELTEC_CAPSULE_SENSOR_V3 HardwareModel = 65
	// Heltec Vision Master T190 with ESP32-S3 CPU, and a 1.90 inch TFT display
	HardwareModel_HELTEC_VISION_MASTER_T190 HardwareModel = 66
	// Heltec Vision Master E213 with ESP32-S3 CPU, and a 2.13 inch E-Ink display
	HardwareModel_HELTEC_VISION_MASTER_E213 HardwareModel = 67
	// Heltec Vision Master E290 with ESP32-S3 CPU, and a 2.9 inch E-Ink display
	HardwareModel_HELTEC_VISION_MASTER_E290 HardwareModel = 68
	// Heltec Mesh Node T114 board with nRF52840 CPU, and a 1.14 inch TFT display, Ultimate low-power design,
	// specifically adapted for the Meshtatic project
	HardwareModel_HELTEC_MESH_NODE_T114 HardwareModel = 69
	// Sensecap Indicator from Seeed Studio. ESP32-S3 device with TFT and RP2040 coprocessor
	HardwareModel_SENSECAP_INDICATOR HardwareModel = 70
	// Seeed studio T1000-E tracker card. NRF52840 w/ LR1110 radio, GPS, button, buzzer, and sensors.
	HardwareModel_TRACKER_T1000_E HardwareModel = 71
	// RAK3172 STM32WLE5 Module (https://store.rakwireless.com/products/wisduo-lpwan-module-rak3172)
	HardwareModel_RAK3172 HardwareModel = 72
	// Seeed Studio Wio-E5 (either mini or Dev kit) using STM32WL chip.
	HardwareModel_WIO_E5 HardwareModel = 73
	// RadioMaster 900 Bandit, https://www.radiomasterrc.com/products/bandit-expresslrs-rf-module
	// SSD1306 OLED and No GPS
	HardwareModel_RADIOMASTER_900_BANDIT HardwareModel = 74
	// Minewsemi ME25LS01 (ME25LE01_V1.0). NRF52840 w/ LR1110 radio, buttons and leds and pins.
	HardwareModel_ME25LS01_4Y10TD HardwareModel = 75
	// RP2040_FEATHER_RFM95
	// Adafruit Feather RP2040 with RFM95 LoRa Radio RFM95 with SX1272, SSD1306 OLED
	// https://www.adafruit.com/product/5714
	// https://www.adafruit.com/product/326
	// https://www.adafruit.com/product/938
	//
	//	^^^ short A0 to switch to I2C address 0x3C
	HardwareModel_RP2040_FEATHER_RFM95 HardwareModel = 76
	// M5 esp32 based MCU modules with enclosure, TFT and LORA Shields. All Variants (Basic, Core, Fire, Core2, CoreS3, Paper) https://m5stack.com/
	HardwareModel_M5STACK_COREBASIC HardwareModel = 77
	HardwareModel_M5STACK_CORE2     HardwareModel = 78
	// Pico2 with Waveshare Hat, same as Pico
	HardwareModel_RPI_PICO2 HardwareModel = 79
	// M5 esp32 based MCU modules with enclosure, TFT and LORA Shields. All Variants (Basic, Core, Fire, Core2, CoreS3, Paper) https://m5stack.com/
	HardwareModel_M5STACK_CORES3 HardwareModel = 80
	// Seeed XIAO S3 DK
	HardwareModel_SEEED_XIAO_S3 HardwareModel = 81
	// Nordic nRF52840+Semtech SX1262 LoRa BLE Combo Module. nRF52840+SX1262 MS24SF1
	HardwareModel_MS24SF1 HardwareModel = 82
	// Lilygo TLora-C6 with the new ESP32-C6 MCU
	HardwareModel_TLORA_C6 HardwareModel = 83
	// WisMesh Tap
	// RAK-4631 w/ TFT in injection modled case
	HardwareModel_WISMESH_TAP HardwareModel = 84
	// Similar to PORTDUINO but used by Routastic devices, this is not any
	// particular device and does not run Meshtastic's code but supports
	// the same frame format.
	// Runs on linux, see https://github.com/Jorropo/routastic
	HardwareModel_ROUTASTIC HardwareModel = 85
	// Mesh-Tab, esp32 based
	// https://github.com/valzzu/Mesh-Tab
	HardwareModel_MESH_TAB HardwareModel = 86
	// MeshLink board developed by LoraItalia. NRF52840, eByte E22900M22S (Will also come with other frequencies), 25w MPPT solar charger (5v,12v,18v selectable), support for gps, buzzer, oled or e-ink display, 10 gpios, hardware watchdog
	// https://www.loraitalia.it
	HardwareModel_MESHLINK HardwareModel = 87
	// Seeed XIAO nRF52840 + Wio SX1262 kit
	HardwareModel_XIAO_NRF52_KIT HardwareModel = 88
	// Elecrow ThinkNode M1 & M2
	// https://www.elecrow.com/wiki/ThinkNode-M1_Transceiver_Device(Meshtastic)_Power_By_nRF52840.html
	// https://www.elecrow.com/wiki/ThinkNode-M2_Transceiver_Device(Meshtastic)_Power_By_NRF52840.html (this actually uses ESP32-S3)
	HardwareModel_THINKNODE_M1 HardwareModel = 89
	HardwareModel_THINKNODE_M2 HardwareModel = 90
	// Lilygo T-ETH-Elite
	HardwareModel_T_ETH_ELITE HardwareModel = 91
	// Heltec HRI-3621 industrial probe
	HardwareModel_HELTEC_SENSOR_HUB HardwareModel = 92
	// Reserved Fried Chicken ID for future use
	HardwareModel_RESERVED_FRIED_CHICKEN HardwareModel = 93
	// Heltec Magnetic Power Bank with Meshtastic compatible
	HardwareModel_HELTEC_MESH_POCKET HardwareModel = 94
	// Seeed Solar Node
	HardwareModel_SEEED_SOLAR_NODE HardwareModel = 95
	// NomadStar Meteor Pro https://nomadstar.ch/
	HardwareModel_NOMADSTAR_METEOR_PRO HardwareModel = 96
	// Elecrow CrowPanel Advance models, ESP32-S3 and TFT with SX1262 radio plugin
	HardwareModel_CROWPANEL HardwareModel = 97
	// *
	// Lilygo LINK32 board with sensors
	HardwareModel_LINK_32 HardwareModel = 98
	// *
	// Seeed Tracker L1
	HardwareModel_SEEED_WIO_TRACKER_L1 HardwareModel = 99
	// *
	// Seeed Tracker L1 EINK driver
	HardwareModel_SEEED_WIO_TRACKER_L1_EINK HardwareModel = 100
	// Reserved ID for future and past use
	HardwareModel_QWANTZ_TINY_ARMS HardwareModel = 101
	// *
	// Lilygo T-Deck Pro
	HardwareModel_T_DECK_PRO HardwareModel = 102
	// *
	// Lilygo TLora Pager
	HardwareModel_T_LORA_PAGER HardwareModel = 103
	// *
	// GAT562 Mesh Trial Tracker
	HardwareModel_GAT562_MESH_TRIAL_TRACKER HardwareModel = 104
	// *
	// RAKwireless WisMesh Tag
	HardwareModel_WISMESH_TAG HardwareModel = 105
	// *
	// RAKwireless WisBlock Core RAK3312 https://docs.rakwireless.com/product-categories/wisduo/rak3112-module/overview/
	HardwareModel_RAK3312 HardwareModel = 106
	// ------------------------------------------------------------------------------------------------------------------------------------------
	// Reserved ID For developing private Ports. These will show up in live traffic sparsely, so we can use a high number. Keep it within 8 bits.
	// ------------------------------------------------------------------------------------------------------------------------------------------
	HardwareModel_PRIVATE_HW HardwareModel = 255
)

// Enum value maps for HardwareModel.
var (
	HardwareModel_name = map[int32]string{
		0:   "UNSET",
		1:   "TLORA_V2",
		2:   "TLORA_V1",
		3:   "TLORA_V2_1_1P6",
		4:   "TBEAM",
		5:   "HELTEC_V2_0",
		6:   "TBEAM_V0P7",
		7:   "T_ECHO",
		8:   "TLORA_V1_1P3",
		9:   "RAK4631",
		10:  "HELTEC_V2_1",
		11:  "HELTEC_V1",
		12:  "LILYGO_TBEAM_S3_CORE",
		13:  "RAK11200",
		14:  "NANO_G1",
		15:  "TLORA_V2_1_1P8",
		16:  "TLORA_T3_S3",
		17:  "NANO_G1_EXPLORER",
		18:  "NANO_G2_ULTRA",
		19:  "LORA_TYPE",
		20:  "WIPHONE",
		21:  "WIO_WM1110",
		22:  "RAK2560",
		23:  "HELTEC_HRU_3601",
		24:  "HELTEC_WIRELESS_BRIDGE",
		25:  "STATION_G1",
		26:  "RAK11310",
		27:  "SENSELORA_RP2040",
		28:  "SENSELORA_S3",
		29:  "CANARYONE",
		30:  "RP2040_LORA",
		31:  "STATION_G2",
		32:  "LORA_RELAY_V1",
		33:  "NRF52840DK",
		34:  "PPR",
		35:  "GENIEBLOCKS",
		36:  "NRF52_UNKNOWN",
		37:  "PORTDUINO",
		38:  "ANDROID_SIM",
		39:  "DIY_V1",
		40:  "NRF52840_PCA10059",
		41:  "DR_DEV",
		42:  "M5STACK",
		43:  "HELTEC_V3",
		44:  "HELTEC_WSL_V3",
		45:  "BETAFPV_2400_TX",
		46:  "BETAFPV_900_NANO_TX",
		47:  "RPI_PICO",
		48:  "HELTEC_WIRELESS_TRACKER",
		49:  "HELTEC_WIRELESS_PAPER",
		50:  "T_DECK",
		51:  "T_WATCH_S3",
		52:  "PICOMPUTER_S3",
		53:  "HELTEC_HT62",
		54:  "EBYTE_ESP32_S3",
		55:  "ESP32_S3_PICO",
		56:  "CHATTER_2",
		57:  "HELTEC_WIRELESS_PAPER_V1_0",
		58:  "HELTEC_WIRELESS_TRACKER_V1_0",
		59:  "UNPHONE",
		60:  "TD_LORAC",
		61:  "CDEBYTE_EORA_S3",
		62:  "TWC_MESH_V4",
		63:  "NRF52_PROMICRO_DIY",
		64:  "RADIOMASTER_900_BANDIT_NANO",
		65:  "HELTEC_CAPSULE_SENSOR_V3",
		66:  "HELTEC_VISION_MASTER_T190",
		67:  "HELTEC_VISION_MASTER_E213",
		68:  "HELTEC_VISION_MASTER_E290",
		69:  "HELTEC_MESH_NODE_T114",
		70:  "SENSECAP_INDICATOR",
		71:  "TRACKER_T1000_E",
		72:  "RAK3172",
		73:  "WIO_E5",
		74:  "RADIOMASTER_900_BANDIT",
		75:  "ME25LS01_4Y10TD",
		76:  "RP2040_FEATHER_RFM95",
		77:  "M5STACK_COREBASIC",
		78:  "M5STACK_CORE2",
		79:  "RPI_PICO2",
		80:  "M5STACK_CORES3",
		81:  "SEEED_XIAO_S3",
		82:  "MS24SF1",
		83:  "TLORA_C6",
		84:  "WISMESH_TAP",
		85:  "ROUTASTIC",
		86:  "MESH_TAB",
		87:  "MESHLINK",
		88:  "XIAO_NRF52_KIT",
		89:  "THINKNODE_M1",
		90:  "THINKNODE_M2",
		91:  "T_ETH_ELITE",
		92:  "HELTEC_SENSOR_HUB",
		93:  "RESERVED_FRIED_CHICKEN",
		94:  "HELTEC_MESH_POCKET",
		95:  "SEEED_SOLAR_NODE",
		96:  "NOMADSTAR_METEOR_PRO",
		97:  "CROWPANEL",
		98:  "LINK_32",
		99:  "SEEED_WIO_TRACKER_L1",
		100: "SEEED_WIO_TRACKER_L1_EINK",
		101: "QWANTZ_TINY_ARMS",
		102: "T_DECK_PRO",
		103: "T_LORA_PAGER",
		104: "GAT562_MESH_TRIAL_TRACKER",
		105: "WISMESH_TAG",
		106: "RAK3312",
		255: "PRIVATE_HW",
	}
	HardwareModel_value = map[string]int32{
		"UNSET":                        0,
		"TLORA_V2":                     1,
		"TLORA_V1":                     2,
		"TLORA_V2_1_1P6":               3,
		"TBEAM":                        4,
		"HELTEC_V2_0":                  5,
		"TBEAM_V0P7":                   6,
		"T_ECHO":                       7,
		"TLORA_V1_1P3":                 8,
		"RAK4631":                      9,
		"HELTEC_V2_1":                  10,
		"HELTEC_V1":                    11,
		"LILYGO_TBEAM_S3_CORE":         12,
		"RAK11200":                     13,
		"NANO_G1":                      14,
		"TLORA_V2_1_1P8":               15,
		"TLORA_T3_S3":                  16,
		"NANO_G1_EXPLORER":             17,
		"NANO_G2_ULTRA":                18,
		"LORA_TYPE":                    19,
		"WIPHONE":                      20,
		"WIO_WM1110":                   21,
		"RAK2560":                      22,
		"HELTEC_HRU_3601":              23,
		"HELTEC_WIRELESS_BRIDGE":       24,
		"STATION_G1":                   25,
		"RAK11310":                     26,
		"SENSELORA_RP2040":             27,
		"SENSELORA_S3":                 28,
		"CANARYONE":                    29,
		"RP2040_LORA":                  30,
		"STATION_G2":                   31,
		"LORA_RELAY_V1":                32,
		"NRF52840DK":                   33,
		"PPR":                          34,
		"GENIEBLOCKS":                  35,
		"NRF52_UNKNOWN":                36,
		"PORTDUINO":                    37,
		"ANDROID_SIM":                  38,
		"DIY_V1":                       39,
		"NRF52840_PCA10059":            40,
		"DR_DEV":                       41,
		"M5STACK":                      42,
		"HELTEC_V3":                    43,
		"HELTEC_WSL_V3":                44,
		"BETAFPV_2400_TX":              45,
		"BETAFPV_900_NANO_TX":          46,
		"RPI_PICO":                     47,
		"HELTEC_WIRELESS_TRACKER":      48,
		"HELTEC_WIRELESS_PAPER":        49,
		"T_DECK":                       50,
		"T_WATCH_S3":                   51,
		"PICOMPUTER_S3":                52,
		"HELTEC_HT62":                  53,
		"EBYTE_ESP32_S3":               54,
		"ESP32_S3_PICO":                55,
		"CHATTER_2":                    56,
		"HELTEC_WIRELESS_PAPER_V1_0":   57,
		"HELTEC_WIRELESS_TRACKER_V1_0": 58,
		"UNPHONE":                      59,
		"TD_LORAC":                     60,
		"CDEBYTE_EORA_S3":              61,
		"TWC_MESH_V4":                  62,
		"NRF52_PROMICRO_DIY":           63,
		"RADIOMASTER_900_BANDIT_NANO":  64,
		"HELTEC_CAPSULE_SENSOR_V3":     65,
		"HELTEC_VISION_MASTER_T190":    66,
		"HELTEC_VISION_MASTER_E213":    67,
		"HELTEC_VISION_MASTER_E290":    68,
		"HELTEC_MESH_NODE_T114":        69,
		"SENSECAP_INDICATOR":           70,
		"TRACKER_T1000_E":              71,
		"RAK3172":                      72,
		"WIO_E5":                       73,
		"RADIOMASTER_900_BANDIT":       74,
		"ME25LS01_4Y10TD":              75,
		"RP2040_FEATHER_RFM95":         76,
		"M5STACK_COREBASIC":            77,
		"M5STACK_CORE2":                78,
		"RPI_PICO2":                    79,
		"M5STACK_CORES3":               80,
		"SEEED_XIAO_S3":                81,
		"MS24SF1":                      82,
		"TLORA_C6":                     83,
		"WISMESH_TAP":                  84,
		"ROUTASTIC":                    85,
		"MESH_TAB":                     86,
		"MESHLINK":                     87,
		"XIAO_NRF52_KIT":               88,
		"THINKNODE_M1":                 89,
		"THINKNODE_M2":                 90,
		"T_ETH_ELITE":                  91,
		"HELTEC_SENSOR_HUB":            92,
		"RESERVED_FRIED_CHICKEN":       93,
		"HELTEC_MESH_POCKET":           94,
		"SEEED_SOLAR_NODE":             95,
		"NOMADSTAR_METEOR_PRO":         96,
		"CROWPANEL":                    97,
		"LINK_32":                      98,
		"SEEED_WIO_TRACKER_L1":         99,
		"SEEED_WIO_TRACKER_L1_EINK":    100,
		"QWANTZ_TINY_ARMS":             101,
		"T_DECK_PRO":                   102,
		"T_LORA_PAGER":                 103,
		"GAT562_MESH_TRIAL_TRACKER":    104,
		"WISMESH_TAG":                  105,
		"RAK3312":                      106,
		"PRIVATE_HW":                   255,
	}
)

func (x HardwareModel) Enum() *HardwareModel {
	p := new(HardwareModel)
	*p = x
	return p
}

func (x HardwareModel) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (HardwareModel) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_mesh_proto_enumTypes[0].Descriptor()
}

func (HardwareModel) Type() protoreflect.EnumType {
	return &file_meshtastic_mesh_proto_enumTypes[0]
}

func (x HardwareModel) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use HardwareModel.Descriptor instead.
func (HardwareModel) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{0}
}

// Shared constants between device and phone
type Constants int32

const (
	// First enum must be zero, and we are just using this enum to
	// pass int constants between two very different environments
	Constants_ZERO Constants = 0
	// From mesh.options
	// note: this payload length is ONLY the bytes that are sent inside of the Data protobuf (excluding protobuf overhead). The 16 byte header is
	// outside of this envelope
	Constants_DATA_PAYLOAD_LEN Constants = 233
)

// Enum value maps for Constants.
var (
	Constants_name = map[int32]string{
		0:   "ZERO",
		233: "DATA_PAYLOAD_LEN",
	}
	Constants_value = map[string]int32{
		"ZERO":             0,
		"DATA_PAYLOAD_LEN": 233,
	}
)

func (x Constants) Enum() *Constants {
	p := new(Constants)
	*p = x
	return p
}

func (x Constants) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Constants) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_mesh_proto_enumTypes[1].Descriptor()
}

func (Constants) Type() protoreflect.EnumType {
	return &file_meshtastic_mesh_proto_enumTypes[1]
}

func (x Constants) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Constants.Descriptor instead.
func (Constants) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{1}
}

// Error codes for critical errors
// The device might report these fault codes on the screen.
// If you encounter a fault code, please post on the meshtastic.discourse.group
// and we'll try to help.
type CriticalErrorCode int32

const (
	// TODO: REPLACE
	CriticalErrorCode_NONE CriticalErrorCode = 0
	// A software bug was detected while trying to send lora
	CriticalErrorCode_TX_WATCHDOG CriticalErrorCode = 1
	// A software bug was detected on entry to sleep
	CriticalErrorCode_SLEEP_ENTER_WAIT CriticalErrorCode = 2
	// No Lora radio hardware could be found
	CriticalErrorCode_NO_RADIO CriticalErrorCode = 3
	// Not normally used
	CriticalErrorCode_UNSPECIFIED CriticalErrorCode = 4
	// We failed while configuring a UBlox GPS
	CriticalErrorCode_UBLOX_UNIT_FAILED CriticalErrorCode = 5
	// This board was expected to have a power management chip and it is missing or broken
	CriticalErrorCode_NO_AXP192 CriticalErrorCode = 6
	// The channel tried to set a radio setting which is not supported by this chipset,
	// radio comms settings are now undefined.
	CriticalErrorCode_INVALID_RADIO_SETTING CriticalErrorCode = 7
	// Radio transmit hardware failure. We sent data to the radio chip, but it didn't
	// reply with an interrupt.
	CriticalErrorCode_TRANSMIT_FAILED CriticalErrorCode = 8
	// We detected that the main CPU voltage dropped below the minimum acceptable value
	CriticalErrorCode_BROWNOUT CriticalErrorCode = 9
	// Selftest of SX1262 radio chip failed
	CriticalErrorCode_SX1262_FAILURE CriticalErrorCode = 10
	// A (likely software but possibly hardware) failure was detected while trying to send packets.
	// If this occurs on your board, please post in the forum so that we can ask you to collect some information to allow fixing this bug
	CriticalErrorCode_RADIO_SPI_BUG CriticalErrorCode = 11
	// Corruption was detected on the flash filesystem but we were able to repair things.
	// If you see this failure in the field please post in the forum because we are interested in seeing if this is occurring in the field.
	CriticalErrorCode_FLASH_CORRUPTION_RECOVERABLE CriticalErrorCode = 12
	// Corruption was detected on the flash filesystem but we were unable to repair things.
	// NOTE: Your node will probably need to be reconfigured the next time it reboots (it will lose the region code etc...)
	// If you see this failure in the field please post in the forum because we are interested in seeing if this is occurring in the field.
	CriticalErrorCode_FLASH_CORRUPTION_UNRECOVERABLE CriticalErrorCode = 13
)

// Enum value maps for CriticalErrorCode.
var (
	CriticalErrorCode_name = map[int32]string{
		0:  "NONE",
		1:  "TX_WATCHDOG",
		2:  "SLEEP_ENTER_WAIT",
		3:  "NO_RADIO",
		4:  "UNSPECIFIED",
		5:  "UBLOX_UNIT_FAILED",
		6:  "NO_AXP192",
		7:  "INVALID_RADIO_SETTING",
		8:  "TRANSMIT_FAILED",
		9:  "BROWNOUT",
		10: "SX1262_FAILURE",
		11: "RADIO_SPI_BUG",
		12: "FLASH_CORRUPTION_RECOVERABLE",
		13: "FLASH_CORRUPTION_UNRECOVERABLE",
	}
	CriticalErrorCode_value = map[string]int32{
		"NONE":                           0,
		"TX_WATCHDOG":                    1,
		"SLEEP_ENTER_WAIT":               2,
		"NO_RADIO":                       3,
		"UNSPECIFIED":                    4,
		"UBLOX_UNIT_FAILED":              5,
		"NO_AXP192":                      6,
		"INVALID_RADIO_SETTING":          7,
		"TRANSMIT_FAILED":                8,
		"BROWNOUT":                       9,
		"SX1262_FAILURE":                 10,
		"RADIO_SPI_BUG":                  11,
		"FLASH_CORRUPTION_RECOVERABLE":   12,
		"FLASH_CORRUPTION_UNRECOVERABLE": 13,
	}
)

func (x CriticalErrorCode) Enum() *CriticalErrorCode {
	p := new(CriticalErrorCode)
	*p = x
	return p
}

func (x CriticalErrorCode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CriticalErrorCode) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_mesh_proto_enumTypes[2].Descriptor()
}

func (CriticalErrorCode) Type() protoreflect.EnumType {
	return &file_meshtastic_mesh_proto_enumTypes[2]
}

func (x CriticalErrorCode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CriticalErrorCode.Descriptor instead.
func (CriticalErrorCode) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{2}
}

// Enum for modules excluded from a device's configuration.
// Each value represents a ModuleConfigType that can be toggled as excluded
// by setting its corresponding bit in the `excluded_modules` bitmask field.
type ExcludedModules int32

const (
	// Default value of 0 indicates no modules are excluded.
	ExcludedModules_EXCLUDED_NONE ExcludedModules = 0
	// MQTT module
	ExcludedModules_MQTT_CONFIG ExcludedModules = 1
	// Serial module
	ExcludedModules_SERIAL_CONFIG ExcludedModules = 2
	// External Notification module
	ExcludedModules_EXTNOTIF_CONFIG ExcludedModules = 4
	// Store and Forward module
	ExcludedModules_STOREFORWARD_CONFIG ExcludedModules = 8
	// Range Test module
	ExcludedModules_RANGETEST_CONFIG ExcludedModules = 16
	// Telemetry module
	ExcludedModules_TELEMETRY_CONFIG ExcludedModules = 32
	// Canned Message module
	ExcludedModules_CANNEDMSG_CONFIG ExcludedModules = 64
	// Audio module
	ExcludedModules_AUDIO_CONFIG ExcludedModules = 128
	// Remote Hardware module
	ExcludedModules_REMOTEHARDWARE_CONFIG ExcludedModules = 256
	// Neighbor Info module
	ExcludedModules_NEIGHBORINFO_CONFIG ExcludedModules = 512
	// Ambient Lighting module
	ExcludedModules_AMBIENTLIGHTING_CONFIG ExcludedModules = 1024
	// Detection Sensor module
	ExcludedModules_DETECTIONSENSOR_CONFIG ExcludedModules = 2048
	// Paxcounter module
	ExcludedModules_PAXCOUNTER_CONFIG ExcludedModules = 4096
	// Bluetooth config (not technically a module, but used to indicate bluetooth capabilities)
	ExcludedModules_BLUETOOTH_CONFIG ExcludedModules = 8192
	// Network config (not technically a module, but used to indicate network capabilities)
	ExcludedModules_NETWORK_CONFIG ExcludedModules = 16384
)

// Enum value maps for ExcludedModules.
var (
	ExcludedModules_name = map[int32]string{
		0:     "EXCLUDED_NONE",
		1:     "MQTT_CONFIG",
		2:     "SERIAL_CONFIG",
		4:     "EXTNOTIF_CONFIG",
		8:     "STOREFORWARD_CONFIG",
		16:    "RANGETEST_CONFIG",
		32:    "TELEMETRY_CONFIG",
		64:    "CANNEDMSG_CONFIG",
		128:   "AUDIO_CONFIG",
		256:   "REMOTEHARDWARE_CONFIG",
		512:   "NEIGHBORINFO_CONFIG",
		1024:  "AMBIENTLIGHTING_CONFIG",
		2048:  "DETECTIONSENSOR_CONFIG",
		4096:  "PAXCOUNTER_CONFIG",
		8192:  "BLUETOOTH_CONFIG",
		16384: "NETWORK_CONFIG",
	}
	ExcludedModules_value = map[string]int32{
		"EXCLUDED_NONE":          0,
		"MQTT_CONFIG":            1,
		"SERIAL_CONFIG":          2,
		"EXTNOTIF_CONFIG":        4,
		"STOREFORWARD_CONFIG":    8,
		"RANGETEST_CONFIG":       16,
		"TELEMETRY_CONFIG":       32,
		"CANNEDMSG_CONFIG":       64,
		"AUDIO_CONFIG":           128,
		"REMOTEHARDWARE_CONFIG":  256,
		"NEIGHBORINFO_CONFIG":    512,
		"AMBIENTLIGHTING_CONFIG": 1024,
		"DETECTIONSENSOR_CONFIG": 2048,
		"PAXCOUNTER_CONFIG":      4096,
		"BLUETOOTH_CONFIG":       8192,
		"NETWORK_CONFIG":         16384,
	}
)

func (x ExcludedModules) Enum() *ExcludedModules {
	p := new(ExcludedModules)
	*p = x
	return p
}

func (x ExcludedModules) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ExcludedModules) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_mesh_proto_enumTypes[3].Descriptor()
}

func (ExcludedModules) Type() protoreflect.EnumType {
	return &file_meshtastic_mesh_proto_enumTypes[3]
}

func (x ExcludedModules) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ExcludedModules.Descriptor instead.
func (ExcludedModules) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{3}
}

// How the location was acquired: manual, onboard GPS, external (EUD) GPS
type Position_LocSource int32

const (
	// TODO: REPLACE
	Position_LOC_UNSET Position_LocSource = 0
	// TODO: REPLACE
	Position_LOC_MANUAL Position_LocSource = 1
	// TODO: REPLACE
	Position_LOC_INTERNAL Position_LocSource = 2
	// TODO: REPLACE
	Position_LOC_EXTERNAL Position_LocSource = 3
)

// Enum value maps for Position_LocSource.
var (
	Position_LocSource_name = map[int32]string{
		0: "LOC_UNSET",
		1: "LOC_MANUAL",
		2: "LOC_INTERNAL",
		3: "LOC_EXTERNAL",
	}
	Position_LocSource_value = map[string]int32{
		"LOC_UNSET":    0,
		"LOC_MANUAL":   1,
		"LOC_INTERNAL": 2,
		"LOC_EXTERNAL": 3,
	}
)

func (x Position_LocSource) Enum() *Position_LocSource {
	p := new(Position_LocSource)
	*p = x
	return p
}

func (x Position_LocSource) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Position_LocSource) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_mesh_proto_enumTypes[4].Descriptor()
}

func (Position_LocSource) Type() protoreflect.EnumType {
	return &file_meshtastic_mesh_proto_enumTypes[4]
}

func (x Position_LocSource) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Position_LocSource.Descriptor instead.
func (Position_LocSource) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{0, 0}
}

// How the altitude was acquired: manual, GPS int/ext, etc
// Default: same as location_source if present
type Position_AltSource int32

const (
	// TODO: REPLACE
	Position_ALT_UNSET Position_AltSource = 0
	// TODO: REPLACE
	Position_ALT_MANUAL Position_AltSource = 1
	// TODO: REPLACE
	Position_ALT_INTERNAL Position_AltSource = 2
	// TODO: REPLACE
	Position_ALT_EXTERNAL Position_AltSource = 3
	// TODO: REPLACE
	Position_ALT_BAROMETRIC Position_AltSource = 4
)

// Enum value maps for Position_AltSource.
var (
	Position_AltSource_name = map[int32]string{
		0: "ALT_UNSET",
		1: "ALT_MANUAL",
		2: "ALT_INTERNAL",
		3: "ALT_EXTERNAL",
		4: "ALT_BAROMETRIC",
	}
	Position_AltSource_value = map[string]int32{
		"ALT_UNSET":      0,
		"ALT_MANUAL":     1,
		"ALT_INTERNAL":   2,
		"ALT_EXTERNAL":   3,
		"ALT_BAROMETRIC": 4,
	}
)

func (x Position_AltSource) Enum() *Position_AltSource {
	p := new(Position_AltSource)
	*p = x
	return p
}

func (x Position_AltSource) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Position_AltSource) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_mesh_proto_enumTypes[5].Descriptor()
}

func (Position_AltSource) Type() protoreflect.EnumType {
	return &file_meshtastic_mesh_proto_enumTypes[5]
}

func (x Position_AltSource) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Position_AltSource.Descriptor instead.
func (Position_AltSource) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{0, 1}
}

// A failure in delivering a message (usually used for routing control messages, but might be provided in addition to ack.fail_id to provide
// details on the type of failure).
type Routing_Error int32

const (
	// This message is not a failure
	Routing_NONE Routing_Error = 0
	// Our node doesn't have a route to the requested destination anymore.
	Routing_NO_ROUTE Routing_Error = 1
	// We received a nak while trying to forward on your behalf
	Routing_GOT_NAK Routing_Error = 2
	// TODO: REPLACE
	Routing_TIMEOUT Routing_Error = 3
	// No suitable interface could be found for delivering this packet
	Routing_NO_INTERFACE Routing_Error = 4
	// We reached the max retransmission count (typically for naive flood routing)
	Routing_MAX_RETRANSMIT Routing_Error = 5
	// No suitable channel was found for sending this packet (i.e. was requested channel index disabled?)
	Routing_NO_CHANNEL Routing_Error = 6
	// The packet was too big for sending (exceeds interface MTU after encoding)
	Routing_TOO_LARGE Routing_Error = 7
	// The request had want_response set, the request reached the destination node, but no service on that node wants to send a response
	// (possibly due to bad channel permissions)
	Routing_NO_RESPONSE Routing_Error = 8
	// Cannot send currently because duty cycle regulations will be violated.
	Routing_DUTY_CYCLE_LIMIT Routing_Error = 9
	// The application layer service on the remote node received your request, but considered your request somehow invalid
	Routing_BAD_REQUEST Routing_Error = 32
	// The application layer service on the remote node received your request, but considered your request not authorized
	// (i.e you did not send the request on the required bound channel)
	Routing_NOT_AUTHORIZED Routing_Error = 33
	// The client specified a PKI transport, but the node was unable to send the packet using PKI (and did not send the message at all)
	Routing_PKI_FAILED Routing_Error = 34
	// The receiving node does not have a Public Key to decode with
	Routing_PKI_UNKNOWN_PUBKEY Routing_Error = 35
	// Admin packet otherwise checks out, but uses a bogus or expired session key
	Routing_ADMIN_BAD_SESSION_KEY Routing_Error = 36
	// Admin packet sent using PKC, but not from a public key on the admin key list
	Routing_ADMIN_PUBLIC_KEY_UNAUTHORIZED Routing_Error = 37
)

// Enum value maps for Routing_Error.
var (
	Routing_Error_name = map[int32]string{
		0:  "NONE",
		1:  "NO_ROUTE",
		2:  "GOT_NAK",
		3:  "TIMEOUT",
		4:  "NO_INTERFACE",
		5:  "MAX_RETRANSMIT",
		6:  "NO_CHANNEL",
		7:  "TOO_LARGE",
		8:  "NO_RESPONSE",
		9:  "DUTY_CYCLE_LIMIT",
		32: "BAD_REQUEST",
		33: "NOT_AUTHORIZED",
		34: "PKI_FAILED",
		35: "PKI_UNKNOWN_PUBKEY",
		36: "ADMIN_BAD_SESSION_KEY",
		37: "ADMIN_PUBLIC_KEY_UNAUTHORIZED",
	}
	Routing_Error_value = map[string]int32{
		"NONE":                          0,
		"NO_ROUTE":                      1,
		"GOT_NAK":                       2,
		"TIMEOUT":                       3,
		"NO_INTERFACE":                  4,
		"MAX_RETRANSMIT":                5,
		"NO_CHANNEL":                    6,
		"TOO_LARGE":                     7,
		"NO_RESPONSE":                   8,
		"DUTY_CYCLE_LIMIT":              9,
		"BAD_REQUEST":                   32,
		"NOT_AUTHORIZED":                33,
		"PKI_FAILED":                    34,
		"PKI_UNKNOWN_PUBKEY":            35,
		"ADMIN_BAD_SESSION_KEY":         36,
		"ADMIN_PUBLIC_KEY_UNAUTHORIZED": 37,
	}
)

func (x Routing_Error) Enum() *Routing_Error {
	p := new(Routing_Error)
	*p = x
	return p
}

func (x Routing_Error) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Routing_Error) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_mesh_proto_enumTypes[6].Descriptor()
}

func (Routing_Error) Type() protoreflect.EnumType {
	return &file_meshtastic_mesh_proto_enumTypes[6]
}

func (x Routing_Error) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Routing_Error.Descriptor instead.
func (Routing_Error) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{3, 0}
}

// The priority of this message for sending.
// Higher priorities are sent first (when managing the transmit queue).
// This field is never sent over the air, it is only used internally inside of a local device node.
// API clients (either on the local node or connected directly to the node)
// can set this parameter if necessary.
// (values must be <= 127 to keep protobuf field to one byte in size.
// Detailed background on this field:
// I noticed a funny side effect of lora being so slow: Usually when making
// a protocol there isnâ€™t much need to use message priority to change the order
// of transmission (because interfaces are fairly fast).
// But for lora where packets can take a few seconds each, it is very important
// to make sure that critical packets are sent ASAP.
// In the case of meshtastic that means we want to send protocol acks as soon as possible
// (to prevent unneeded retransmissions), we want routing messages to be sent next,
// then messages marked as reliable and finally 'background' packets like periodic position updates.
// So I bit the bullet and implemented a new (internal - not sent over the air)
// field in MeshPacket called 'priority'.
// And the transmission queue in the router object is now a priority queue.
type MeshPacket_Priority int32

const (
	// Treated as Priority.DEFAULT
	MeshPacket_UNSET MeshPacket_Priority = 0
	// TODO: REPLACE
	MeshPacket_MIN MeshPacket_Priority = 1
	// Background position updates are sent with very low priority -
	// if the link is super congested they might not go out at all
	MeshPacket_BACKGROUND MeshPacket_Priority = 10
	// This priority is used for most messages that don't have a priority set
	MeshPacket_DEFAULT MeshPacket_Priority = 64
	// If priority is unset but the message is marked as want_ack,
	// assume it is important and use a slightly higher priority
	MeshPacket_RELIABLE MeshPacket_Priority = 70
	// If priority is unset but the packet is a response to a request, we want it to get there relatively quickly.
	// Furthermore, responses stop relaying packets directed to a node early.
	MeshPacket_RESPONSE MeshPacket_Priority = 80
	// Higher priority for specific message types (portnums) to distinguish between other reliable packets.
	MeshPacket_HIGH MeshPacket_Priority = 100
	// Higher priority alert message used for critical alerts which take priority over other reliable packets.
	MeshPacket_ALERT MeshPacket_Priority = 110
	// Ack/naks are sent with very high priority to ensure that retransmission
	// stops as soon as possible
	MeshPacket_ACK MeshPacket_Priority = 120
	// TODO: REPLACE
	MeshPacket_MAX MeshPacket_Priority = 127
)

// Enum value maps for MeshPacket_Priority.
var (
	MeshPacket_Priority_name = map[int32]string{
		0:   "UNSET",
		1:   "MIN",
		10:  "BACKGROUND",
		64:  "DEFAULT",
		70:  "RELIABLE",
		80:  "RESPONSE",
		100: "HIGH",
		110: "ALERT",
		120: "ACK",
		127: "MAX",
	}
	MeshPacket_Priority_value = map[string]int32{
		"UNSET":      0,
		"MIN":        1,
		"BACKGROUND": 10,
		"DEFAULT":    64,
		"RELIABLE":   70,
		"RESPONSE":   80,
		"HIGH":       100,
		"ALERT":      110,
		"ACK":        120,
		"MAX":        127,
	}
)

func (x MeshPacket_Priority) Enum() *MeshPacket_Priority {
	p := new(MeshPacket_Priority)
	*p = x
	return p
}

func (x MeshPacket_Priority) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MeshPacket_Priority) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_mesh_proto_enumTypes[7].Descriptor()
}

func (MeshPacket_Priority) Type() protoreflect.EnumType {
	return &file_meshtastic_mesh_proto_enumTypes[7]
}

func (x MeshPacket_Priority) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MeshPacket_Priority.Descriptor instead.
func (MeshPacket_Priority) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{8, 0}
}

// Identify if this is a delayed packet
type MeshPacket_Delayed int32

const (
	// If unset, the message is being sent in real time.
	MeshPacket_NO_DELAY MeshPacket_Delayed = 0
	// The message is delayed and was originally a broadcast
	MeshPacket_DELAYED_BROADCAST MeshPacket_Delayed = 1
	// The message is delayed and was originally a direct message
	MeshPacket_DELAYED_DIRECT MeshPacket_Delayed = 2
)

// Enum value maps for MeshPacket_Delayed.
var (
	MeshPacket_Delayed_name = map[int32]string{
		0: "NO_DELAY",
		1: "DELAYED_BROADCAST",
		2: "DELAYED_DIRECT",
	}
	MeshPacket_Delayed_value = map[string]int32{
		"NO_DELAY":          0,
		"DELAYED_BROADCAST": 1,
		"DELAYED_DIRECT":    2,
	}
)

func (x MeshPacket_Delayed) Enum() *MeshPacket_Delayed {
	p := new(MeshPacket_Delayed)
	*p = x
	return p
}

func (x MeshPacket_Delayed) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MeshPacket_Delayed) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_mesh_proto_enumTypes[8].Descriptor()
}

func (MeshPacket_Delayed) Type() protoreflect.EnumType {
	return &file_meshtastic_mesh_proto_enumTypes[8]
}

func (x MeshPacket_Delayed) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MeshPacket_Delayed.Descriptor instead.
func (MeshPacket_Delayed) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{8, 1}
}

// Log levels, chosen to match python logging conventions.
type LogRecord_Level int32

const (
	// Log levels, chosen to match python logging conventions.
	LogRecord_UNSET LogRecord_Level = 0
	// Log levels, chosen to match python logging conventions.
	LogRecord_CRITICAL LogRecord_Level = 50
	// Log levels, chosen to match python logging conventions.
	LogRecord_ERROR LogRecord_Level = 40
	// Log levels, chosen to match python logging conventions.
	LogRecord_WARNING LogRecord_Level = 30
	// Log levels, chosen to match python logging conventions.
	LogRecord_INFO LogRecord_Level = 20
	// Log levels, chosen to match python logging conventions.
	LogRecord_DEBUG LogRecord_Level = 10
	// Log levels, chosen to match python logging conventions.
	LogRecord_TRACE LogRecord_Level = 5
)

// Enum value maps for LogRecord_Level.
var (
	LogRecord_Level_name = map[int32]string{
		0:  "UNSET",
		50: "CRITICAL",
		40: "ERROR",
		30: "WARNING",
		20: "INFO",
		10: "DEBUG",
		5:  "TRACE",
	}
	LogRecord_Level_value = map[string]int32{
		"UNSET":    0,
		"CRITICAL": 50,
		"ERROR":    40,
		"WARNING":  30,
		"INFO":     20,
		"DEBUG":    10,
		"TRACE":    5,
	}
)

func (x LogRecord_Level) Enum() *LogRecord_Level {
	p := new(LogRecord_Level)
	*p = x
	return p
}

func (x LogRecord_Level) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LogRecord_Level) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_mesh_proto_enumTypes[9].Descriptor()
}

func (LogRecord_Level) Type() protoreflect.EnumType {
	return &file_meshtastic_mesh_proto_enumTypes[9]
}

func (x LogRecord_Level) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use LogRecord_Level.Descriptor instead.
func (LogRecord_Level) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{11, 0}
}

// A GPS Position
type Position struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The new preferred location encoding, multiply by 1e-7 to get degrees
	// in floating point
	LatitudeI *int32 `protobuf:"fixed32,1,opt,name=latitude_i,json=latitudeI,proto3,oneof" json:"latitude_i,omitempty"`
	// TODO: REPLACE
	LongitudeI *int32 `protobuf:"fixed32,2,opt,name=longitude_i,json=longitudeI,proto3,oneof" json:"longitude_i,omitempty"`
	// In meters above MSL (but see issue #359)
	Altitude *int32 `protobuf:"varint,3,opt,name=altitude,proto3,oneof" json:"altitude,omitempty"`
	// This is usually not sent over the mesh (to save space), but it is sent
	// from the phone so that the local device can set its time if it is sent over
	// the mesh (because there are devices on the mesh without GPS or RTC).
	// seconds since 1970
	Time uint32 `protobuf:"fixed32,4,opt,name=time,proto3" json:"time,omitempty"`
	// TODO: REPLACE
	LocationSource Position_LocSource `protobuf:"varint,5,opt,name=location_source,json=locationSource,proto3,enum=meshtastic.Position_LocSource" json:"location_source,omitempty"`
	// TODO: REPLACE
	AltitudeSource Position_AltSource `protobuf:"varint,6,opt,name=altitude_source,json=altitudeSource,proto3,enum=meshtastic.Position_AltSource" json:"altitude_source,omitempty"`
	// Positional timestamp (actual timestamp of GPS solution) in integer epoch seconds
	Timestamp uint32 `protobuf:"fixed32,7,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Pos. timestamp milliseconds adjustment (rarely available or required)
	TimestampMillisAdjust int32 `protobuf:"varint,8,opt,name=timestamp_millis_adjust,json=timestampMillisAdjust,proto3" json:"timestamp_millis_adjust,omitempty"`
	// HAE altitude in meters - can be used instead of MSL altitude
	AltitudeHae *int32 `protobuf:"zigzag32,9,opt,name=altitude_hae,json=altitudeHae,proto3,oneof" json:"altitude_hae,omitempty"`
	// Geoidal separation in meters
	AltitudeGeoidalSeparation *int32 `protobuf:"zigzag32,10,opt,name=altitude_geoidal_separation,json=altitudeGeoidalSeparation,proto3,oneof" json:"altitude_geoidal_separation,omitempty"`
	// Horizontal, Vertical and Position Dilution of Precision, in 1/100 units
	//   - PDOP is sufficient for most cases
	//   - for higher precision scenarios, HDOP and VDOP can be used instead,
	//     in which case PDOP becomes redundant (PDOP=sqrt(HDOP^2 + VDOP^2))
	//
	// TODO: REMOVE/INTEGRATE
	PDOP uint32 `protobuf:"varint,11,opt,name=PDOP,proto3" json:"PDOP,omitempty"`
	// TODO: REPLACE
	HDOP uint32 `protobuf:"varint,12,opt,name=HDOP,proto3" json:"HDOP,omitempty"`
	// TODO: REPLACE
	VDOP uint32 `protobuf:"varint,13,opt,name=VDOP,proto3" json:"VDOP,omitempty"`
	// GPS accuracy (a hardware specific constant) in mm
	//
	//	multiplied with DOP to calculate positional accuracy
	//
	// Default: "'bout three meters-ish" :)
	GpsAccuracy uint32 `protobuf:"varint,14,opt,name=gps_accuracy,json=gpsAccuracy,proto3" json:"gps_accuracy,omitempty"`
	// Ground speed in m/s and True North TRACK in 1/100 degrees
	// Clarification of terms:
	// - "track" is the direction of motion (measured in horizontal plane)
	// - "heading" is where the fuselage points (measured in horizontal plane)
	// - "yaw" indicates a relative rotation about the vertical axis
	// TODO: REMOVE/INTEGRATE
	GroundSpeed *uint32 `protobuf:"varint,15,opt,name=ground_speed,json=groundSpeed,proto3,oneof" json:"ground_speed,omitempty"`
	// TODO: REPLACE
	GroundTrack *uint32 `protobuf:"varint,16,opt,name=ground_track,json=groundTrack,proto3,oneof" json:"ground_track,omitempty"`
	// GPS fix quality (from NMEA GxGGA statement or similar)
	FixQuality uint32 `protobuf:"varint,17,opt,name=fix_quality,json=fixQuality,proto3" json:"fix_quality,omitempty"`
	// GPS fix type 2D/3D (from NMEA GxGSA statement)
	FixType uint32 `protobuf:"varint,18,opt,name=fix_type,json=fixType,proto3" json:"fix_type,omitempty"`
	// GPS "Satellites in View" number
	SatsInView uint32 `protobuf:"varint,19,opt,name=sats_in_view,json=satsInView,proto3" json:"sats_in_view,omitempty"`
	// Sensor ID - in case multiple positioning sensors are being used
	SensorId uint32 `protobuf:"varint,20,opt,name=sensor_id,json=sensorId,proto3" json:"sensor_id,omitempty"`
	// Estimated/expected time (in seconds) until next update:
	//   - if we update at fixed intervals of X seconds, use X
	//   - if we update at dynamic intervals (based on relative movement etc),
	//     but "AT LEAST every Y seconds", use Y
	NextUpdate uint32 `protobuf:"varint,21,opt,name=next_update,json=nextUpdate,proto3" json:"next_update,omitempty"`
	// A sequence number, incremented with each Position message to help
	//
	//	detect lost updates if needed
	SeqNumber uint32 `protobuf:"varint,22,opt,name=seq_number,json=seqNumber,proto3" json:"seq_number,omitempty"`
	// Indicates the bits of precision set by the sending node
	PrecisionBits uint32 `protobuf:"varint,23,opt,name=precision_bits,json=precisionBits,proto3" json:"precision_bits,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Position) Reset() {
	*x = Position{}
	mi := &file_meshtastic_mesh_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Position) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Position) ProtoMessage() {}

func (x *Position) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Position.ProtoReflect.Descriptor instead.
func (*Position) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{0}
}

func (x *Position) GetLatitudeI() int32 {
	if x != nil && x.LatitudeI != nil {
		return *x.LatitudeI
	}
	return 0
}

func (x *Position) GetLongitudeI() int32 {
	if x != nil && x.LongitudeI != nil {
		return *x.LongitudeI
	}
	return 0
}

func (x *Position) GetAltitude() int32 {
	if x != nil && x.Altitude != nil {
		return *x.Altitude
	}
	return 0
}

func (x *Position) GetTime() uint32 {
	if x != nil {
		return x.Time
	}
	return 0
}

func (x *Position) GetLocationSource() Position_LocSource {
	if x != nil {
		return x.LocationSource
	}
	return Position_LOC_UNSET
}

func (x *Position) GetAltitudeSource() Position_AltSource {
	if x != nil {
		return x.AltitudeSource
	}
	return Position_ALT_UNSET
}

func (x *Position) GetTimestamp() uint32 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *Position) GetTimestampMillisAdjust() int32 {
	if x != nil {
		return x.TimestampMillisAdjust
	}
	return 0
}

func (x *Position) GetAltitudeHae() int32 {
	if x != nil && x.AltitudeHae != nil {
		return *x.AltitudeHae
	}
	return 0
}

func (x *Position) GetAltitudeGeoidalSeparation() int32 {
	if x != nil && x.AltitudeGeoidalSeparation != nil {
		return *x.AltitudeGeoidalSeparation
	}
	return 0
}

func (x *Position) GetPDOP() uint32 {
	if x != nil {
		return x.PDOP
	}
	return 0
}

func (x *Position) GetHDOP() uint32 {
	if x != nil {
		return x.HDOP
	}
	return 0
}

func (x *Position) GetVDOP() uint32 {
	if x != nil {
		return x.VDOP
	}
	return 0
}

func (x *Position) GetGpsAccuracy() uint32 {
	if x != nil {
		return x.GpsAccuracy
	}
	return 0
}

func (x *Position) GetGroundSpeed() uint32 {
	if x != nil && x.GroundSpeed != nil {
		return *x.GroundSpeed
	}
	return 0
}

func (x *Position) GetGroundTrack() uint32 {
	if x != nil && x.GroundTrack != nil {
		return *x.GroundTrack
	}
	return 0
}

func (x *Position) GetFixQuality() uint32 {
	if x != nil {
		return x.FixQuality
	}
	return 0
}

func (x *Position) GetFixType() uint32 {
	if x != nil {
		return x.FixType
	}
	return 0
}

func (x *Position) GetSatsInView() uint32 {
	if x != nil {
		return x.SatsInView
	}
	return 0
}

func (x *Position) GetSensorId() uint32 {
	if x != nil {
		return x.SensorId
	}
	return 0
}

func (x *Position) GetNextUpdate() uint32 {
	if x != nil {
		return x.NextUpdate
	}
	return 0
}

func (x *Position) GetSeqNumber() uint32 {
	if x != nil {
		return x.SeqNumber
	}
	return 0
}

func (x *Position) GetPrecisionBits() uint32 {
	if x != nil {
		return x.PrecisionBits
	}
	return 0
}

// Broadcast when a newly powered mesh node wants to find a node num it can use
// Sent from the phone over bluetooth to set the user id for the owner of this node.
// Also sent from nodes to each other when a new node signs on (so all clients can have this info)
// The algorithm is as follows:
// when a node starts up, it broadcasts their user and the normal flow is for all
// other nodes to reply with their User as well (so the new node can build its nodedb)
// If a node ever receives a User (not just the first broadcast) message where
// the sender node number equals our node number, that indicates a collision has
// occurred and the following steps should happen:
// If the receiving node (that was already in the mesh)'s macaddr is LOWER than the
// new User who just tried to sign in: it gets to keep its nodenum.
// We send a broadcast message of OUR User (we use a broadcast so that the other node can
// receive our message, considering we have the same id - it also serves to let
// observers correct their nodedb) - this case is rare so it should be okay.
// If any node receives a User where the macaddr is GTE than their local macaddr,
// they have been vetoed and should pick a new random nodenum (filtering against
// whatever it knows about the nodedb) and rebroadcast their User.
// A few nodenums are reserved and will never be requested:
// 0xff - broadcast
// 0 through 3 - for future use
type User struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A globally unique ID string for this user.
	// In the case of Signal that would mean +16504442323, for the default macaddr derived id it would be !<8 hexidecimal bytes>.
	// Note: app developers are encouraged to also use the following standard
	// node IDs "^all" (for broadcast), "^local" (for the locally connected node)
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// A full name for this user, i.e. "Kevin Hester"
	LongName string `protobuf:"bytes,2,opt,name=long_name,json=longName,proto3" json:"long_name,omitempty"`
	// A VERY short name, ideally two characters.
	// Suitable for a tiny OLED screen
	ShortName string `protobuf:"bytes,3,opt,name=short_name,json=shortName,proto3" json:"short_name,omitempty"`
	// Deprecated in Meshtastic 2.1.x
	// This is the addr of the radio.
	// Not populated by the phone, but added by the esp32 when broadcasting
	//
	// Deprecated: Marked as deprecated in meshtastic/mesh.proto.
	Macaddr []byte `protobuf:"bytes,4,opt,name=macaddr,proto3" json:"macaddr,omitempty"`
	// TBEAM, HELTEC, etc...
	// Starting in 1.2.11 moved to hw_model enum in the NodeInfo object.
	// Apps will still need the string here for older builds
	// (so OTA update can find the right image), but if the enum is available it will be used instead.
	HwModel HardwareModel `protobuf:"varint,5,opt,name=hw_model,json=hwModel,proto3,enum=meshtastic.HardwareModel" json:"hw_model,omitempty"`
	// In some regions Ham radio operators have different bandwidth limitations than others.
	// If this user is a licensed operator, set this flag.
	// Also, "long_name" should be their licence number.
	IsLicensed bool `protobuf:"varint,6,opt,name=is_licensed,json=isLicensed,proto3" json:"is_licensed,omitempty"`
	// Indicates that the user's role in the mesh
	Role Config_DeviceConfig_Role `protobuf:"varint,7,opt,name=role,proto3,enum=meshtastic.Config_DeviceConfig_Role" json:"role,omitempty"`
	// The public key of the user's device.
	// This is sent out to other nodes on the mesh to allow them to compute a shared secret key.
	PublicKey []byte `protobuf:"bytes,8,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// Whether or not the node can be messaged
	IsUnmessagable *bool `protobuf:"varint,9,opt,name=is_unmessagable,json=isUnmessagable,proto3,oneof" json:"is_unmessagable,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *User) Reset() {
	*x = User{}
	mi := &file_meshtastic_mesh_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *User) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*User) ProtoMessage() {}

func (x *User) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use User.ProtoReflect.Descriptor instead.
func (*User) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{1}
}

func (x *User) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *User) GetLongName() string {
	if x != nil {
		return x.LongName
	}
	return ""
}

func (x *User) GetShortName() string {
	if x != nil {
		return x.ShortName
	}
	return ""
}

// Deprecated: Marked as deprecated in meshtastic/mesh.proto.
func (x *User) GetMacaddr() []byte {
	if x != nil {
		return x.Macaddr
	}
	return nil
}

func (x *User) GetHwModel() HardwareModel {
	if x != nil {
		return x.HwModel
	}
	return HardwareModel_UNSET
}

func (x *User) GetIsLicensed() bool {
	if x != nil {
		return x.IsLicensed
	}
	return false
}

func (x *User) GetRole() Config_DeviceConfig_Role {
	if x != nil {
		return x.Role
	}
	return Config_DeviceConfig_CLIENT
}

func (x *User) GetPublicKey() []byte {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

func (x *User) GetIsUnmessagable() bool {
	if x != nil && x.IsUnmessagable != nil {
		return *x.IsUnmessagable
	}
	return false
}

// A message used in a traceroute
type RouteDiscovery struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The list of nodenums this packet has visited so far to the destination.
	Route []uint32 `protobuf:"fixed32,1,rep,packed,name=route,proto3" json:"route,omitempty"`
	// The list of SNRs (in dB, scaled by 4) in the route towards the destination.
	SnrTowards []int32 `protobuf:"varint,2,rep,packed,name=snr_towards,json=snrTowards,proto3" json:"snr_towards,omitempty"`
	// The list of nodenums the packet has visited on the way back from the destination.
	RouteBack []uint32 `protobuf:"fixed32,3,rep,packed,name=route_back,json=routeBack,proto3" json:"route_back,omitempty"`
	// The list of SNRs (in dB, scaled by 4) in the route back from the destination.
	SnrBack       []int32 `protobuf:"varint,4,rep,packed,name=snr_back,json=snrBack,proto3" json:"snr_back,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RouteDiscovery) Reset() {
	*x = RouteDiscovery{}
	mi := &file_meshtastic_mesh_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RouteDiscovery) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteDiscovery) ProtoMessage() {}

func (x *RouteDiscovery) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteDiscovery.ProtoReflect.Descriptor instead.
func (*RouteDiscovery) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{2}
}

func (x *RouteDiscovery) GetRoute() []uint32 {
	if x != nil {
		return x.Route
	}
	return nil
}

func (x *RouteDiscovery) GetSnrTowards() []int32 {
	if x != nil {
		return x.SnrTowards
	}
	return nil
}

func (x *RouteDiscovery) GetRouteBack() []uint32 {
	if x != nil {
		return x.RouteBack
	}
	return nil
}

func (x *RouteDiscovery) GetSnrBack() []int32 {
	if x != nil {
		return x.SnrBack
	}
	return nil
}

// A Routing control Data packet handled by the routing module
type Routing struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Variant:
	//
	//	*Routing_RouteRequest
	//	*Routing_RouteReply
	//	*Routing_ErrorReason
	Variant       isRouting_Variant `protobuf_oneof:"variant"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Routing) Reset() {
	*x = Routing{}
	mi := &file_meshtastic_mesh_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Routing) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Routing) ProtoMessage() {}

func (x *Routing) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Routing.ProtoReflect.Descriptor instead.
func (*Routing) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{3}
}

func (x *Routing) GetVariant() isRouting_Variant {
	if x != nil {
		return x.Variant
	}
	return nil
}

func (x *Routing) GetRouteRequest() *RouteDiscovery {
	if x != nil {
		if x, ok := x.Variant.(*Routing_RouteRequest); ok {
			return x.RouteRequest
		}
	}
	return nil
}

func (x *Routing) GetRouteReply() *RouteDiscovery {
	if x != nil {
		if x, ok := x.Variant.(*Routing_RouteReply); ok {
			return x.RouteReply
		}
	}
	return nil
}

func (x *Routing) GetErrorReason() Routing_Error {
	if x != nil {
		if x, ok := x.Variant.(*Routing_ErrorReason); ok {
			return x.ErrorReason
		}
	}
	return Routing_NONE
}

type isRouting_Variant interface {
	isRouting_Variant()
}

type Routing_RouteRequest struct {
	// A route request going from the requester
	RouteRequest *RouteDiscovery `protobuf:"bytes,1,opt,name=route_request,json=routeRequest,proto3,oneof"`
}

type Routing_RouteReply struct {
	// A route reply
	RouteReply *RouteDiscovery `protobuf:"bytes,2,opt,name=route_reply,json=routeReply,proto3,oneof"`
}

type Routing_ErrorReason struct {
	// A failure in delivering a message (usually used for routing control messages, but might be provided
	// in addition to ack.fail_id to provide details on the type of failure).
	ErrorReason Routing_Error `protobuf:"varint,3,opt,name=error_reason,json=errorReason,proto3,enum=meshtastic.Routing_Error,oneof"`
}

func (*Routing_RouteRequest) isRouting_Variant() {}

func (*Routing_RouteReply) isRouting_Variant() {}

func (*Routing_ErrorReason) isRouting_Variant() {}

// (Formerly called SubPacket)
// The payload portion fo a packet, this is the actual bytes that are sent
// inside a radio packet (because from/to are broken out by the comms library)
type Data struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Formerly named typ and of type Type
	Portnum PortNum `protobuf:"varint,1,opt,name=portnum,proto3,enum=meshtastic.PortNum" json:"portnum,omitempty"`
	// TODO: REPLACE
	Payload []byte `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	// Not normally used, but for testing a sender can request that recipient
	// responds in kind (i.e. if it received a position, it should unicast back it's position).
	// Note: that if you set this on a broadcast you will receive many replies.
	WantResponse bool `protobuf:"varint,3,opt,name=want_response,json=wantResponse,proto3" json:"want_response,omitempty"`
	// The address of the destination node.
	// This field is is filled in by the mesh radio device software, application
	// layer software should never need it.
	// RouteDiscovery messages _must_ populate this.
	// Other message types might need to if they are doing multihop routing.
	Dest uint32 `protobuf:"fixed32,4,opt,name=dest,proto3" json:"dest,omitempty"`
	// The address of the original sender for this message.
	// This field should _only_ be populated for reliable multihop packets (to keep
	// packets small).
	Source uint32 `protobuf:"fixed32,5,opt,name=source,proto3" json:"source,omitempty"`
	// Only used in routing or response messages.
	// Indicates the original message ID that this message is reporting failure on. (formerly called original_id)
	RequestId uint32 `protobuf:"fixed32,6,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// If set, this message is intened to be a reply to a previously sent message with the defined id.
	ReplyId uint32 `protobuf:"fixed32,7,opt,name=reply_id,json=replyId,proto3" json:"reply_id,omitempty"`
	// Defaults to false. If true, then what is in the payload should be treated as an emoji like giving
	// a message a heart or poop emoji.
	Emoji uint32 `protobuf:"fixed32,8,opt,name=emoji,proto3" json:"emoji,omitempty"`
	// Bitfield for extra flags. First use is to indicate that user approves the packet being uploaded to MQTT.
	Bitfield      *uint32 `protobuf:"varint,9,opt,name=bitfield,proto3,oneof" json:"bitfield,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Data) Reset() {
	*x = Data{}
	mi := &file_meshtastic_mesh_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Data) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Data) ProtoMessage() {}

func (x *Data) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Data.ProtoReflect.Descriptor instead.
func (*Data) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{4}
}

func (x *Data) GetPortnum() PortNum {
	if x != nil {
		return x.Portnum
	}
	return PortNum_UNKNOWN_APP
}

func (x *Data) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *Data) GetWantResponse() bool {
	if x != nil {
		return x.WantResponse
	}
	return false
}

func (x *Data) GetDest() uint32 {
	if x != nil {
		return x.Dest
	}
	return 0
}

func (x *Data) GetSource() uint32 {
	if x != nil {
		return x.Source
	}
	return 0
}

func (x *Data) GetRequestId() uint32 {
	if x != nil {
		return x.RequestId
	}
	return 0
}

func (x *Data) GetReplyId() uint32 {
	if x != nil {
		return x.ReplyId
	}
	return 0
}

func (x *Data) GetEmoji() uint32 {
	if x != nil {
		return x.Emoji
	}
	return 0
}

func (x *Data) GetBitfield() uint32 {
	if x != nil && x.Bitfield != nil {
		return *x.Bitfield
	}
	return 0
}

// The actual over-the-mesh message doing KeyVerification
type KeyVerification struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// random value Selected by the requesting node
	Nonce uint64 `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// The final authoritative hash, only to be sent by NodeA at the end of the handshake
	Hash1 []byte `protobuf:"bytes,2,opt,name=hash1,proto3" json:"hash1,omitempty"`
	// The intermediary hash (actually derived from hash1),
	// sent from NodeB to NodeA in response to the initial message.
	Hash2         []byte `protobuf:"bytes,3,opt,name=hash2,proto3" json:"hash2,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KeyVerification) Reset() {
	*x = KeyVerification{}
	mi := &file_meshtastic_mesh_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KeyVerification) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeyVerification) ProtoMessage() {}

func (x *KeyVerification) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeyVerification.ProtoReflect.Descriptor instead.
func (*KeyVerification) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{5}
}

func (x *KeyVerification) GetNonce() uint64 {
	if x != nil {
		return x.Nonce
	}
	return 0
}

func (x *KeyVerification) GetHash1() []byte {
	if x != nil {
		return x.Hash1
	}
	return nil
}

func (x *KeyVerification) GetHash2() []byte {
	if x != nil {
		return x.Hash2
	}
	return nil
}

// Waypoint message, used to share arbitrary locations across the mesh
type Waypoint struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Id of the waypoint
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// latitude_i
	LatitudeI *int32 `protobuf:"fixed32,2,opt,name=latitude_i,json=latitudeI,proto3,oneof" json:"latitude_i,omitempty"`
	// longitude_i
	LongitudeI *int32 `protobuf:"fixed32,3,opt,name=longitude_i,json=longitudeI,proto3,oneof" json:"longitude_i,omitempty"`
	// Time the waypoint is to expire (epoch)
	Expire uint32 `protobuf:"varint,4,opt,name=expire,proto3" json:"expire,omitempty"`
	// If greater than zero, treat the value as a nodenum only allowing them to update the waypoint.
	// If zero, the waypoint is open to be edited by any member of the mesh.
	LockedTo uint32 `protobuf:"varint,5,opt,name=locked_to,json=lockedTo,proto3" json:"locked_to,omitempty"`
	// Name of the waypoint - max 30 chars
	Name string `protobuf:"bytes,6,opt,name=name,proto3" json:"name,omitempty"`
	// Description of the waypoint - max 100 chars
	Description string `protobuf:"bytes,7,opt,name=description,proto3" json:"description,omitempty"`
	// Designator icon for the waypoint in the form of a unicode emoji
	Icon          uint32 `protobuf:"fixed32,8,opt,name=icon,proto3" json:"icon,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Waypoint) Reset() {
	*x = Waypoint{}
	mi := &file_meshtastic_mesh_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Waypoint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Waypoint) ProtoMessage() {}

func (x *Waypoint) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Waypoint.ProtoReflect.Descriptor instead.
func (*Waypoint) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{6}
}

func (x *Waypoint) GetId() uint32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *Waypoint) GetLatitudeI() int32 {
	if x != nil && x.LatitudeI != nil {
		return *x.LatitudeI
	}
	return 0
}

func (x *Waypoint) GetLongitudeI() int32 {
	if x != nil && x.LongitudeI != nil {
		return *x.LongitudeI
	}
	return 0
}

func (x *Waypoint) GetExpire() uint32 {
	if x != nil {
		return x.Expire
	}
	return 0
}

func (x *Waypoint) GetLockedTo() uint32 {
	if x != nil {
		return x.LockedTo
	}
	return 0
}

func (x *Waypoint) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Waypoint) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *Waypoint) GetIcon() uint32 {
	if x != nil {
		return x.Icon
	}
	return 0
}

// This message will be proxied over the PhoneAPI for the client to deliver to the MQTT server
type MqttClientProxyMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The MQTT topic this message will be sent /received on
	Topic string `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	// The actual service envelope payload or text for mqtt pub / sub
	//
	// Types that are valid to be assigned to PayloadVariant:
	//
	//	*MqttClientProxyMessage_Data
	//	*MqttClientProxyMessage_Text
	PayloadVariant isMqttClientProxyMessage_PayloadVariant `protobuf_oneof:"payload_variant"`
	// Whether the message should be retained (or not)
	Retained      bool `protobuf:"varint,4,opt,name=retained,proto3" json:"retained,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MqttClientProxyMessage) Reset() {
	*x = MqttClientProxyMessage{}
	mi := &file_meshtastic_mesh_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MqttClientProxyMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MqttClientProxyMessage) ProtoMessage() {}

func (x *MqttClientProxyMessage) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MqttClientProxyMessage.ProtoReflect.Descriptor instead.
func (*MqttClientProxyMessage) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{7}
}

func (x *MqttClientProxyMessage) GetTopic() string {
	if x != nil {
		return x.Topic
	}
	return ""
}

func (x *MqttClientProxyMessage) GetPayloadVariant() isMqttClientProxyMessage_PayloadVariant {
	if x != nil {
		return x.PayloadVariant
	}
	return nil
}

func (x *MqttClientProxyMessage) GetData() []byte {
	if x != nil {
		if x, ok := x.PayloadVariant.(*MqttClientProxyMessage_Data); ok {
			return x.Data
		}
	}
	return nil
}

func (x *MqttClientProxyMessage) GetText() string {
	if x != nil {
		if x, ok := x.PayloadVariant.(*MqttClientProxyMessage_Text); ok {
			return x.Text
		}
	}
	return ""
}

func (x *MqttClientProxyMessage) GetRetained() bool {
	if x != nil {
		return x.Retained
	}
	return false
}

type isMqttClientProxyMessage_PayloadVariant interface {
	isMqttClientProxyMessage_PayloadVariant()
}

type MqttClientProxyMessage_Data struct {
	// Bytes
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3,oneof"`
}

type MqttClientProxyMessage_Text struct {
	// Text
	Text string `protobuf:"bytes,3,opt,name=text,proto3,oneof"`
}

func (*MqttClientProxyMessage_Data) isMqttClientProxyMessage_PayloadVariant() {}

func (*MqttClientProxyMessage_Text) isMqttClientProxyMessage_PayloadVariant() {}

// A packet envelope sent/received over the mesh
// only payload_variant is sent in the payload portion of the LORA packet.
// The other fields are either not sent at all, or sent in the special 16 byte LORA header.
type MeshPacket struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The sending node number.
	// Note: Our crypto implementation uses this field as well.
	// See [crypto](/docs/overview/encryption) for details.
	From uint32 `protobuf:"fixed32,1,opt,name=from,proto3" json:"from,omitempty"`
	// The (immediate) destination for this packet
	To uint32 `protobuf:"fixed32,2,opt,name=to,proto3" json:"to,omitempty"`
	// (Usually) If set, this indicates the index in the secondary_channels table that this packet was sent/received on.
	// If unset, packet was on the primary channel.
	// A particular node might know only a subset of channels in use on the mesh.
	// Therefore channel_index is inherently a local concept and meaningless to send between nodes.
	// Very briefly, while sending and receiving deep inside the device Router code, this field instead
	// contains the 'channel hash' instead of the index.
	// This 'trick' is only used while the payload_variant is an 'encrypted'.
	Channel uint32 `protobuf:"varint,3,opt,name=channel,proto3" json:"channel,omitempty"`
	// Types that are valid to be assigned to PayloadVariant:
	//
	//	*MeshPacket_Decoded
	//	*MeshPacket_Encrypted
	PayloadVariant isMeshPacket_PayloadVariant `protobuf_oneof:"payload_variant"`
	// A unique ID for this packet.
	// Always 0 for no-ack packets or non broadcast packets (and therefore take zero bytes of space).
	// Otherwise a unique ID for this packet, useful for flooding algorithms.
	// ID only needs to be unique on a _per sender_ basis, and it only
	// needs to be unique for a few minutes (long enough to last for the length of
	// any ACK or the completion of a mesh broadcast flood).
	// Note: Our crypto implementation uses this id as well.
	// See [crypto](/docs/overview/encryption) for details.
	Id uint32 `protobuf:"fixed32,6,opt,name=id,proto3" json:"id,omitempty"`
	// The time this message was received by the esp32 (secs since 1970).
	// Note: this field is _never_ sent on the radio link itself (to save space) Times
	// are typically not sent over the mesh, but they will be added to any Packet
	// (chain of SubPacket) sent to the phone (so the phone can know exact time of reception)
	RxTime uint32 `protobuf:"fixed32,7,opt,name=rx_time,json=rxTime,proto3" json:"rx_time,omitempty"`
	// *Never* sent over the radio links.
	// Set during reception to indicate the SNR of this packet.
	// Used to collect statistics on current link quality.
	RxSnr float32 `protobuf:"fixed32,8,opt,name=rx_snr,json=rxSnr,proto3" json:"rx_snr,omitempty"`
	// If unset treated as zero (no forwarding, send to direct neighbor nodes only)
	// if 1, allow hopping through one node, etc...
	// For our usecase real world topologies probably have a max of about 3.
	// This field is normally placed into a few of bits in the header.
	HopLimit uint32 `protobuf:"varint,9,opt,name=hop_limit,json=hopLimit,proto3" json:"hop_limit,omitempty"`
	// This packet is being sent as a reliable message, we would prefer it to arrive at the destination.
	// We would like to receive a ack packet in response.
	// Broadcasts messages treat this flag specially: Since acks for broadcasts would
	// rapidly flood the channel, the normal ack behavior is suppressed.
	// Instead, the original sender listens to see if at least one node is rebroadcasting this packet (because naive flooding algorithm).
	// If it hears that the odds (given typical LoRa topologies) the odds are very high that every node should eventually receive the message.
	// So FloodingRouter.cpp generates an implicit ack which is delivered to the original sender.
	// If after some time we don't hear anyone rebroadcast our packet, we will timeout and retransmit, using the regular resend logic.
	// Note: This flag is normally sent in a flag bit in the header when sent over the wire
	WantAck bool `protobuf:"varint,10,opt,name=want_ack,json=wantAck,proto3" json:"want_ack,omitempty"`
	// The priority of this message for sending.
	// See MeshPacket.Priority description for more details.
	Priority MeshPacket_Priority `protobuf:"varint,11,opt,name=priority,proto3,enum=meshtastic.MeshPacket_Priority" json:"priority,omitempty"`
	// rssi of received packet. Only sent to phone for dispay purposes.
	RxRssi int32 `protobuf:"varint,12,opt,name=rx_rssi,json=rxRssi,proto3" json:"rx_rssi,omitempty"`
	// Describe if this message is delayed
	//
	// Deprecated: Marked as deprecated in meshtastic/mesh.proto.
	Delayed MeshPacket_Delayed `protobuf:"varint,13,opt,name=delayed,proto3,enum=meshtastic.MeshPacket_Delayed" json:"delayed,omitempty"`
	// Describes whether this packet passed via MQTT somewhere along the path it currently took.
	ViaMqtt bool `protobuf:"varint,14,opt,name=via_mqtt,json=viaMqtt,proto3" json:"via_mqtt,omitempty"`
	// Hop limit with which the original packet started. Sent via LoRa using three bits in the unencrypted header.
	// When receiving a packet, the difference between hop_start and hop_limit gives how many hops it traveled.
	HopStart uint32 `protobuf:"varint,15,opt,name=hop_start,json=hopStart,proto3" json:"hop_start,omitempty"`
	// Records the public key the packet was encrypted with, if applicable.
	PublicKey []byte `protobuf:"bytes,16,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// Indicates whether the packet was en/decrypted using PKI
	PkiEncrypted bool `protobuf:"varint,17,opt,name=pki_encrypted,json=pkiEncrypted,proto3" json:"pki_encrypted,omitempty"`
	// Last byte of the node number of the node that should be used as the next hop in routing.
	// Set by the firmware internally, clients are not supposed to set this.
	NextHop uint32 `protobuf:"varint,18,opt,name=next_hop,json=nextHop,proto3" json:"next_hop,omitempty"`
	// Last byte of the node number of the node that will relay/relayed this packet.
	// Set by the firmware internally, clients are not supposed to set this.
	RelayNode uint32 `protobuf:"varint,19,opt,name=relay_node,json=relayNode,proto3" json:"relay_node,omitempty"`
	// *Never* sent over the radio links.
	// Timestamp after which this packet may be sent.
	// Set by the firmware internally, clients are not supposed to set this.
	TxAfter       uint32 `protobuf:"varint,20,opt,name=tx_after,json=txAfter,proto3" json:"tx_after,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MeshPacket) Reset() {
	*x = MeshPacket{}
	mi := &file_meshtastic_mesh_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MeshPacket) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MeshPacket) ProtoMessage() {}

func (x *MeshPacket) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MeshPacket.ProtoReflect.Descriptor instead.
func (*MeshPacket) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{8}
}

func (x *MeshPacket) GetFrom() uint32 {
	if x != nil {
		return x.From
	}
	return 0
}

func (x *MeshPacket) GetTo() uint32 {
	if x != nil {
		return x.To
	}
	return 0
}

func (x *MeshPacket) GetChannel() uint32 {
	if x != nil {
		return x.Channel
	}
	return 0
}

func (x *MeshPacket) GetPayloadVariant() isMeshPacket_PayloadVariant {
	if x != nil {
		return x.PayloadVariant
	}
	return nil
}

func (x *MeshPacket) GetDecoded() *Data {
	if x != nil {
		if x, ok := x.PayloadVariant.(*MeshPacket_Decoded); ok {
			return x.Decoded
		}
	}
	return nil
}

func (x *MeshPacket) GetEncrypted() []byte {
	if x != nil {
		if x, ok := x.PayloadVariant.(*MeshPacket_Encrypted); ok {
			return x.Encrypted
		}
	}
	return nil
}

func (x *MeshPacket) GetId() uint32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *MeshPacket) GetRxTime() uint32 {
	if x != nil {
		return x.RxTime
	}
	return 0
}

func (x *MeshPacket) GetRxSnr() float32 {
	if x != nil {
		return x.RxSnr
	}
	return 0
}

func (x *MeshPacket) GetHopLimit() uint32 {
	if x != nil {
		return x.HopLimit
	}
	return 0
}

func (x *MeshPacket) GetWantAck() bool {
	if x != nil {
		return x.WantAck
	}
	return false
}

func (x *MeshPacket) GetPriority() MeshPacket_Priority {
	if x != nil {
		return x.Priority
	}
	return MeshPacket_UNSET
}

func (x *MeshPacket) GetRxRssi() int32 {
	if x != nil {
		return x.RxRssi
	}
	return 0
}

// Deprecated: Marked as deprecated in meshtastic/mesh.proto.
func (x *MeshPacket) GetDelayed() MeshPacket_Delayed {
	if x != nil {
		return x.Delayed
	}
	return MeshPacket_NO_DELAY
}

func (x *MeshPacket) GetViaMqtt() bool {
	if x != nil {
		return x.ViaMqtt
	}
	return false
}

func (x *MeshPacket) GetHopStart() uint32 {
	if x != nil {
		return x.HopStart
	}
	return 0
}

func (x *MeshPacket) GetPublicKey() []byte {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

func (x *MeshPacket) GetPkiEncrypted() bool {
	if x != nil {
		return x.PkiEncrypted
	}
	return false
}

func (x *MeshPacket) GetNextHop() uint32 {
	if x != nil {
		return x.NextHop
	}
	return 0
}

func (x *MeshPacket) GetRelayNode() uint32 {
	if x != nil {
		return x.RelayNode
	}
	return 0
}

func (x *MeshPacket) GetTxAfter() uint32 {
	if x != nil {
		return x.TxAfter
	}
	return 0
}

type isMeshPacket_PayloadVariant interface {
	isMeshPacket_PayloadVariant()
}

type MeshPacket_Decoded struct {
	// TODO: REPLACE
	Decoded *Data `protobuf:"bytes,4,opt,name=decoded,proto3,oneof"`
}

type MeshPacket_Encrypted struct {
	// TODO: REPLACE
	Encrypted []byte `protobuf:"bytes,5,opt,name=encrypted,proto3,oneof"`
}

func (*MeshPacket_Decoded) isMeshPacket_PayloadVariant() {}

func (*MeshPacket_Encrypted) isMeshPacket_PayloadVariant() {}

// The bluetooth to device link:
// Old BTLE protocol docs from TODO, merge in above and make real docs...
// use protocol buffers, and NanoPB
// messages from device to phone:
// POSITION_UPDATE (..., time)
// TEXT_RECEIVED(from, text, time)
// OPAQUE_RECEIVED(from, payload, time) (for signal messages or other applications)
// messages from phone to device:
// SET_MYID(id, human readable long, human readable short) (send down the unique ID
// string used for this node, a human readable string shown for that id, and a very
// short human readable string suitable for oled screen) SEND_OPAQUE(dest, payload)
// (for signal messages or other applications) SEND_TEXT(dest, text) Get all
// nodes() (returns list of nodes, with full info, last time seen, loc, battery
// level etc) SET_CONFIG (switches device to a new set of radio params and
// preshared key, drops all existing nodes, force our node to rejoin this new group)
// Full information about a node on the mesh
type NodeInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The node number
	Num uint32 `protobuf:"varint,1,opt,name=num,proto3" json:"num,omitempty"`
	// The user info for this node
	User *User `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	// This position data. Note: before 1.2.14 we would also store the last time we've heard from this node in position.time, that is no longer true.
	// Position.time now indicates the last time we received a POSITION from that node.
	Position *Position `protobuf:"bytes,3,opt,name=position,proto3" json:"position,omitempty"`
	// Returns the Signal-to-noise ratio (SNR) of the last received message,
	// as measured by the receiver. Return SNR of the last received message in dB
	Snr float32 `protobuf:"fixed32,4,opt,name=snr,proto3" json:"snr,omitempty"`
	// Set to indicate the last time we received a packet from this node
	LastHeard uint32 `protobuf:"fixed32,5,opt,name=last_heard,json=lastHeard,proto3" json:"last_heard,omitempty"`
	// The latest device metrics for the node.
	DeviceMetrics *DeviceMetrics `protobuf:"bytes,6,opt,name=device_metrics,json=deviceMetrics,proto3" json:"device_metrics,omitempty"`
	// local channel index we heard that node on. Only populated if its not the default channel.
	Channel uint32 `protobuf:"varint,7,opt,name=channel,proto3" json:"channel,omitempty"`
	// True if we witnessed the node over MQTT instead of LoRA transport
	ViaMqtt bool `protobuf:"varint,8,opt,name=via_mqtt,json=viaMqtt,proto3" json:"via_mqtt,omitempty"`
	// Number of hops away from us this node is (0 if direct neighbor)
	HopsAway *uint32 `protobuf:"varint,9,opt,name=hops_away,json=hopsAway,proto3,oneof" json:"hops_away,omitempty"`
	// True if node is in our favorites list
	// Persists between NodeDB internal clean ups
	IsFavorite bool `protobuf:"varint,10,opt,name=is_favorite,json=isFavorite,proto3" json:"is_favorite,omitempty"`
	// True if node is in our ignored list
	// Persists between NodeDB internal clean ups
	IsIgnored bool `protobuf:"varint,11,opt,name=is_ignored,json=isIgnored,proto3" json:"is_ignored,omitempty"`
	// True if node public key has been verified.
	// Persists between NodeDB internal clean ups
	// LSB 0 of the bitfield
	IsKeyManuallyVerified bool `protobuf:"varint,12,opt,name=is_key_manually_verified,json=isKeyManuallyVerified,proto3" json:"is_key_manually_verified,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *NodeInfo) Reset() {
	*x = NodeInfo{}
	mi := &file_meshtastic_mesh_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeInfo) ProtoMessage() {}

func (x *NodeInfo) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeInfo.ProtoReflect.Descriptor instead.
func (*NodeInfo) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{9}
}

func (x *NodeInfo) GetNum() uint32 {
	if x != nil {
		return x.Num
	}
	return 0
}

func (x *NodeInfo) GetUser() *User {
	if x != nil {
		return x.User
	}
	return nil
}

func (x *NodeInfo) GetPosition() *Position {
	if x != nil {
		return x.Position
	}
	return nil
}

func (x *NodeInfo) GetSnr() float32 {
	if x != nil {
		return x.Snr
	}
	return 0
}

func (x *NodeInfo) GetLastHeard() uint32 {
	if x != nil {
		return x.LastHeard
	}
	return 0
}

func (x *NodeInfo) GetDeviceMetrics() *DeviceMetrics {
	if x != nil {
		return x.DeviceMetrics
	}
	return nil
}

func (x *NodeInfo) GetChannel() uint32 {
	if x != nil {
		return x.Channel
	}
	return 0
}

func (x *NodeInfo) GetViaMqtt() bool {
	if x != nil {
		return x.ViaMqtt
	}
	return false
}

func (x *NodeInfo) GetHopsAway() uint32 {
	if x != nil && x.HopsAway != nil {
		return *x.HopsAway
	}
	return 0
}

func (x *NodeInfo) GetIsFavorite() bool {
	if x != nil {
		return x.IsFavorite
	}
	return false
}

func (x *NodeInfo) GetIsIgnored() bool {
	if x != nil {
		return x.IsIgnored
	}
	return false
}

func (x *NodeInfo) GetIsKeyManuallyVerified() bool {
	if x != nil {
		return x.IsKeyManuallyVerified
	}
	return false
}

// Unique local debugging info for this node
// Note: we don't include position or the user info, because that will come in the
// Sent to the phone in response to WantNodes.
type MyNodeInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Tells the phone what our node number is, default starting value is
	// lowbyte of macaddr, but it will be fixed if that is already in use
	MyNodeNum uint32 `protobuf:"varint,1,opt,name=my_node_num,json=myNodeNum,proto3" json:"my_node_num,omitempty"`
	// The total number of reboots this node has ever encountered
	// (well - since the last time we discarded preferences)
	RebootCount uint32 `protobuf:"varint,8,opt,name=reboot_count,json=rebootCount,proto3" json:"reboot_count,omitempty"`
	// The minimum app version that can talk to this device.
	// Phone/PC apps should compare this to their build number and if too low tell the user they must update their app
	MinAppVersion uint32 `protobuf:"varint,11,opt,name=min_app_version,json=minAppVersion,proto3" json:"min_app_version,omitempty"`
	// Unique hardware identifier for this device
	DeviceId []byte `protobuf:"bytes,12,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
	// The PlatformIO environment used to build this firmware
	PioEnv        string `protobuf:"bytes,13,opt,name=pio_env,json=pioEnv,proto3" json:"pio_env,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MyNodeInfo) Reset() {
	*x = MyNodeInfo{}
	mi := &file_meshtastic_mesh_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MyNodeInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MyNodeInfo) ProtoMessage() {}

func (x *MyNodeInfo) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MyNodeInfo.ProtoReflect.Descriptor instead.
func (*MyNodeInfo) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{10}
}

func (x *MyNodeInfo) GetMyNodeNum() uint32 {
	if x != nil {
		return x.MyNodeNum
	}
	return 0
}

func (x *MyNodeInfo) GetRebootCount() uint32 {
	if x != nil {
		return x.RebootCount
	}
	return 0
}

func (x *MyNodeInfo) GetMinAppVersion() uint32 {
	if x != nil {
		return x.MinAppVersion
	}
	return 0
}

func (x *MyNodeInfo) GetDeviceId() []byte {
	if x != nil {
		return x.DeviceId
	}
	return nil
}

func (x *MyNodeInfo) GetPioEnv() string {
	if x != nil {
		return x.PioEnv
	}
	return ""
}

// Debug output from the device.
// To minimize the size of records inside the device code, if a time/source/level is not set
// on the message it is assumed to be a continuation of the previously sent message.
// This allows the device code to use fixed maxlen 64 byte strings for messages,
// and then extend as needed by emitting multiple records.
type LogRecord struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Log levels, chosen to match python logging conventions.
	Message string `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	// Seconds since 1970 - or 0 for unknown/unset
	Time uint32 `protobuf:"fixed32,2,opt,name=time,proto3" json:"time,omitempty"`
	// Usually based on thread name - if known
	Source string `protobuf:"bytes,3,opt,name=source,proto3" json:"source,omitempty"`
	// Not yet set
	Level         LogRecord_Level `protobuf:"varint,4,opt,name=level,proto3,enum=meshtastic.LogRecord_Level" json:"level,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LogRecord) Reset() {
	*x = LogRecord{}
	mi := &file_meshtastic_mesh_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogRecord) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogRecord) ProtoMessage() {}

func (x *LogRecord) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogRecord.ProtoReflect.Descriptor instead.
func (*LogRecord) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{11}
}

func (x *LogRecord) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *LogRecord) GetTime() uint32 {
	if x != nil {
		return x.Time
	}
	return 0
}

func (x *LogRecord) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *LogRecord) GetLevel() LogRecord_Level {
	if x != nil {
		return x.Level
	}
	return LogRecord_UNSET
}

type QueueStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Last attempt to queue status, ErrorCode
	Res int32 `protobuf:"varint,1,opt,name=res,proto3" json:"res,omitempty"`
	// Free entries in the outgoing queue
	Free uint32 `protobuf:"varint,2,opt,name=free,proto3" json:"free,omitempty"`
	// Maximum entries in the outgoing queue
	Maxlen uint32 `protobuf:"varint,3,opt,name=maxlen,proto3" json:"maxlen,omitempty"`
	// What was mesh packet id that generated this response?
	MeshPacketId  uint32 `protobuf:"varint,4,opt,name=mesh_packet_id,json=meshPacketId,proto3" json:"mesh_packet_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueueStatus) Reset() {
	*x = QueueStatus{}
	mi := &file_meshtastic_mesh_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueueStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueueStatus) ProtoMessage() {}

func (x *QueueStatus) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueueStatus.ProtoReflect.Descriptor instead.
func (*QueueStatus) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{12}
}

func (x *QueueStatus) GetRes() int32 {
	if x != nil {
		return x.Res
	}
	return 0
}

func (x *QueueStatus) GetFree() uint32 {
	if x != nil {
		return x.Free
	}
	return 0
}

func (x *QueueStatus) GetMaxlen() uint32 {
	if x != nil {
		return x.Maxlen
	}
	return 0
}

func (x *QueueStatus) GetMeshPacketId() uint32 {
	if x != nil {
		return x.MeshPacketId
	}
	return 0
}

// Packets from the radio to the phone will appear on the fromRadio characteristic.
// It will support READ and NOTIFY. When a new packet arrives the device will BLE notify?
// It will sit in that descriptor until consumed by the phone,
// at which point the next item in the FIFO will be populated.
type FromRadio struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The packet id, used to allow the phone to request missing read packets from the FIFO,
	// see our bluetooth docs
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Log levels, chosen to match python logging conventions.
	//
	// Types that are valid to be assigned to PayloadVariant:
	//
	//	*FromRadio_Packet
	//	*FromRadio_MyInfo
	//	*FromRadio_NodeInfo
	//	*FromRadio_Config
	//	*FromRadio_LogRecord
	//	*FromRadio_ConfigCompleteId
	//	*FromRadio_Rebooted
	//	*FromRadio_ModuleConfig
	//	*FromRadio_Channel
	//	*FromRadio_QueueStatus
	//	*FromRadio_XmodemPacket
	//	*FromRadio_Metadata
	//	*FromRadio_MqttClientProxyMessage
	//	*FromRadio_FileInfo
	//	*FromRadio_ClientNotification
	//	*FromRadio_DeviceuiConfig
	PayloadVariant isFromRadio_PayloadVariant `protobuf_oneof:"payload_variant"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *FromRadio) Reset() {
	*x = FromRadio{}
	mi := &file_meshtastic_mesh_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FromRadio) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FromRadio) ProtoMessage() {}

func (x *FromRadio) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FromRadio.ProtoReflect.Descriptor instead.
func (*FromRadio) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{13}
}

func (x *FromRadio) GetId() uint32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *FromRadio) GetPayloadVariant() isFromRadio_PayloadVariant {
	if x != nil {
		return x.PayloadVariant
	}
	return nil
}

func (x *FromRadio) GetPacket() *MeshPacket {
	if x != nil {
		if x, ok := x.PayloadVariant.(*FromRadio_Packet); ok {
			return x.Packet
		}
	}
	return nil
}

func (x *FromRadio) GetMyInfo() *MyNodeInfo {
	if x != nil {
		if x, ok := x.PayloadVariant.(*FromRadio_MyInfo); ok {
			return x.MyInfo
		}
	}
	return nil
}

func (x *FromRadio) GetNodeInfo() *NodeInfo {
	if x != nil {
		if x, ok := x.PayloadVariant.(*FromRadio_NodeInfo); ok {
			return x.NodeInfo
		}
	}
	return nil
}

func (x *FromRadio) GetConfig() *Config {
	if x != nil {
		if x, ok := x.PayloadVariant.(*FromRadio_Config); ok {
			return x.Config
		}
	}
	return nil
}

func (x *FromRadio) GetLogRecord() *LogRecord {
	if x != nil {
		if x, ok := x.PayloadVariant.(*FromRadio_LogRecord); ok {
			return x.LogRecord
		}
	}
	return nil
}

func (x *FromRadio) GetConfigCompleteId() uint32 {
	if x != nil {
		if x, ok := x.PayloadVariant.(*FromRadio_ConfigCompleteId); ok {
			return x.ConfigCompleteId
		}
	}
	return 0
}

func (x *FromRadio) GetRebooted() bool {
	if x != nil {
		if x, ok := x.PayloadVariant.(*FromRadio_Rebooted); ok {
			return x.Rebooted
		}
	}
	return false
}

func (x *FromRadio) GetModuleConfig() *ModuleConfig {
	if x != nil {
		if x, ok := x.PayloadVariant.(*FromRadio_ModuleConfig); ok {
			return x.ModuleConfig
		}
	}
	return nil
}

func (x *FromRadio) GetChannel() *Channel {
	if x != nil {
		if x, ok := x.PayloadVariant.(*FromRadio_Channel); ok {
			return x.Channel
		}
	}
	return nil
}

func (x *FromRadio) GetQueueStatus() *QueueStatus {
	if x != nil {
		if x, ok := x.PayloadVariant.(*FromRadio_QueueStatus); ok {
			return x.QueueStatus
		}
	}
	return nil
}

func (x *FromRadio) GetXmodemPacket() *XModem {
	if x != nil {
		if x, ok := x.PayloadVariant.(*FromRadio_XmodemPacket); ok {
			return x.XmodemPacket
		}
	}
	return nil
}

func (x *FromRadio) GetMetadata() *DeviceMetadata {
	if x != nil {
		if x, ok := x.PayloadVariant.(*FromRadio_Metadata); ok {
			return x.Metadata
		}
	}
	return nil
}

func (x *FromRadio) GetMqttClientProxyMessage() *MqttClientProxyMessage {
	if x != nil {
		if x, ok := x.PayloadVariant.(*FromRadio_MqttClientProxyMessage); ok {
			return x.MqttClientProxyMessage
		}
	}
	return nil
}

func (x *FromRadio) GetFileInfo() *FileInfo {
	if x != nil {
		if x, ok := x.PayloadVariant.(*FromRadio_FileInfo); ok {
			return x.FileInfo
		}
	}
	return nil
}

func (x *FromRadio) GetClientNotification() *ClientNotification {
	if x != nil {
		if x, ok := x.PayloadVariant.(*FromRadio_ClientNotification); ok {
			return x.ClientNotification
		}
	}
	return nil
}

func (x *FromRadio) GetDeviceuiConfig() *DeviceUIConfig {
	if x != nil {
		if x, ok := x.PayloadVariant.(*FromRadio_DeviceuiConfig); ok {
			return x.DeviceuiConfig
		}
	}
	return nil
}

type isFromRadio_PayloadVariant interface {
	isFromRadio_PayloadVariant()
}

type FromRadio_Packet struct {
	// Log levels, chosen to match python logging conventions.
	Packet *MeshPacket `protobuf:"bytes,2,opt,name=packet,proto3,oneof"`
}

type FromRadio_MyInfo struct {
	// Tells the phone what our node number is, can be -1 if we've not yet joined a mesh.
	// NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
	MyInfo *MyNodeInfo `protobuf:"bytes,3,opt,name=my_info,json=myInfo,proto3,oneof"`
}

type FromRadio_NodeInfo struct {
	// One packet is sent for each node in the on radio DB
	// starts over with the first node in our DB
	NodeInfo *NodeInfo `protobuf:"bytes,4,opt,name=node_info,json=nodeInfo,proto3,oneof"`
}

type FromRadio_Config struct {
	// Include a part of the config (was: RadioConfig radio)
	Config *Config `protobuf:"bytes,5,opt,name=config,proto3,oneof"`
}

type FromRadio_LogRecord struct {
	// Set to send debug console output over our protobuf stream
	LogRecord *LogRecord `protobuf:"bytes,6,opt,name=log_record,json=logRecord,proto3,oneof"`
}

type FromRadio_ConfigCompleteId struct {
	// Sent as true once the device has finished sending all of the responses to want_config
	// recipient should check if this ID matches our original request nonce, if
	// not, it means your config responses haven't started yet.
	// NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
	ConfigCompleteId uint32 `protobuf:"varint,7,opt,name=config_complete_id,json=configCompleteId,proto3,oneof"`
}

type FromRadio_Rebooted struct {
	// Sent to tell clients the radio has just rebooted.
	// Set to true if present.
	// Not used on all transports, currently just used for the serial console.
	// NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
	Rebooted bool `protobuf:"varint,8,opt,name=rebooted,proto3,oneof"`
}

type FromRadio_ModuleConfig struct {
	// Include module config
	ModuleConfig *ModuleConfig `protobuf:"bytes,9,opt,name=moduleConfig,proto3,oneof"`
}

type FromRadio_Channel struct {
	// One packet is sent for each channel
	Channel *Channel `protobuf:"bytes,10,opt,name=channel,proto3,oneof"`
}

type FromRadio_QueueStatus struct {
	// Queue status info
	QueueStatus *QueueStatus `protobuf:"bytes,11,opt,name=queueStatus,proto3,oneof"`
}

type FromRadio_XmodemPacket struct {
	// File Transfer Chunk
	XmodemPacket *XModem `protobuf:"bytes,12,opt,name=xmodemPacket,proto3,oneof"`
}

type FromRadio_Metadata struct {
	// Device metadata message
	Metadata *DeviceMetadata `protobuf:"bytes,13,opt,name=metadata,proto3,oneof"`
}

type FromRadio_MqttClientProxyMessage struct {
	// MQTT Client Proxy Message (device sending to client / phone for publishing to MQTT)
	MqttClientProxyMessage *MqttClientProxyMessage `protobuf:"bytes,14,opt,name=mqttClientProxyMessage,proto3,oneof"`
}

type FromRadio_FileInfo struct {
	// File system manifest messages
	FileInfo *FileInfo `protobuf:"bytes,15,opt,name=fileInfo,proto3,oneof"`
}

type FromRadio_ClientNotification struct {
	// Notification message to the client
	ClientNotification *ClientNotification `protobuf:"bytes,16,opt,name=clientNotification,proto3,oneof"`
}

type FromRadio_DeviceuiConfig struct {
	// Persistent data for device-ui
	DeviceuiConfig *DeviceUIConfig `protobuf:"bytes,17,opt,name=deviceuiConfig,proto3,oneof"`
}

func (*FromRadio_Packet) isFromRadio_PayloadVariant() {}

func (*FromRadio_MyInfo) isFromRadio_PayloadVariant() {}

func (*FromRadio_NodeInfo) isFromRadio_PayloadVariant() {}

func (*FromRadio_Config) isFromRadio_PayloadVariant() {}

func (*FromRadio_LogRecord) isFromRadio_PayloadVariant() {}

func (*FromRadio_ConfigCompleteId) isFromRadio_PayloadVariant() {}

func (*FromRadio_Rebooted) isFromRadio_PayloadVariant() {}

func (*FromRadio_ModuleConfig) isFromRadio_PayloadVariant() {}

func (*FromRadio_Channel) isFromRadio_PayloadVariant() {}

func (*FromRadio_QueueStatus) isFromRadio_PayloadVariant() {}

func (*FromRadio_XmodemPacket) isFromRadio_PayloadVariant() {}

func (*FromRadio_Metadata) isFromRadio_PayloadVariant() {}

func (*FromRadio_MqttClientProxyMessage) isFromRadio_PayloadVariant() {}

func (*FromRadio_FileInfo) isFromRadio_PayloadVariant() {}

func (*FromRadio_ClientNotification) isFromRadio_PayloadVariant() {}

func (*FromRadio_DeviceuiConfig) isFromRadio_PayloadVariant() {}

// A notification message from the device to the client
// To be used for important messages that should to be displayed to the user
// in the form of push notifications or validation messages when saving
// invalid configuration.
type ClientNotification struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The id of the packet we're notifying in response to
	ReplyId *uint32 `protobuf:"varint,1,opt,name=reply_id,json=replyId,proto3,oneof" json:"reply_id,omitempty"`
	// Seconds since 1970 - or 0 for unknown/unset
	Time uint32 `protobuf:"fixed32,2,opt,name=time,proto3" json:"time,omitempty"`
	// The level type of notification
	Level LogRecord_Level `protobuf:"varint,3,opt,name=level,proto3,enum=meshtastic.LogRecord_Level" json:"level,omitempty"`
	// The message body of the notification
	Message string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
	// Types that are valid to be assigned to PayloadVariant:
	//
	//	*ClientNotification_KeyVerificationNumberInform
	//	*ClientNotification_KeyVerificationNumberRequest
	//	*ClientNotification_KeyVerificationFinal
	//	*ClientNotification_DuplicatedPublicKey
	//	*ClientNotification_LowEntropyKey
	PayloadVariant isClientNotification_PayloadVariant `protobuf_oneof:"payload_variant"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ClientNotification) Reset() {
	*x = ClientNotification{}
	mi := &file_meshtastic_mesh_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClientNotification) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClientNotification) ProtoMessage() {}

func (x *ClientNotification) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClientNotification.ProtoReflect.Descriptor instead.
func (*ClientNotification) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{14}
}

func (x *ClientNotification) GetReplyId() uint32 {
	if x != nil && x.ReplyId != nil {
		return *x.ReplyId
	}
	return 0
}

func (x *ClientNotification) GetTime() uint32 {
	if x != nil {
		return x.Time
	}
	return 0
}

func (x *ClientNotification) GetLevel() LogRecord_Level {
	if x != nil {
		return x.Level
	}
	return LogRecord_UNSET
}

func (x *ClientNotification) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *ClientNotification) GetPayloadVariant() isClientNotification_PayloadVariant {
	if x != nil {
		return x.PayloadVariant
	}
	return nil
}

func (x *ClientNotification) GetKeyVerificationNumberInform() *KeyVerificationNumberInform {
	if x != nil {
		if x, ok := x.PayloadVariant.(*ClientNotification_KeyVerificationNumberInform); ok {
			return x.KeyVerificationNumberInform
		}
	}
	return nil
}

func (x *ClientNotification) GetKeyVerificationNumberRequest() *KeyVerificationNumberRequest {
	if x != nil {
		if x, ok := x.PayloadVariant.(*ClientNotification_KeyVerificationNumberRequest); ok {
			return x.KeyVerificationNumberRequest
		}
	}
	return nil
}

func (x *ClientNotification) GetKeyVerificationFinal() *KeyVerificationFinal {
	if x != nil {
		if x, ok := x.PayloadVariant.(*ClientNotification_KeyVerificationFinal); ok {
			return x.KeyVerificationFinal
		}
	}
	return nil
}

func (x *ClientNotification) GetDuplicatedPublicKey() *DuplicatedPublicKey {
	if x != nil {
		if x, ok := x.PayloadVariant.(*ClientNotification_DuplicatedPublicKey); ok {
			return x.DuplicatedPublicKey
		}
	}
	return nil
}

func (x *ClientNotification) GetLowEntropyKey() *LowEntropyKey {
	if x != nil {
		if x, ok := x.PayloadVariant.(*ClientNotification_LowEntropyKey); ok {
			return x.LowEntropyKey
		}
	}
	return nil
}

type isClientNotification_PayloadVariant interface {
	isClientNotification_PayloadVariant()
}

type ClientNotification_KeyVerificationNumberInform struct {
	KeyVerificationNumberInform *KeyVerificationNumberInform `protobuf:"bytes,11,opt,name=key_verification_number_inform,json=keyVerificationNumberInform,proto3,oneof"`
}

type ClientNotification_KeyVerificationNumberRequest struct {
	KeyVerificationNumberRequest *KeyVerificationNumberRequest `protobuf:"bytes,12,opt,name=key_verification_number_request,json=keyVerificationNumberRequest,proto3,oneof"`
}

type ClientNotification_KeyVerificationFinal struct {
	KeyVerificationFinal *KeyVerificationFinal `protobuf:"bytes,13,opt,name=key_verification_final,json=keyVerificationFinal,proto3,oneof"`
}

type ClientNotification_DuplicatedPublicKey struct {
	DuplicatedPublicKey *DuplicatedPublicKey `protobuf:"bytes,14,opt,name=duplicated_public_key,json=duplicatedPublicKey,proto3,oneof"`
}

type ClientNotification_LowEntropyKey struct {
	LowEntropyKey *LowEntropyKey `protobuf:"bytes,15,opt,name=low_entropy_key,json=lowEntropyKey,proto3,oneof"`
}

func (*ClientNotification_KeyVerificationNumberInform) isClientNotification_PayloadVariant() {}

func (*ClientNotification_KeyVerificationNumberRequest) isClientNotification_PayloadVariant() {}

func (*ClientNotification_KeyVerificationFinal) isClientNotification_PayloadVariant() {}

func (*ClientNotification_DuplicatedPublicKey) isClientNotification_PayloadVariant() {}

func (*ClientNotification_LowEntropyKey) isClientNotification_PayloadVariant() {}

type KeyVerificationNumberInform struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	Nonce          uint64                 `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	RemoteLongname string                 `protobuf:"bytes,2,opt,name=remote_longname,json=remoteLongname,proto3" json:"remote_longname,omitempty"`
	SecurityNumber uint32                 `protobuf:"varint,3,opt,name=security_number,json=securityNumber,proto3" json:"security_number,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *KeyVerificationNumberInform) Reset() {
	*x = KeyVerificationNumberInform{}
	mi := &file_meshtastic_mesh_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KeyVerificationNumberInform) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeyVerificationNumberInform) ProtoMessage() {}

func (x *KeyVerificationNumberInform) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeyVerificationNumberInform.ProtoReflect.Descriptor instead.
func (*KeyVerificationNumberInform) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{15}
}

func (x *KeyVerificationNumberInform) GetNonce() uint64 {
	if x != nil {
		return x.Nonce
	}
	return 0
}

func (x *KeyVerificationNumberInform) GetRemoteLongname() string {
	if x != nil {
		return x.RemoteLongname
	}
	return ""
}

func (x *KeyVerificationNumberInform) GetSecurityNumber() uint32 {
	if x != nil {
		return x.SecurityNumber
	}
	return 0
}

type KeyVerificationNumberRequest struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	Nonce          uint64                 `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	RemoteLongname string                 `protobuf:"bytes,2,opt,name=remote_longname,json=remoteLongname,proto3" json:"remote_longname,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *KeyVerificationNumberRequest) Reset() {
	*x = KeyVerificationNumberRequest{}
	mi := &file_meshtastic_mesh_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KeyVerificationNumberRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeyVerificationNumberRequest) ProtoMessage() {}

func (x *KeyVerificationNumberRequest) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeyVerificationNumberRequest.ProtoReflect.Descriptor instead.
func (*KeyVerificationNumberRequest) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{16}
}

func (x *KeyVerificationNumberRequest) GetNonce() uint64 {
	if x != nil {
		return x.Nonce
	}
	return 0
}

func (x *KeyVerificationNumberRequest) GetRemoteLongname() string {
	if x != nil {
		return x.RemoteLongname
	}
	return ""
}

type KeyVerificationFinal struct {
	state                  protoimpl.MessageState `protogen:"open.v1"`
	Nonce                  uint64                 `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	RemoteLongname         string                 `protobuf:"bytes,2,opt,name=remote_longname,json=remoteLongname,proto3" json:"remote_longname,omitempty"`
	IsSender               bool                   `protobuf:"varint,3,opt,name=isSender,proto3" json:"isSender,omitempty"`
	VerificationCharacters string                 `protobuf:"bytes,4,opt,name=verification_characters,json=verificationCharacters,proto3" json:"verification_characters,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *KeyVerificationFinal) Reset() {
	*x = KeyVerificationFinal{}
	mi := &file_meshtastic_mesh_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KeyVerificationFinal) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeyVerificationFinal) ProtoMessage() {}

func (x *KeyVerificationFinal) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeyVerificationFinal.ProtoReflect.Descriptor instead.
func (*KeyVerificationFinal) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{17}
}

func (x *KeyVerificationFinal) GetNonce() uint64 {
	if x != nil {
		return x.Nonce
	}
	return 0
}

func (x *KeyVerificationFinal) GetRemoteLongname() string {
	if x != nil {
		return x.RemoteLongname
	}
	return ""
}

func (x *KeyVerificationFinal) GetIsSender() bool {
	if x != nil {
		return x.IsSender
	}
	return false
}

func (x *KeyVerificationFinal) GetVerificationCharacters() string {
	if x != nil {
		return x.VerificationCharacters
	}
	return ""
}

type DuplicatedPublicKey struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DuplicatedPublicKey) Reset() {
	*x = DuplicatedPublicKey{}
	mi := &file_meshtastic_mesh_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DuplicatedPublicKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DuplicatedPublicKey) ProtoMessage() {}

func (x *DuplicatedPublicKey) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DuplicatedPublicKey.ProtoReflect.Descriptor instead.
func (*DuplicatedPublicKey) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{18}
}

type LowEntropyKey struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LowEntropyKey) Reset() {
	*x = LowEntropyKey{}
	mi := &file_meshtastic_mesh_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LowEntropyKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LowEntropyKey) ProtoMessage() {}

func (x *LowEntropyKey) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LowEntropyKey.ProtoReflect.Descriptor instead.
func (*LowEntropyKey) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{19}
}

// Individual File info for the device
type FileInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The fully qualified path of the file
	FileName string `protobuf:"bytes,1,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
	// The size of the file in bytes
	SizeBytes     uint32 `protobuf:"varint,2,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FileInfo) Reset() {
	*x = FileInfo{}
	mi := &file_meshtastic_mesh_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileInfo) ProtoMessage() {}

func (x *FileInfo) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileInfo.ProtoReflect.Descriptor instead.
func (*FileInfo) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{20}
}

func (x *FileInfo) GetFileName() string {
	if x != nil {
		return x.FileName
	}
	return ""
}

func (x *FileInfo) GetSizeBytes() uint32 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

// Packets/commands to the radio will be written (reliably) to the toRadio characteristic.
// Once the write completes the phone can assume it is handled.
type ToRadio struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Log levels, chosen to match python logging conventions.
	//
	// Types that are valid to be assigned to PayloadVariant:
	//
	//	*ToRadio_Packet
	//	*ToRadio_WantConfigId
	//	*ToRadio_Disconnect
	//	*ToRadio_XmodemPacket
	//	*ToRadio_MqttClientProxyMessage
	//	*ToRadio_Heartbeat
	PayloadVariant isToRadio_PayloadVariant `protobuf_oneof:"payload_variant"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ToRadio) Reset() {
	*x = ToRadio{}
	mi := &file_meshtastic_mesh_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ToRadio) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ToRadio) ProtoMessage() {}

func (x *ToRadio) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ToRadio.ProtoReflect.Descriptor instead.
func (*ToRadio) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{21}
}

func (x *ToRadio) GetPayloadVariant() isToRadio_PayloadVariant {
	if x != nil {
		return x.PayloadVariant
	}
	return nil
}

func (x *ToRadio) GetPacket() *MeshPacket {
	if x != nil {
		if x, ok := x.PayloadVariant.(*ToRadio_Packet); ok {
			return x.Packet
		}
	}
	return nil
}

func (x *ToRadio) GetWantConfigId() uint32 {
	if x != nil {
		if x, ok := x.PayloadVariant.(*ToRadio_WantConfigId); ok {
			return x.WantConfigId
		}
	}
	return 0
}

func (x *ToRadio) GetDisconnect() bool {
	if x != nil {
		if x, ok := x.PayloadVariant.(*ToRadio_Disconnect); ok {
			return x.Disconnect
		}
	}
	return false
}

func (x *ToRadio) GetXmodemPacket() *XModem {
	if x != nil {
		if x, ok := x.PayloadVariant.(*ToRadio_XmodemPacket); ok {
			return x.XmodemPacket
		}
	}
	return nil
}

func (x *ToRadio) GetMqttClientProxyMessage() *MqttClientProxyMessage {
	if x != nil {
		if x, ok := x.PayloadVariant.(*ToRadio_MqttClientProxyMessage); ok {
			return x.MqttClientProxyMessage
		}
	}
	return nil
}

func (x *ToRadio) GetHeartbeat() *Heartbeat {
	if x != nil {
		if x, ok := x.PayloadVariant.(*ToRadio_Heartbeat); ok {
			return x.Heartbeat
		}
	}
	return nil
}

type isToRadio_PayloadVariant interface {
	isToRadio_PayloadVariant()
}

type ToRadio_Packet struct {
	// Send this packet on the mesh
	Packet *MeshPacket `protobuf:"bytes,1,opt,name=packet,proto3,oneof"`
}

type ToRadio_WantConfigId struct {
	// Phone wants radio to send full node db to the phone, This is
	// typically the first packet sent to the radio when the phone gets a
	// bluetooth connection. The radio will respond by sending back a
	// MyNodeInfo, a owner, a radio config and a series of
	// FromRadio.node_infos, and config_complete
	// the integer you write into this field will be reported back in the
	// config_complete_id response this allows clients to never be confused by
	// a stale old partially sent config.
	WantConfigId uint32 `protobuf:"varint,3,opt,name=want_config_id,json=wantConfigId,proto3,oneof"`
}

type ToRadio_Disconnect struct {
	// Tell API server we are disconnecting now.
	// This is useful for serial links where there is no hardware/protocol based notification that the client has dropped the link.
	// (Sending this message is optional for clients)
	Disconnect bool `protobuf:"varint,4,opt,name=disconnect,proto3,oneof"`
}

type ToRadio_XmodemPacket struct {
	XmodemPacket *XModem `protobuf:"bytes,5,opt,name=xmodemPacket,proto3,oneof"`
}

type ToRadio_MqttClientProxyMessage struct {
	// MQTT Client Proxy Message (for client / phone subscribed to MQTT sending to device)
	MqttClientProxyMessage *MqttClientProxyMessage `protobuf:"bytes,6,opt,name=mqttClientProxyMessage,proto3,oneof"`
}

type ToRadio_Heartbeat struct {
	// Heartbeat message (used to keep the device connection awake on serial)
	Heartbeat *Heartbeat `protobuf:"bytes,7,opt,name=heartbeat,proto3,oneof"`
}

func (*ToRadio_Packet) isToRadio_PayloadVariant() {}

func (*ToRadio_WantConfigId) isToRadio_PayloadVariant() {}

func (*ToRadio_Disconnect) isToRadio_PayloadVariant() {}

func (*ToRadio_XmodemPacket) isToRadio_PayloadVariant() {}

func (*ToRadio_MqttClientProxyMessage) isToRadio_PayloadVariant() {}

func (*ToRadio_Heartbeat) isToRadio_PayloadVariant() {}

// Compressed message payload
type Compressed struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// PortNum to determine the how to handle the compressed payload.
	Portnum PortNum `protobuf:"varint,1,opt,name=portnum,proto3,enum=meshtastic.PortNum" json:"portnum,omitempty"`
	// Compressed data.
	Data          []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Compressed) Reset() {
	*x = Compressed{}
	mi := &file_meshtastic_mesh_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Compressed) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Compressed) ProtoMessage() {}

func (x *Compressed) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Compressed.ProtoReflect.Descriptor instead.
func (*Compressed) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{22}
}

func (x *Compressed) GetPortnum() PortNum {
	if x != nil {
		return x.Portnum
	}
	return PortNum_UNKNOWN_APP
}

func (x *Compressed) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

// Full info on edges for a single node
type NeighborInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The node ID of the node sending info on its neighbors
	NodeId uint32 `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// Field to pass neighbor info for the next sending cycle
	LastSentById uint32 `protobuf:"varint,2,opt,name=last_sent_by_id,json=lastSentById,proto3" json:"last_sent_by_id,omitempty"`
	// Broadcast interval of the represented node (in seconds)
	NodeBroadcastIntervalSecs uint32 `protobuf:"varint,3,opt,name=node_broadcast_interval_secs,json=nodeBroadcastIntervalSecs,proto3" json:"node_broadcast_interval_secs,omitempty"`
	// The list of out edges from this node
	Neighbors     []*Neighbor `protobuf:"bytes,4,rep,name=neighbors,proto3" json:"neighbors,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NeighborInfo) Reset() {
	*x = NeighborInfo{}
	mi := &file_meshtastic_mesh_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NeighborInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NeighborInfo) ProtoMessage() {}

func (x *NeighborInfo) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NeighborInfo.ProtoReflect.Descriptor instead.
func (*NeighborInfo) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{23}
}

func (x *NeighborInfo) GetNodeId() uint32 {
	if x != nil {
		return x.NodeId
	}
	return 0
}

func (x *NeighborInfo) GetLastSentById() uint32 {
	if x != nil {
		return x.LastSentById
	}
	return 0
}

func (x *NeighborInfo) GetNodeBroadcastIntervalSecs() uint32 {
	if x != nil {
		return x.NodeBroadcastIntervalSecs
	}
	return 0
}

func (x *NeighborInfo) GetNeighbors() []*Neighbor {
	if x != nil {
		return x.Neighbors
	}
	return nil
}

// A single edge in the mesh
type Neighbor struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Node ID of neighbor
	NodeId uint32 `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// SNR of last heard message
	Snr float32 `protobuf:"fixed32,2,opt,name=snr,proto3" json:"snr,omitempty"`
	// Reception time (in secs since 1970) of last message that was last sent by this ID.
	// Note: this is for local storage only and will not be sent out over the mesh.
	LastRxTime uint32 `protobuf:"fixed32,3,opt,name=last_rx_time,json=lastRxTime,proto3" json:"last_rx_time,omitempty"`
	// Broadcast interval of this neighbor (in seconds).
	// Note: this is for local storage only and will not be sent out over the mesh.
	NodeBroadcastIntervalSecs uint32 `protobuf:"varint,4,opt,name=node_broadcast_interval_secs,json=nodeBroadcastIntervalSecs,proto3" json:"node_broadcast_interval_secs,omitempty"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *Neighbor) Reset() {
	*x = Neighbor{}
	mi := &file_meshtastic_mesh_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Neighbor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Neighbor) ProtoMessage() {}

func (x *Neighbor) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Neighbor.ProtoReflect.Descriptor instead.
func (*Neighbor) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{24}
}

func (x *Neighbor) GetNodeId() uint32 {
	if x != nil {
		return x.NodeId
	}
	return 0
}

func (x *Neighbor) GetSnr() float32 {
	if x != nil {
		return x.Snr
	}
	return 0
}

func (x *Neighbor) GetLastRxTime() uint32 {
	if x != nil {
		return x.LastRxTime
	}
	return 0
}

func (x *Neighbor) GetNodeBroadcastIntervalSecs() uint32 {
	if x != nil {
		return x.NodeBroadcastIntervalSecs
	}
	return 0
}

// Device metadata response
type DeviceMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Device firmware version string
	FirmwareVersion string `protobuf:"bytes,1,opt,name=firmware_version,json=firmwareVersion,proto3" json:"firmware_version,omitempty"`
	// Device state version
	DeviceStateVersion uint32 `protobuf:"varint,2,opt,name=device_state_version,json=deviceStateVersion,proto3" json:"device_state_version,omitempty"`
	// Indicates whether the device can shutdown CPU natively or via power management chip
	CanShutdown bool `protobuf:"varint,3,opt,name=canShutdown,proto3" json:"canShutdown,omitempty"`
	// Indicates that the device has native wifi capability
	HasWifi bool `protobuf:"varint,4,opt,name=hasWifi,proto3" json:"hasWifi,omitempty"`
	// Indicates that the device has native bluetooth capability
	HasBluetooth bool `protobuf:"varint,5,opt,name=hasBluetooth,proto3" json:"hasBluetooth,omitempty"`
	// Indicates that the device has an ethernet peripheral
	HasEthernet bool `protobuf:"varint,6,opt,name=hasEthernet,proto3" json:"hasEthernet,omitempty"`
	// Indicates that the device's role in the mesh
	Role Config_DeviceConfig_Role `protobuf:"varint,7,opt,name=role,proto3,enum=meshtastic.Config_DeviceConfig_Role" json:"role,omitempty"`
	// Indicates the device's current enabled position flags
	PositionFlags uint32 `protobuf:"varint,8,opt,name=position_flags,json=positionFlags,proto3" json:"position_flags,omitempty"`
	// Device hardware model
	HwModel HardwareModel `protobuf:"varint,9,opt,name=hw_model,json=hwModel,proto3,enum=meshtastic.HardwareModel" json:"hw_model,omitempty"`
	// Has Remote Hardware enabled
	HasRemoteHardware bool `protobuf:"varint,10,opt,name=hasRemoteHardware,proto3" json:"hasRemoteHardware,omitempty"`
	// Has PKC capabilities
	HasPKC bool `protobuf:"varint,11,opt,name=hasPKC,proto3" json:"hasPKC,omitempty"`
	// Bit field of boolean for excluded modules
	// (bitwise OR of ExcludedModules)
	ExcludedModules uint32 `protobuf:"varint,12,opt,name=excluded_modules,json=excludedModules,proto3" json:"excluded_modules,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *DeviceMetadata) Reset() {
	*x = DeviceMetadata{}
	mi := &file_meshtastic_mesh_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeviceMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeviceMetadata) ProtoMessage() {}

func (x *DeviceMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeviceMetadata.ProtoReflect.Descriptor instead.
func (*DeviceMetadata) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{25}
}

func (x *DeviceMetadata) GetFirmwareVersion() string {
	if x != nil {
		return x.FirmwareVersion
	}
	return ""
}

func (x *DeviceMetadata) GetDeviceStateVersion() uint32 {
	if x != nil {
		return x.DeviceStateVersion
	}
	return 0
}

func (x *DeviceMetadata) GetCanShutdown() bool {
	if x != nil {
		return x.CanShutdown
	}
	return false
}

func (x *DeviceMetadata) GetHasWifi() bool {
	if x != nil {
		return x.HasWifi
	}
	return false
}

func (x *DeviceMetadata) GetHasBluetooth() bool {
	if x != nil {
		return x.HasBluetooth
	}
	return false
}

func (x *DeviceMetadata) GetHasEthernet() bool {
	if x != nil {
		return x.HasEthernet
	}
	return false
}

func (x *DeviceMetadata) GetRole() Config_DeviceConfig_Role {
	if x != nil {
		return x.Role
	}
	return Config_DeviceConfig_CLIENT
}

func (x *DeviceMetadata) GetPositionFlags() uint32 {
	if x != nil {
		return x.PositionFlags
	}
	return 0
}

func (x *DeviceMetadata) GetHwModel() HardwareModel {
	if x != nil {
		return x.HwModel
	}
	return HardwareModel_UNSET
}

func (x *DeviceMetadata) GetHasRemoteHardware() bool {
	if x != nil {
		return x.HasRemoteHardware
	}
	return false
}

func (x *DeviceMetadata) GetHasPKC() bool {
	if x != nil {
		return x.HasPKC
	}
	return false
}

func (x *DeviceMetadata) GetExcludedModules() uint32 {
	if x != nil {
		return x.ExcludedModules
	}
	return 0
}

// A heartbeat message is sent to the node from the client to keep the connection alive.
// This is currently only needed to keep serial connections alive, but can be used by any PhoneAPI.
type Heartbeat struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Heartbeat) Reset() {
	*x = Heartbeat{}
	mi := &file_meshtastic_mesh_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Heartbeat) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Heartbeat) ProtoMessage() {}

func (x *Heartbeat) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Heartbeat.ProtoReflect.Descriptor instead.
func (*Heartbeat) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{26}
}

// RemoteHardwarePins associated with a node
type NodeRemoteHardwarePin struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The node_num exposing the available gpio pin
	NodeNum uint32 `protobuf:"varint,1,opt,name=node_num,json=nodeNum,proto3" json:"node_num,omitempty"`
	// The the available gpio pin for usage with RemoteHardware module
	Pin           *RemoteHardwarePin `protobuf:"bytes,2,opt,name=pin,proto3" json:"pin,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeRemoteHardwarePin) Reset() {
	*x = NodeRemoteHardwarePin{}
	mi := &file_meshtastic_mesh_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeRemoteHardwarePin) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeRemoteHardwarePin) ProtoMessage() {}

func (x *NodeRemoteHardwarePin) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeRemoteHardwarePin.ProtoReflect.Descriptor instead.
func (*NodeRemoteHardwarePin) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{27}
}

func (x *NodeRemoteHardwarePin) GetNodeNum() uint32 {
	if x != nil {
		return x.NodeNum
	}
	return 0
}

func (x *NodeRemoteHardwarePin) GetPin() *RemoteHardwarePin {
	if x != nil {
		return x.Pin
	}
	return nil
}

type ChunkedPayload struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ID of the entire payload
	PayloadId uint32 `protobuf:"varint,1,opt,name=payload_id,json=payloadId,proto3" json:"payload_id,omitempty"`
	// The total number of chunks in the payload
	ChunkCount uint32 `protobuf:"varint,2,opt,name=chunk_count,json=chunkCount,proto3" json:"chunk_count,omitempty"`
	// The current chunk index in the total
	ChunkIndex uint32 `protobuf:"varint,3,opt,name=chunk_index,json=chunkIndex,proto3" json:"chunk_index,omitempty"`
	// The binary data of the current chunk
	PayloadChunk  []byte `protobuf:"bytes,4,opt,name=payload_chunk,json=payloadChunk,proto3" json:"payload_chunk,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChunkedPayload) Reset() {
	*x = ChunkedPayload{}
	mi := &file_meshtastic_mesh_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChunkedPayload) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChunkedPayload) ProtoMessage() {}

func (x *ChunkedPayload) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChunkedPayload.ProtoReflect.Descriptor instead.
func (*ChunkedPayload) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{28}
}

func (x *ChunkedPayload) GetPayloadId() uint32 {
	if x != nil {
		return x.PayloadId
	}
	return 0
}

func (x *ChunkedPayload) GetChunkCount() uint32 {
	if x != nil {
		return x.ChunkCount
	}
	return 0
}

func (x *ChunkedPayload) GetChunkIndex() uint32 {
	if x != nil {
		return x.ChunkIndex
	}
	return 0
}

func (x *ChunkedPayload) GetPayloadChunk() []byte {
	if x != nil {
		return x.PayloadChunk
	}
	return nil
}

// Wrapper message for broken repeated oneof support
type ResendChunks struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Chunks        []uint32               `protobuf:"varint,1,rep,packed,name=chunks,proto3" json:"chunks,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ResendChunks) Reset() {
	*x = ResendChunks{}
	mi := &file_meshtastic_mesh_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResendChunks) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResendChunks) ProtoMessage() {}

func (x *ResendChunks) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ResendChunks.ProtoReflect.Descriptor instead.
func (*ResendChunks) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{29}
}

func (x *ResendChunks) GetChunks() []uint32 {
	if x != nil {
		return x.Chunks
	}
	return nil
}

// Responses to a ChunkedPayload request
type ChunkedPayloadResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ID of the entire payload
	PayloadId uint32 `protobuf:"varint,1,opt,name=payload_id,json=payloadId,proto3" json:"payload_id,omitempty"`
	// Types that are valid to be assigned to PayloadVariant:
	//
	//	*ChunkedPayloadResponse_RequestTransfer
	//	*ChunkedPayloadResponse_AcceptTransfer
	//	*ChunkedPayloadResponse_ResendChunks
	PayloadVariant isChunkedPayloadResponse_PayloadVariant `protobuf_oneof:"payload_variant"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ChunkedPayloadResponse) Reset() {
	*x = ChunkedPayloadResponse{}
	mi := &file_meshtastic_mesh_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChunkedPayloadResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChunkedPayloadResponse) ProtoMessage() {}

func (x *ChunkedPayloadResponse) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_mesh_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChunkedPayloadResponse.ProtoReflect.Descriptor instead.
func (*ChunkedPayloadResponse) Descriptor() ([]byte, []int) {
	return file_meshtastic_mesh_proto_rawDescGZIP(), []int{30}
}

func (x *ChunkedPayloadResponse) GetPayloadId() uint32 {
	if x != nil {
		return x.PayloadId
	}
	return 0
}

func (x *ChunkedPayloadResponse) GetPayloadVariant() isChunkedPayloadResponse_PayloadVariant {
	if x != nil {
		return x.PayloadVariant
	}
	return nil
}

func (x *ChunkedPayloadResponse) GetRequestTransfer() bool {
	if x != nil {
		if x, ok := x.PayloadVariant.(*ChunkedPayloadResponse_RequestTransfer); ok {
			return x.RequestTransfer
		}
	}
	return false
}

func (x *ChunkedPayloadResponse) GetAcceptTransfer() bool {
	if x != nil {
		if x, ok := x.PayloadVariant.(*ChunkedPayloadResponse_AcceptTransfer); ok {
			return x.AcceptTransfer
		}
	}
	return false
}

func (x *ChunkedPayloadResponse) GetResendChunks() *ResendChunks {
	if x != nil {
		if x, ok := x.PayloadVariant.(*ChunkedPayloadResponse_ResendChunks); ok {
			return x.ResendChunks
		}
	}
	return nil
}

type isChunkedPayloadResponse_PayloadVariant interface {
	isChunkedPayloadResponse_PayloadVariant()
}

type ChunkedPayloadResponse_RequestTransfer struct {
	// Request to transfer chunked payload
	RequestTransfer bool `protobuf:"varint,2,opt,name=request_transfer,json=requestTransfer,proto3,oneof"`
}

type ChunkedPayloadResponse_AcceptTransfer struct {
	// Accept the transfer chunked payload
	AcceptTransfer bool `protobuf:"varint,3,opt,name=accept_transfer,json=acceptTransfer,proto3,oneof"`
}

type ChunkedPayloadResponse_ResendChunks struct {
	// Request missing indexes in the chunked payload
	ResendChunks *ResendChunks `protobuf:"bytes,4,opt,name=resend_chunks,json=resendChunks,proto3,oneof"`
}

func (*ChunkedPayloadResponse_RequestTransfer) isChunkedPayloadResponse_PayloadVariant() {}

func (*ChunkedPayloadResponse_AcceptTransfer) isChunkedPayloadResponse_PayloadVariant() {}

func (*ChunkedPayloadResponse_ResendChunks) isChunkedPayloadResponse_PayloadVariant() {}

var File_meshtastic_mesh_proto protoreflect.FileDescriptor

const file_meshtastic_mesh_proto_rawDesc = "" +
	"\n" +
	"\x15meshtastic/mesh.proto\x12\n" +
	"meshtastic\x1a\x18meshtastic/channel.proto\x1a\x17meshtastic/config.proto\x1a\x1emeshtastic/module_config.proto\x1a\x19meshtastic/portnums.proto\x1a\x1ameshtastic/telemetry.proto\x1a\x17meshtastic/xmodem.proto\x1a\x1ameshtastic/device_ui.proto\"\xa2\t\n" +
	"\bPosition\x12\"\n" +
	"\n" +
	"latitude_i\x18\x01 \x01(\x0fH\x00R\tlatitudeI\x88\x01\x01\x12$\n" +
	"\vlongitude_i\x18\x02 \x01(\x0fH\x01R\n" +
	"longitudeI\x88\x01\x01\x12\x1f\n" +
	"\baltitude\x18\x03 \x01(\x05H\x02R\baltitude\x88\x01\x01\x12\x12\n" +
	"\x04time\x18\x04 \x01(\aR\x04time\x12G\n" +
	"\x0flocation_source\x18\x05 \x01(\x0e2\x1e.meshtastic.Position.LocSourceR\x0elocationSource\x12G\n" +
	"\x0faltitude_source\x18\x06 \x01(\x0e2\x1e.meshtastic.Position.AltSourceR\x0ealtitudeSource\x12\x1c\n" +
	"\ttimestamp\x18\a \x01(\aR\ttimestamp\x126\n" +
	"\x17timestamp_millis_adjust\x18\b \x01(\x05R\x15timestampMillisAdjust\x12&\n" +
	"\faltitude_hae\x18\t \x01(\x11H\x03R\valtitudeHae\x88\x01\x01\x12C\n" +
	"\x1baltitude_geoidal_separation\x18\n" +
	" \x01(\x11H\x04R\x19altitudeGeoidalSeparation\x88\x01\x01\x12\x12\n" +
	"\x04PDOP\x18\v \x01(\rR\x04PDOP\x12\x12\n" +
	"\x04HDOP\x18\f \x01(\rR\x04HDOP\x12\x12\n" +
	"\x04VDOP\x18\r \x01(\rR\x04VDOP\x12!\n" +
	"\fgps_accuracy\x18\x0e \x01(\rR\vgpsAccuracy\x12&\n" +
	"\fground_speed\x18\x0f \x01(\rH\x05R\vgroundSpeed\x88\x01\x01\x12&\n" +
	"\fground_track\x18\x10 \x01(\rH\x06R\vgroundTrack\x88\x01\x01\x12\x1f\n" +
	"\vfix_quality\x18\x11 \x01(\rR\n" +
	"fixQuality\x12\x19\n" +
	"\bfix_type\x18\x12 \x01(\rR\afixType\x12 \n" +
	"\fsats_in_view\x18\x13 \x01(\rR\n" +
	"satsInView\x12\x1b\n" +
	"\tsensor_id\x18\x14 \x01(\rR\bsensorId\x12\x1f\n" +
	"\vnext_update\x18\x15 \x01(\rR\n" +
	"nextUpdate\x12\x1d\n" +
	"\n" +
	"seq_number\x18\x16 \x01(\rR\tseqNumber\x12%\n" +
	"\x0eprecision_bits\x18\x17 \x01(\rR\rprecisionBits\"N\n" +
	"\tLocSource\x12\r\n" +
	"\tLOC_UNSET\x10\x00\x12\x0e\n" +
	"\n" +
	"LOC_MANUAL\x10\x01\x12\x10\n" +
	"\fLOC_INTERNAL\x10\x02\x12\x10\n" +
	"\fLOC_EXTERNAL\x10\x03\"b\n" +
	"\tAltSource\x12\r\n" +
	"\tALT_UNSET\x10\x00\x12\x0e\n" +
	"\n" +
	"ALT_MANUAL\x10\x01\x12\x10\n" +
	"\fALT_INTERNAL\x10\x02\x12\x10\n" +
	"\fALT_EXTERNAL\x10\x03\x12\x12\n" +
	"\x0eALT_BAROMETRIC\x10\x04B\r\n" +
	"\v_latitude_iB\x0e\n" +
	"\f_longitude_iB\v\n" +
	"\t_altitudeB\x0f\n" +
	"\r_altitude_haeB\x1e\n" +
	"\x1c_altitude_geoidal_separationB\x0f\n" +
	"\r_ground_speedB\x0f\n" +
	"\r_ground_track\"\xe2\x02\n" +
	"\x04User\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x1b\n" +
	"\tlong_name\x18\x02 \x01(\tR\blongName\x12\x1d\n" +
	"\n" +
	"short_name\x18\x03 \x01(\tR\tshortName\x12\x1c\n" +
	"\amacaddr\x18\x04 \x01(\fB\x02\x18\x01R\amacaddr\x124\n" +
	"\bhw_model\x18\x05 \x01(\x0e2\x19.meshtastic.HardwareModelR\ahwModel\x12\x1f\n" +
	"\vis_licensed\x18\x06 \x01(\bR\n" +
	"isLicensed\x128\n" +
	"\x04role\x18\a \x01(\x0e2$.meshtastic.Config.DeviceConfig.RoleR\x04role\x12\x1d\n" +
	"\n" +
	"public_key\x18\b \x01(\fR\tpublicKey\x12,\n" +
	"\x0fis_unmessagable\x18\t \x01(\bH\x00R\x0eisUnmessagable\x88\x01\x01B\x12\n" +
	"\x10_is_unmessagable\"\x81\x01\n" +
	"\x0eRouteDiscovery\x12\x14\n" +
	"\x05route\x18\x01 \x03(\aR\x05route\x12\x1f\n" +
	"\vsnr_towards\x18\x02 \x03(\x05R\n" +
	"snrTowards\x12\x1d\n" +
	"\n" +
	"route_back\x18\x03 \x03(\aR\trouteBack\x12\x19\n" +
	"\bsnr_back\x18\x04 \x03(\x05R\asnrBack\"\x89\x04\n" +
	"\aRouting\x12A\n" +
	"\rroute_request\x18\x01 \x01(\v2\x1a.meshtastic.RouteDiscoveryH\x00R\frouteRequest\x12=\n" +
	"\vroute_reply\x18\x02 \x01(\v2\x1a.meshtastic.RouteDiscoveryH\x00R\n" +
	"routeReply\x12>\n" +
	"\ferror_reason\x18\x03 \x01(\x0e2\x19.meshtastic.Routing.ErrorH\x00R\verrorReason\"\xb0\x02\n" +
	"\x05Error\x12\b\n" +
	"\x04NONE\x10\x00\x12\f\n" +
	"\bNO_ROUTE\x10\x01\x12\v\n" +
	"\aGOT_NAK\x10\x02\x12\v\n" +
	"\aTIMEOUT\x10\x03\x12\x10\n" +
	"\fNO_INTERFACE\x10\x04\x12\x12\n" +
	"\x0eMAX_RETRANSMIT\x10\x05\x12\x0e\n" +
	"\n" +
	"NO_CHANNEL\x10\x06\x12\r\n" +
	"\tTOO_LARGE\x10\a\x12\x0f\n" +
	"\vNO_RESPONSE\x10\b\x12\x14\n" +
	"\x10DUTY_CYCLE_LIMIT\x10\t\x12\x0f\n" +
	"\vBAD_REQUEST\x10 \x12\x12\n" +
	"\x0eNOT_AUTHORIZED\x10!\x12\x0e\n" +
	"\n" +
	"PKI_FAILED\x10\"\x12\x16\n" +
	"\x12PKI_UNKNOWN_PUBKEY\x10#\x12\x19\n" +
	"\x15ADMIN_BAD_SESSION_KEY\x10$\x12!\n" +
	"\x1dADMIN_PUBLIC_KEY_UNAUTHORIZED\x10%B\t\n" +
	"\avariant\"\x9e\x02\n" +
	"\x04Data\x12-\n" +
	"\aportnum\x18\x01 \x01(\x0e2\x13.meshtastic.PortNumR\aportnum\x12\x18\n" +
	"\apayload\x18\x02 \x01(\fR\apayload\x12#\n" +
	"\rwant_response\x18\x03 \x01(\bR\fwantResponse\x12\x12\n" +
	"\x04dest\x18\x04 \x01(\aR\x04dest\x12\x16\n" +
	"\x06source\x18\x05 \x01(\aR\x06source\x12\x1d\n" +
	"\n" +
	"request_id\x18\x06 \x01(\aR\trequestId\x12\x19\n" +
	"\breply_id\x18\a \x01(\aR\areplyId\x12\x14\n" +
	"\x05emoji\x18\b \x01(\aR\x05emoji\x12\x1f\n" +
	"\bbitfield\x18\t \x01(\rH\x00R\bbitfield\x88\x01\x01B\v\n" +
	"\t_bitfield\"S\n" +
	"\x0fKeyVerification\x12\x14\n" +
	"\x05nonce\x18\x01 \x01(\x04R\x05nonce\x12\x14\n" +
	"\x05hash1\x18\x02 \x01(\fR\x05hash1\x12\x14\n" +
	"\x05hash2\x18\x03 \x01(\fR\x05hash2\"\x82\x02\n" +
	"\bWaypoint\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\rR\x02id\x12\"\n" +
	"\n" +
	"latitude_i\x18\x02 \x01(\x0fH\x00R\tlatitudeI\x88\x01\x01\x12$\n" +
	"\vlongitude_i\x18\x03 \x01(\x0fH\x01R\n" +
	"longitudeI\x88\x01\x01\x12\x16\n" +
	"\x06expire\x18\x04 \x01(\rR\x06expire\x12\x1b\n" +
	"\tlocked_to\x18\x05 \x01(\rR\blockedTo\x12\x12\n" +
	"\x04name\x18\x06 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\a \x01(\tR\vdescription\x12\x12\n" +
	"\x04icon\x18\b \x01(\aR\x04iconB\r\n" +
	"\v_latitude_iB\x0e\n" +
	"\f_longitude_i\"\x89\x01\n" +
	"\x16MqttClientProxyMessage\x12\x14\n" +
	"\x05topic\x18\x01 \x01(\tR\x05topic\x12\x14\n" +
	"\x04data\x18\x02 \x01(\fH\x00R\x04data\x12\x14\n" +
	"\x04text\x18\x03 \x01(\tH\x00R\x04text\x12\x1a\n" +
	"\bretained\x18\x04 \x01(\bR\bretainedB\x11\n" +
	"\x0fpayload_variant\"\xcc\x06\n" +
	"\n" +
	"MeshPacket\x12\x12\n" +
	"\x04from\x18\x01 \x01(\aR\x04from\x12\x0e\n" +
	"\x02to\x18\x02 \x01(\aR\x02to\x12\x18\n" +
	"\achannel\x18\x03 \x01(\rR\achannel\x12,\n" +
	"\adecoded\x18\x04 \x01(\v2\x10.meshtastic.DataH\x00R\adecoded\x12\x1e\n" +
	"\tencrypted\x18\x05 \x01(\fH\x00R\tencrypted\x12\x0e\n" +
	"\x02id\x18\x06 \x01(\aR\x02id\x12\x17\n" +
	"\arx_time\x18\a \x01(\aR\x06rxTime\x12\x15\n" +
	"\x06rx_snr\x18\b \x01(\x02R\x05rxSnr\x12\x1b\n" +
	"\thop_limit\x18\t \x01(\rR\bhopLimit\x12\x19\n" +
	"\bwant_ack\x18\n" +
	" \x01(\bR\awantAck\x12;\n" +
	"\bpriority\x18\v \x01(\x0e2\x1f.meshtastic.MeshPacket.PriorityR\bpriority\x12\x17\n" +
	"\arx_rssi\x18\f \x01(\x05R\x06rxRssi\x12<\n" +
	"\adelayed\x18\r \x01(\x0e2\x1e.meshtastic.MeshPacket.DelayedB\x02\x18\x01R\adelayed\x12\x19\n" +
	"\bvia_mqtt\x18\x0e \x01(\bR\aviaMqtt\x12\x1b\n" +
	"\thop_start\x18\x0f \x01(\rR\bhopStart\x12\x1d\n" +
	"\n" +
	"public_key\x18\x10 \x01(\fR\tpublicKey\x12#\n" +
	"\rpki_encrypted\x18\x11 \x01(\bR\fpkiEncrypted\x12\x19\n" +
	"\bnext_hop\x18\x12 \x01(\rR\anextHop\x12\x1d\n" +
	"\n" +
	"relay_node\x18\x13 \x01(\rR\trelayNode\x12\x19\n" +
	"\btx_after\x18\x14 \x01(\rR\atxAfter\"~\n" +
	"\bPriority\x12\t\n" +
	"\x05UNSET\x10\x00\x12\a\n" +
	"\x03MIN\x10\x01\x12\x0e\n" +
	"\n" +
	"BACKGROUND\x10\n" +
	"\x12\v\n" +
	"\aDEFAULT\x10@\x12\f\n" +
	"\bRELIABLE\x10F\x12\f\n" +
	"\bRESPONSE\x10P\x12\b\n" +
	"\x04HIGH\x10d\x12\t\n" +
	"\x05ALERT\x10n\x12\a\n" +
	"\x03ACK\x10x\x12\a\n" +
	"\x03MAX\x10\x7f\"B\n" +
	"\aDelayed\x12\f\n" +
	"\bNO_DELAY\x10\x00\x12\x15\n" +
	"\x11DELAYED_BROADCAST\x10\x01\x12\x12\n" +
	"\x0eDELAYED_DIRECT\x10\x02B\x11\n" +
	"\x0fpayload_variant\"\xc5\x03\n" +
	"\bNodeInfo\x12\x10\n" +
	"\x03num\x18\x01 \x01(\rR\x03num\x12$\n" +
	"\x04user\x18\x02 \x01(\v2\x10.meshtastic.UserR\x04user\x120\n" +
	"\bposition\x18\x03 \x01(\v2\x14.meshtastic.PositionR\bposition\x12\x10\n" +
	"\x03snr\x18\x04 \x01(\x02R\x03snr\x12\x1d\n" +
	"\n" +
	"last_heard\x18\x05 \x01(\aR\tlastHeard\x12@\n" +
	"\x0edevice_metrics\x18\x06 \x01(\v2\x19.meshtastic.DeviceMetricsR\rdeviceMetrics\x12\x18\n" +
	"\achannel\x18\a \x01(\rR\achannel\x12\x19\n" +
	"\bvia_mqtt\x18\b \x01(\bR\aviaMqtt\x12 \n" +
	"\thops_away\x18\t \x01(\rH\x00R\bhopsAway\x88\x01\x01\x12\x1f\n" +
	"\vis_favorite\x18\n" +
	" \x01(\bR\n" +
	"isFavorite\x12\x1d\n" +
	"\n" +
	"is_ignored\x18\v \x01(\bR\tisIgnored\x127\n" +
	"\x18is_key_manually_verified\x18\f \x01(\bR\x15isKeyManuallyVerifiedB\f\n" +
	"\n" +
	"_hops_away\"\xad\x01\n" +
	"\n" +
	"MyNodeInfo\x12\x1e\n" +
	"\vmy_node_num\x18\x01 \x01(\rR\tmyNodeNum\x12!\n" +
	"\freboot_count\x18\b \x01(\rR\vrebootCount\x12&\n" +
	"\x0fmin_app_version\x18\v \x01(\rR\rminAppVersion\x12\x1b\n" +
	"\tdevice_id\x18\f \x01(\fR\bdeviceId\x12\x17\n" +
	"\apio_env\x18\r \x01(\tR\x06pioEnv\"\xde\x01\n" +
	"\tLogRecord\x12\x18\n" +
	"\amessage\x18\x01 \x01(\tR\amessage\x12\x12\n" +
	"\x04time\x18\x02 \x01(\aR\x04time\x12\x16\n" +
	"\x06source\x18\x03 \x01(\tR\x06source\x121\n" +
	"\x05level\x18\x04 \x01(\x0e2\x1b.meshtastic.LogRecord.LevelR\x05level\"X\n" +
	"\x05Level\x12\t\n" +
	"\x05UNSET\x10\x00\x12\f\n" +
	"\bCRITICAL\x102\x12\t\n" +
	"\x05ERROR\x10(\x12\v\n" +
	"\aWARNING\x10\x1e\x12\b\n" +
	"\x04INFO\x10\x14\x12\t\n" +
	"\x05DEBUG\x10\n" +
	"\x12\t\n" +
	"\x05TRACE\x10\x05\"q\n" +
	"\vQueueStatus\x12\x10\n" +
	"\x03res\x18\x01 \x01(\x05R\x03res\x12\x12\n" +
	"\x04free\x18\x02 \x01(\rR\x04free\x12\x16\n" +
	"\x06maxlen\x18\x03 \x01(\rR\x06maxlen\x12$\n" +
	"\x0emesh_packet_id\x18\x04 \x01(\rR\fmeshPacketId\"\xc8\a\n" +
	"\tFromRadio\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\rR\x02id\x120\n" +
	"\x06packet\x18\x02 \x01(\v2\x16.meshtastic.MeshPacketH\x00R\x06packet\x121\n" +
	"\amy_info\x18\x03 \x01(\v2\x16.meshtastic.MyNodeInfoH\x00R\x06myInfo\x123\n" +
	"\tnode_info\x18\x04 \x01(\v2\x14.meshtastic.NodeInfoH\x00R\bnodeInfo\x12,\n" +
	"\x06config\x18\x05 \x01(\v2\x12.meshtastic.ConfigH\x00R\x06config\x126\n" +
	"\n" +
	"log_record\x18\x06 \x01(\v2\x15.meshtastic.LogRecordH\x00R\tlogRecord\x12.\n" +
	"\x12config_complete_id\x18\a \x01(\rH\x00R\x10configCompleteId\x12\x1c\n" +
	"\brebooted\x18\b \x01(\bH\x00R\brebooted\x12>\n" +
	"\fmoduleConfig\x18\t \x01(\v2\x18.meshtastic.ModuleConfigH\x00R\fmoduleConfig\x12/\n" +
	"\achannel\x18\n" +
	" \x01(\v2\x13.meshtastic.ChannelH\x00R\achannel\x12;\n" +
	"\vqueueStatus\x18\v \x01(\v2\x17.meshtastic.QueueStatusH\x00R\vqueueStatus\x128\n" +
	"\fxmodemPacket\x18\f \x01(\v2\x12.meshtastic.XModemH\x00R\fxmodemPacket\x128\n" +
	"\bmetadata\x18\r \x01(\v2\x1a.meshtastic.DeviceMetadataH\x00R\bmetadata\x12\\\n" +
	"\x16mqttClientProxyMessage\x18\x0e \x01(\v2\".meshtastic.MqttClientProxyMessageH\x00R\x16mqttClientProxyMessage\x122\n" +
	"\bfileInfo\x18\x0f \x01(\v2\x14.meshtastic.FileInfoH\x00R\bfileInfo\x12P\n" +
	"\x12clientNotification\x18\x10 \x01(\v2\x1e.meshtastic.ClientNotificationH\x00R\x12clientNotification\x12D\n" +
	"\x0edeviceuiConfig\x18\x11 \x01(\v2\x1a.meshtastic.DeviceUIConfigH\x00R\x0edeviceuiConfigB\x11\n" +
	"\x0fpayload_variant\"\x8e\x05\n" +
	"\x12ClientNotification\x12\x1e\n" +
	"\breply_id\x18\x01 \x01(\rH\x01R\areplyId\x88\x01\x01\x12\x12\n" +
	"\x04time\x18\x02 \x01(\aR\x04time\x121\n" +
	"\x05level\x18\x03 \x01(\x0e2\x1b.meshtastic.LogRecord.LevelR\x05level\x12\x18\n" +
	"\amessage\x18\x04 \x01(\tR\amessage\x12n\n" +
	"\x1ekey_verification_number_inform\x18\v \x01(\v2'.meshtastic.KeyVerificationNumberInformH\x00R\x1bkeyVerificationNumberInform\x12q\n" +
	"\x1fkey_verification_number_request\x18\f \x01(\v2(.meshtastic.KeyVerificationNumberRequestH\x00R\x1ckeyVerificationNumberRequest\x12X\n" +
	"\x16key_verification_final\x18\r \x01(\v2 .meshtastic.KeyVerificationFinalH\x00R\x14keyVerificationFinal\x12U\n" +
	"\x15duplicated_public_key\x18\x0e \x01(\v2\x1f.meshtastic.DuplicatedPublicKeyH\x00R\x13duplicatedPublicKey\x12C\n" +
	"\x0flow_entropy_key\x18\x0f \x01(\v2\x19.meshtastic.LowEntropyKeyH\x00R\rlowEntropyKeyB\x11\n" +
	"\x0fpayload_variantB\v\n" +
	"\t_reply_id\"\x85\x01\n" +
	"\x1bKeyVerificationNumberInform\x12\x14\n" +
	"\x05nonce\x18\x01 \x01(\x04R\x05nonce\x12'\n" +
	"\x0fremote_longname\x18\x02 \x01(\tR\x0eremoteLongname\x12'\n" +
	"\x0fsecurity_number\x18\x03 \x01(\rR\x0esecurityNumber\"]\n" +
	"\x1cKeyVerificationNumberRequest\x12\x14\n" +
	"\x05nonce\x18\x01 \x01(\x04R\x05nonce\x12'\n" +
	"\x0fremote_longname\x18\x02 \x01(\tR\x0eremoteLongname\"\xaa\x01\n" +
	"\x14KeyVerificationFinal\x12\x14\n" +
	"\x05nonce\x18\x01 \x01(\x04R\x05nonce\x12'\n" +
	"\x0fremote_longname\x18\x02 \x01(\tR\x0eremoteLongname\x12\x1a\n" +
	"\bisSender\x18\x03 \x01(\bR\bisSender\x127\n" +
	"\x17verification_characters\x18\x04 \x01(\tR\x16verificationCharacters\"\x15\n" +
	"\x13DuplicatedPublicKey\"\x0f\n" +
	"\rLowEntropyKey\"F\n" +
	"\bFileInfo\x12\x1b\n" +
	"\tfile_name\x18\x01 \x01(\tR\bfileName\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\x02 \x01(\rR\tsizeBytes\"\xe7\x02\n" +
	"\aToRadio\x120\n" +
	"\x06packet\x18\x01 \x01(\v2\x16.meshtastic.MeshPacketH\x00R\x06packet\x12&\n" +
	"\x0ewant_config_id\x18\x03 \x01(\rH\x00R\fwantConfigId\x12 \n" +
	"\n" +
	"disconnect\x18\x04 \x01(\bH\x00R\n" +
	"disconnect\x128\n" +
	"\fxmodemPacket\x18\x05 \x01(\v2\x12.meshtastic.XModemH\x00R\fxmodemPacket\x12\\\n" +
	"\x16mqttClientProxyMessage\x18\x06 \x01(\v2\".meshtastic.MqttClientProxyMessageH\x00R\x16mqttClientProxyMessage\x125\n" +
	"\theartbeat\x18\a \x01(\v2\x15.meshtastic.HeartbeatH\x00R\theartbeatB\x11\n" +
	"\x0fpayload_variant\"O\n" +
	"\n" +
	"Compressed\x12-\n" +
	"\aportnum\x18\x01 \x01(\x0e2\x13.meshtastic.PortNumR\aportnum\x12\x12\n" +
	"\x04data\x18\x02 \x01(\fR\x04data\"\xc3\x01\n" +
	"\fNeighborInfo\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\rR\x06nodeId\x12%\n" +
	"\x0flast_sent_by_id\x18\x02 \x01(\rR\flastSentById\x12?\n" +
	"\x1cnode_broadcast_interval_secs\x18\x03 \x01(\rR\x19nodeBroadcastIntervalSecs\x122\n" +
	"\tneighbors\x18\x04 \x03(\v2\x14.meshtastic.NeighborR\tneighbors\"\x98\x01\n" +
	"\bNeighbor\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\rR\x06nodeId\x12\x10\n" +
	"\x03snr\x18\x02 \x01(\x02R\x03snr\x12 \n" +
	"\flast_rx_time\x18\x03 \x01(\aR\n" +
	"lastRxTime\x12?\n" +
	"\x1cnode_broadcast_interval_secs\x18\x04 \x01(\rR\x19nodeBroadcastIntervalSecs\"\xf7\x03\n" +
	"\x0eDeviceMetadata\x12)\n" +
	"\x10firmware_version\x18\x01 \x01(\tR\x0ffirmwareVersion\x120\n" +
	"\x14device_state_version\x18\x02 \x01(\rR\x12deviceStateVersion\x12 \n" +
	"\vcanShutdown\x18\x03 \x01(\bR\vcanShutdown\x12\x18\n" +
	"\ahasWifi\x18\x04 \x01(\bR\ahasWifi\x12\"\n" +
	"\fhasBluetooth\x18\x05 \x01(\bR\fhasBluetooth\x12 \n" +
	"\vhasEthernet\x18\x06 \x01(\bR\vhasEthernet\x128\n" +
	"\x04role\x18\a \x01(\x0e2$.meshtastic.Config.DeviceConfig.RoleR\x04role\x12%\n" +
	"\x0eposition_flags\x18\b \x01(\rR\rpositionFlags\x124\n" +
	"\bhw_model\x18\t \x01(\x0e2\x19.meshtastic.HardwareModelR\ahwModel\x12,\n" +
	"\x11hasRemoteHardware\x18\n" +
	" \x01(\bR\x11hasRemoteHardware\x12\x16\n" +
	"\x06hasPKC\x18\v \x01(\bR\x06hasPKC\x12)\n" +
	"\x10excluded_modules\x18\f \x01(\rR\x0fexcludedModules\"\v\n" +
	"\tHeartbeat\"c\n" +
	"\x15NodeRemoteHardwarePin\x12\x19\n" +
	"\bnode_num\x18\x01 \x01(\rR\anodeNum\x12/\n" +
	"\x03pin\x18\x02 \x01(\v2\x1d.meshtastic.RemoteHardwarePinR\x03pin\"\x96\x01\n" +
	"\x0eChunkedPayload\x12\x1d\n" +
	"\n" +
	"payload_id\x18\x01 \x01(\rR\tpayloadId\x12\x1f\n" +
	"\vchunk_count\x18\x02 \x01(\rR\n" +
	"chunkCount\x12\x1f\n" +
	"\vchunk_index\x18\x03 \x01(\rR\n" +
	"chunkIndex\x12#\n" +
	"\rpayload_chunk\x18\x04 \x01(\fR\fpayloadChunk\"'\n" +
	"\rresend_chunks\x12\x16\n" +
	"\x06chunks\x18\x01 \x03(\rR\x06chunks\"\xe4\x01\n" +
	"\x16ChunkedPayloadResponse\x12\x1d\n" +
	"\n" +
	"payload_id\x18\x01 \x01(\rR\tpayloadId\x12+\n" +
	"\x10request_transfer\x18\x02 \x01(\bH\x00R\x0frequestTransfer\x12)\n" +
	"\x0faccept_transfer\x18\x03 \x01(\bH\x00R\x0eacceptTransfer\x12@\n" +
	"\rresend_chunks\x18\x04 \x01(\v2\x19.meshtastic.resend_chunksH\x00R\fresendChunksB\x11\n" +
	"\x0fpayload_variant*\x95\x10\n" +
	"\rHardwareModel\x12\t\n" +
	"\x05UNSET\x10\x00\x12\f\n" +
	"\bTLORA_V2\x10\x01\x12\f\n" +
	"\bTLORA_V1\x10\x02\x12\x12\n" +
	"\x0eTLORA_V2_1_1P6\x10\x03\x12\t\n" +
	"\x05TBEAM\x10\x04\x12\x0f\n" +
	"\vHELTEC_V2_0\x10\x05\x12\x0e\n" +
	"\n" +
	"TBEAM_V0P7\x10\x06\x12\n" +
	"\n" +
	"\x06T_ECHO\x10\a\x12\x10\n" +
	"\fTLORA_V1_1P3\x10\b\x12\v\n" +
	"\aRAK4631\x10\t\x12\x0f\n" +
	"\vHELTEC_V2_1\x10\n" +
	"\x12\r\n" +
	"\tHELTEC_V1\x10\v\x12\x18\n" +
	"\x14LILYGO_TBEAM_S3_CORE\x10\f\x12\f\n" +
	"\bRAK11200\x10\r\x12\v\n" +
	"\aNANO_G1\x10\x0e\x12\x12\n" +
	"\x0eTLORA_V2_1_1P8\x10\x0f\x12\x0f\n" +
	"\vTLORA_T3_S3\x10\x10\x12\x14\n" +
	"\x10NANO_G1_EXPLORER\x10\x11\x12\x11\n" +
	"\rNANO_G2_ULTRA\x10\x12\x12\r\n" +
	"\tLORA_TYPE\x10\x13\x12\v\n" +
	"\aWIPHONE\x10\x14\x12\x0e\n" +
	"\n" +
	"WIO_WM1110\x10\x15\x12\v\n" +
	"\aRAK2560\x10\x16\x12\x13\n" +
	"\x0fHELTEC_HRU_3601\x10\x17\x12\x1a\n" +
	"\x16HELTEC_WIRELESS_BRIDGE\x10\x18\x12\x0e\n" +
	"\n" +
	"STATION_G1\x10\x19\x12\f\n" +
	"\bRAK11310\x10\x1a\x12\x14\n" +
	"\x10SENSELORA_RP2040\x10\x1b\x12\x10\n" +
	"\fSENSELORA_S3\x10\x1c\x12\r\n" +
	"\tCANARYONE\x10\x1d\x12\x0f\n" +
	"\vRP2040_LORA\x10\x1e\x12\x0e\n" +
	"\n" +
	"STATION_G2\x10\x1f\x12\x11\n" +
	"\rLORA_RELAY_V1\x10 \x12\x0e\n" +
	"\n" +
	"NRF52840DK\x10!\x12\a\n" +
	"\x03PPR\x10\"\x12\x0f\n" +
	"\vGENIEBLOCKS\x10#\x12\x11\n" +
	"\rNRF52_UNKNOWN\x10$\x12\r\n" +
	"\tPORTDUINO\x10%\x12\x0f\n" +
	"\vANDROID_SIM\x10&\x12\n" +
	"\n" +
	"\x06DIY_V1\x10'\x12\x15\n" +
	"\x11NRF52840_PCA10059\x10(\x12\n" +
	"\n" +
	"\x06DR_DEV\x10)\x12\v\n" +
	"\aM5STACK\x10*\x12\r\n" +
	"\tHELTEC_V3\x10+\x12\x11\n" +
	"\rHELTEC_WSL_V3\x10,\x12\x13\n" +
	"\x0fBETAFPV_2400_TX\x10-\x12\x17\n" +
	"\x13BETAFPV_900_NANO_TX\x10.\x12\f\n" +
	"\bRPI_PICO\x10/\x12\x1b\n" +
	"\x17HELTEC_WIRELESS_TRACKER\x100\x12\x19\n" +
	"\x15HELTEC_WIRELESS_PAPER\x101\x12\n" +
	"\n" +
	"\x06T_DECK\x102\x12\x0e\n" +
	"\n" +
	"T_WATCH_S3\x103\x12\x11\n" +
	"\rPICOMPUTER_S3\x104\x12\x0f\n" +
	"\vHELTEC_HT62\x105\x12\x12\n" +
	"\x0eEBYTE_ESP32_S3\x106\x12\x11\n" +
	"\rESP32_S3_PICO\x107\x12\r\n" +
	"\tCHATTER_2\x108\x12\x1e\n" +
	"\x1aHELTEC_WIRELESS_PAPER_V1_0\x109\x12 \n" +
	"\x1cHELTEC_WIRELESS_TRACKER_V1_0\x10:\x12\v\n" +
	"\aUNPHONE\x10;\x12\f\n" +
	"\bTD_LORAC\x10<\x12\x13\n" +
	"\x0fCDEBYTE_EORA_S3\x10=\x12\x0f\n" +
	"\vTWC_MESH_V4\x10>\x12\x16\n" +
	"\x12NRF52_PROMICRO_DIY\x10?\x12\x1f\n" +
	"\x1bRADIOMASTER_900_BANDIT_NANO\x10@\x12\x1c\n" +
	"\x18HELTEC_CAPSULE_SENSOR_V3\x10A\x12\x1d\n" +
	"\x19HELTEC_VISION_MASTER_T190\x10B\x12\x1d\n" +
	"\x19HELTEC_VISION_MASTER_E213\x10C\x12\x1d\n" +
	"\x19HELTEC_VISION_MASTER_E290\x10D\x12\x19\n" +
	"\x15HELTEC_MESH_NODE_T114\x10E\x12\x16\n" +
	"\x12SENSECAP_INDICATOR\x10F\x12\x13\n" +
	"\x0fTRACKER_T1000_E\x10G\x12\v\n" +
	"\aRAK3172\x10H\x12\n" +
	"\n" +
	"\x06WIO_E5\x10I\x12\x1a\n" +
	"\x16RADIOMASTER_900_BANDIT\x10J\x12\x13\n" +
	"\x0fME25LS01_4Y10TD\x10K\x12\x18\n" +
	"\x14RP2040_FEATHER_RFM95\x10L\x12\x15\n" +
	"\x11M5STACK_COREBASIC\x10M\x12\x11\n" +
	"\rM5STACK_CORE2\x10N\x12\r\n" +
	"\tRPI_PICO2\x10O\x12\x12\n" +
	"\x0eM5STACK_CORES3\x10P\x12\x11\n" +
	"\rSEEED_XIAO_S3\x10Q\x12\v\n" +
	"\aMS24SF1\x10R\x12\f\n" +
	"\bTLORA_C6\x10S\x12\x0f\n" +
	"\vWISMESH_TAP\x10T\x12\r\n" +
	"\tROUTASTIC\x10U\x12\f\n" +
	"\bMESH_TAB\x10V\x12\f\n" +
	"\bMESHLINK\x10W\x12\x12\n" +
	"\x0eXIAO_NRF52_KIT\x10X\x12\x10\n" +
	"\fTHINKNODE_M1\x10Y\x12\x10\n" +
	"\fTHINKNODE_M2\x10Z\x12\x0f\n" +
	"\vT_ETH_ELITE\x10[\x12\x15\n" +
	"\x11HELTEC_SENSOR_HUB\x10\\\x12\x1a\n" +
	"\x16RESERVED_FRIED_CHICKEN\x10]\x12\x16\n" +
	"\x12HELTEC_MESH_POCKET\x10^\x12\x14\n" +
	"\x10SEEED_SOLAR_NODE\x10_\x12\x18\n" +
	"\x14NOMADSTAR_METEOR_PRO\x10`\x12\r\n" +
	"\tCROWPANEL\x10a\x12\v\n" +
	"\aLINK_32\x10b\x12\x18\n" +
	"\x14SEEED_WIO_TRACKER_L1\x10c\x12\x1d\n" +
	"\x19SEEED_WIO_TRACKER_L1_EINK\x10d\x12\x14\n" +
	"\x10QWANTZ_TINY_ARMS\x10e\x12\x0e\n" +
	"\n" +
	"T_DECK_PRO\x10f\x12\x10\n" +
	"\fT_LORA_PAGER\x10g\x12\x1d\n" +
	"\x19GAT562_MESH_TRIAL_TRACKER\x10h\x12\x0f\n" +
	"\vWISMESH_TAG\x10i\x12\v\n" +
	"\aRAK3312\x10j\x12\x0f\n" +
	"\n" +
	"PRIVATE_HW\x10\xff\x01*,\n" +
	"\tConstants\x12\b\n" +
	"\x04ZERO\x10\x00\x12\x15\n" +
	"\x10DATA_PAYLOAD_LEN\x10\xe9\x01*\xb4\x02\n" +
	"\x11CriticalErrorCode\x12\b\n" +
	"\x04NONE\x10\x00\x12\x0f\n" +
	"\vTX_WATCHDOG\x10\x01\x12\x14\n" +
	"\x10SLEEP_ENTER_WAIT\x10\x02\x12\f\n" +
	"\bNO_RADIO\x10\x03\x12\x0f\n" +
	"\vUNSPECIFIED\x10\x04\x12\x15\n" +
	"\x11UBLOX_UNIT_FAILED\x10\x05\x12\r\n" +
	"\tNO_AXP192\x10\x06\x12\x19\n" +
	"\x15INVALID_RADIO_SETTING\x10\a\x12\x13\n" +
	"\x0fTRANSMIT_FAILED\x10\b\x12\f\n" +
	"\bBROWNOUT\x10\t\x12\x12\n" +
	"\x0eSX1262_FAILURE\x10\n" +
	"\x12\x11\n" +
	"\rRADIO_SPI_BUG\x10\v\x12 \n" +
	"\x1cFLASH_CORRUPTION_RECOVERABLE\x10\f\x12\"\n" +
	"\x1eFLASH_CORRUPTION_UNRECOVERABLE\x10\r*\x80\x03\n" +
	"\x0fExcludedModules\x12\x11\n" +
	"\rEXCLUDED_NONE\x10\x00\x12\x0f\n" +
	"\vMQTT_CONFIG\x10\x01\x12\x11\n" +
	"\rSERIAL_CONFIG\x10\x02\x12\x13\n" +
	"\x0fEXTNOTIF_CONFIG\x10\x04\x12\x17\n" +
	"\x13STOREFORWARD_CONFIG\x10\b\x12\x14\n" +
	"\x10RANGETEST_CONFIG\x10\x10\x12\x14\n" +
	"\x10TELEMETRY_CONFIG\x10 \x12\x14\n" +
	"\x10CANNEDMSG_CONFIG\x10@\x12\x11\n" +
	"\fAUDIO_CONFIG\x10\x80\x01\x12\x1a\n" +
	"\x15REMOTEHARDWARE_CONFIG\x10\x80\x02\x12\x18\n" +
	"\x13NEIGHBORINFO_CONFIG\x10\x80\x04\x12\x1b\n" +
	"\x16AMBIENTLIGHTING_CONFIG\x10\x80\b\x12\x1b\n" +
	"\x16DETECTIONSENSOR_CONFIG\x10\x80\x10\x12\x16\n" +
	"\x11PAXCOUNTER_CONFIG\x10\x80 \x12\x15\n" +
	"\x10BLUETOOTH_CONFIG\x10\x80@\x12\x14\n" +
	"\x0eNETWORK_CONFIG\x10\x80\x80\x01B_\n" +
	"\x13com.geeksville.meshB\n" +
	"MeshProtosZ\"github.com/meshtastic/go/generated\xaa\x02\x14Meshtastic.Protobufs\xba\x02\x00b\x06proto3"

var (
	file_meshtastic_mesh_proto_rawDescOnce sync.Once
	file_meshtastic_mesh_proto_rawDescData []byte
)

func file_meshtastic_mesh_proto_rawDescGZIP() []byte {
	file_meshtastic_mesh_proto_rawDescOnce.Do(func() {
		file_meshtastic_mesh_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_meshtastic_mesh_proto_rawDesc), len(file_meshtastic_mesh_proto_rawDesc)))
	})
	return file_meshtastic_mesh_proto_rawDescData
}

var file_meshtastic_mesh_proto_enumTypes = make([]protoimpl.EnumInfo, 10)
var file_meshtastic_mesh_proto_msgTypes = make([]protoimpl.MessageInfo, 31)
var file_meshtastic_mesh_proto_goTypes = []any{
	(HardwareModel)(0),                   // 0: meshtastic.HardwareModel
	(Constants)(0),                       // 1: meshtastic.Constants
	(CriticalErrorCode)(0),               // 2: meshtastic.CriticalErrorCode
	(ExcludedModules)(0),                 // 3: meshtastic.ExcludedModules
	(Position_LocSource)(0),              // 4: meshtastic.Position.LocSource
	(Position_AltSource)(0),              // 5: meshtastic.Position.AltSource
	(Routing_Error)(0),                   // 6: meshtastic.Routing.Error
	(MeshPacket_Priority)(0),             // 7: meshtastic.MeshPacket.Priority
	(MeshPacket_Delayed)(0),              // 8: meshtastic.MeshPacket.Delayed
	(LogRecord_Level)(0),                 // 9: meshtastic.LogRecord.Level
	(*Position)(nil),                     // 10: meshtastic.Position
	(*User)(nil),                         // 11: meshtastic.User
	(*RouteDiscovery)(nil),               // 12: meshtastic.RouteDiscovery
	(*Routing)(nil),                      // 13: meshtastic.Routing
	(*Data)(nil),                         // 14: meshtastic.Data
	(*KeyVerification)(nil),              // 15: meshtastic.KeyVerification
	(*Waypoint)(nil),                     // 16: meshtastic.Waypoint
	(*MqttClientProxyMessage)(nil),       // 17: meshtastic.MqttClientProxyMessage
	(*MeshPacket)(nil),                   // 18: meshtastic.MeshPacket
	(*NodeInfo)(nil),                     // 19: meshtastic.NodeInfo
	(*MyNodeInfo)(nil),                   // 20: meshtastic.MyNodeInfo
	(*LogRecord)(nil),                    // 21: meshtastic.LogRecord
	(*QueueStatus)(nil),                  // 22: meshtastic.QueueStatus
	(*FromRadio)(nil),                    // 23: meshtastic.FromRadio
	(*ClientNotification)(nil),           // 24: meshtastic.ClientNotification
	(*KeyVerificationNumberInform)(nil),  // 25: meshtastic.KeyVerificationNumberInform
	(*KeyVerificationNumberRequest)(nil), // 26: meshtastic.KeyVerificationNumberRequest
	(*KeyVerificationFinal)(nil),         // 27: meshtastic.KeyVerificationFinal
	(*DuplicatedPublicKey)(nil),          // 28: meshtastic.DuplicatedPublicKey
	(*LowEntropyKey)(nil),                // 29: meshtastic.LowEntropyKey
	(*FileInfo)(nil),                     // 30: meshtastic.FileInfo
	(*ToRadio)(nil),                      // 31: meshtastic.ToRadio
	(*Compressed)(nil),                   // 32: meshtastic.Compressed
	(*NeighborInfo)(nil),                 // 33: meshtastic.NeighborInfo
	(*Neighbor)(nil),                     // 34: meshtastic.Neighbor
	(*DeviceMetadata)(nil),               // 35: meshtastic.DeviceMetadata
	(*Heartbeat)(nil),                    // 36: meshtastic.Heartbeat
	(*NodeRemoteHardwarePin)(nil),        // 37: meshtastic.NodeRemoteHardwarePin
	(*ChunkedPayload)(nil),               // 38: meshtastic.ChunkedPayload
	(*ResendChunks)(nil),                 // 39: meshtastic.resend_chunks
	(*ChunkedPayloadResponse)(nil),       // 40: meshtastic.ChunkedPayloadResponse
	(Config_DeviceConfig_Role)(0),        // 41: meshtastic.Config.DeviceConfig.Role
	(PortNum)(0),                         // 42: meshtastic.PortNum
	(*DeviceMetrics)(nil),                // 43: meshtastic.DeviceMetrics
	(*Config)(nil),                       // 44: meshtastic.Config
	(*ModuleConfig)(nil),                 // 45: meshtastic.ModuleConfig
	(*Channel)(nil),                      // 46: meshtastic.Channel
	(*XModem)(nil),                       // 47: meshtastic.XModem
	(*DeviceUIConfig)(nil),               // 48: meshtastic.DeviceUIConfig
	(*RemoteHardwarePin)(nil),            // 49: meshtastic.RemoteHardwarePin
}
var file_meshtastic_mesh_proto_depIdxs = []int32{
	4,  // 0: meshtastic.Position.location_source:type_name -> meshtastic.Position.LocSource
	5,  // 1: meshtastic.Position.altitude_source:type_name -> meshtastic.Position.AltSource
	0,  // 2: meshtastic.User.hw_model:type_name -> meshtastic.HardwareModel
	41, // 3: meshtastic.User.role:type_name -> meshtastic.Config.DeviceConfig.Role
	12, // 4: meshtastic.Routing.route_request:type_name -> meshtastic.RouteDiscovery
	12, // 5: meshtastic.Routing.route_reply:type_name -> meshtastic.RouteDiscovery
	6,  // 6: meshtastic.Routing.error_reason:type_name -> meshtastic.Routing.Error
	42, // 7: meshtastic.Data.portnum:type_name -> meshtastic.PortNum
	14, // 8: meshtastic.MeshPacket.decoded:type_name -> meshtastic.Data
	7,  // 9: meshtastic.MeshPacket.priority:type_name -> meshtastic.MeshPacket.Priority
	8,  // 10: meshtastic.MeshPacket.delayed:type_name -> meshtastic.MeshPacket.Delayed
	11, // 11: meshtastic.NodeInfo.user:type_name -> meshtastic.User
	10, // 12: meshtastic.NodeInfo.position:type_name -> meshtastic.Position
	43, // 13: meshtastic.NodeInfo.device_metrics:type_name -> meshtastic.DeviceMetrics
	9,  // 14: meshtastic.LogRecord.level:type_name -> meshtastic.LogRecord.Level
	18, // 15: meshtastic.FromRadio.packet:type_name -> meshtastic.MeshPacket
	20, // 16: meshtastic.FromRadio.my_info:type_name -> meshtastic.MyNodeInfo
	19, // 17: meshtastic.FromRadio.node_info:type_name -> meshtastic.NodeInfo
	44, // 18: meshtastic.FromRadio.config:type_name -> meshtastic.Config
	21, // 19: meshtastic.FromRadio.log_record:type_name -> meshtastic.LogRecord
	45, // 20: meshtastic.FromRadio.moduleConfig:type_name -> meshtastic.ModuleConfig
	46, // 21: meshtastic.FromRadio.channel:type_name -> meshtastic.Channel
	22, // 22: meshtastic.FromRadio.queueStatus:type_name -> meshtastic.QueueStatus
	47, // 23: meshtastic.FromRadio.xmodemPacket:type_name -> meshtastic.XModem
	35, // 24: meshtastic.FromRadio.metadata:type_name -> meshtastic.DeviceMetadata
	17, // 25: meshtastic.FromRadio.mqttClientProxyMessage:type_name -> meshtastic.MqttClientProxyMessage
	30, // 26: meshtastic.FromRadio.fileInfo:type_name -> meshtastic.FileInfo
	24, // 27: meshtastic.FromRadio.clientNotification:type_name -> meshtastic.ClientNotification
	48, // 28: meshtastic.FromRadio.deviceuiConfig:type_name -> meshtastic.DeviceUIConfig
	9,  // 29: meshtastic.ClientNotification.level:type_name -> meshtastic.LogRecord.Level
	25, // 30: meshtastic.ClientNotification.key_verification_number_inform:type_name -> meshtastic.KeyVerificationNumberInform
	26, // 31: meshtastic.ClientNotification.key_verification_number_request:type_name -> meshtastic.KeyVerificationNumberRequest
	27, // 32: meshtastic.ClientNotification.key_verification_final:type_name -> meshtastic.KeyVerificationFinal
	28, // 33: meshtastic.ClientNotification.duplicated_public_key:type_name -> meshtastic.DuplicatedPublicKey
	29, // 34: meshtastic.ClientNotification.low_entropy_key:type_name -> meshtastic.LowEntropyKey
	18, // 35: meshtastic.ToRadio.packet:type_name -> meshtastic.MeshPacket
	47, // 36: meshtastic.ToRadio.xmodemPacket:type_name -> meshtastic.XModem
	17, // 37: meshtastic.ToRadio.mqttClientProxyMessage:type_name -> meshtastic.MqttClientProxyMessage
	36, // 38: meshtastic.ToRadio.heartbeat:type_name -> meshtastic.Heartbeat
	42, // 39: meshtastic.Compressed.portnum:type_name -> meshtastic.PortNum
	34, // 40: meshtastic.NeighborInfo.neighbors:type_name -> meshtastic.Neighbor
	41, // 41: meshtastic.DeviceMetadata.role:type_name -> meshtastic.Config.DeviceConfig.Role
	0,  // 42: meshtastic.DeviceMetadata.hw_model:type_name -> meshtastic.HardwareModel
	49, // 43: meshtastic.NodeRemoteHardwarePin.pin:type_name -> meshtastic.RemoteHardwarePin
	39, // 44: meshtastic.ChunkedPayloadResponse.resend_chunks:type_name -> meshtastic.resend_chunks
	45, // [45:45] is the sub-list for method output_type
	45, // [45:45] is the sub-list for method input_type
	45, // [45:45] is the sub-list for extension type_name
	45, // [45:45] is the sub-list for extension extendee
	0,  // [0:45] is the sub-list for field type_name
}

func init() { file_meshtastic_mesh_proto_init() }
func file_meshtastic_mesh_proto_init() {
	if File_meshtastic_mesh_proto != nil {
		return
	}
	file_meshtastic_channel_proto_init()
	file_meshtastic_config_proto_init()
	file_meshtastic_module_config_proto_init()
	file_meshtastic_portnums_proto_init()
	file_meshtastic_telemetry_proto_init()
	file_meshtastic_xmodem_proto_init()
	file_meshtastic_device_ui_proto_init()
	file_meshtastic_mesh_proto_msgTypes[0].OneofWrappers = []any{}
	file_meshtastic_mesh_proto_msgTypes[1].OneofWrappers = []any{}
	file_meshtastic_mesh_proto_msgTypes[3].OneofWrappers = []any{
		(*Routing_RouteRequest)(nil),
		(*Routing_RouteReply)(nil),
		(*Routing_ErrorReason)(nil),
	}
	file_meshtastic_mesh_proto_msgTypes[4].OneofWrappers = []any{}
	file_meshtastic_mesh_proto_msgTypes[6].OneofWrappers = []any{}
	file_meshtastic_mesh_proto_msgTypes[7].OneofWrappers = []any{
		(*MqttClientProxyMessage_Data)(nil),
		(*MqttClientProxyMessage_Text)(nil),
	}
	file_meshtastic_mesh_proto_msgTypes[8].OneofWrappers = []any{
		(*MeshPacket_Decoded)(nil),
		(*MeshPacket_Encrypted)(nil),
	}
	file_meshtastic_mesh_proto_msgTypes[9].OneofWrappers = []any{}
	file_meshtastic_mesh_proto_msgTypes[13].OneofWrappers = []any{
		(*FromRadio_Packet)(nil),
		(*FromRadio_MyInfo)(nil),
		(*FromRadio_NodeInfo)(nil),
		(*FromRadio_Config)(nil),
		(*FromRadio_LogRecord)(nil),
		(*FromRadio_ConfigCompleteId)(nil),
		(*FromRadio_Rebooted)(nil),
		(*FromRadio_ModuleConfig)(nil),
		(*FromRadio_Channel)(nil),
		(*FromRadio_QueueStatus)(nil),
		(*FromRadio_XmodemPacket)(nil),
		(*FromRadio_Metadata)(nil),
		(*FromRadio_MqttClientProxyMessage)(nil),
		(*FromRadio_FileInfo)(nil),
		(*FromRadio_ClientNotification)(nil),
		(*FromRadio_DeviceuiConfig)(nil),
	}
	file_meshtastic_mesh_proto_msgTypes[14].OneofWrappers = []any{
		(*ClientNotification_KeyVerificationNumberInform)(nil),
		(*ClientNotification_KeyVerificationNumberRequest)(nil),
		(*ClientNotification_KeyVerificationFinal)(nil),
		(*ClientNotification_DuplicatedPublicKey)(nil),
		(*ClientNotification_LowEntropyKey)(nil),
	}
	file_meshtastic_mesh_proto_msgTypes[21].OneofWrappers = []any{
		(*ToRadio_Packet)(nil),
		(*ToRadio_WantConfigId)(nil),
		(*ToRadio_Disconnect)(nil),
		(*ToRadio_XmodemPacket)(nil),
		(*ToRadio_MqttClientProxyMessage)(nil),
		(*ToRadio_Heartbeat)(nil),
	}
	file_meshtastic_mesh_proto_msgTypes[30].OneofWrappers = []any{
		(*ChunkedPayloadResponse_RequestTransfer)(nil),
		(*ChunkedPayloadResponse_AcceptTransfer)(nil),
		(*ChunkedPayloadResponse_ResendChunks)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_meshtastic_mesh_proto_rawDesc), len(file_meshtastic_mesh_proto_rawDesc)),
			NumEnums:      10,
			NumMessages:   31,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_meshtastic_mesh_proto_goTypes,
		DependencyIndexes: file_meshtastic_mesh_proto_depIdxs,
		EnumInfos:         file_meshtastic_mesh_proto_enumTypes,
		MessageInfos:      file_meshtastic_mesh_proto_msgTypes,
	}.Build()
	File_meshtastic_mesh_proto = out.File
	file_meshtastic_mesh_proto_goTypes = nil
	file_meshtastic_mesh_proto_depIdxs = nil
}
