// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v3.21.12
// source: meshtastic/module_config.proto

package generated

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type RemoteHardwarePinType int32

const (
	// Unset/unused
	RemoteHardwarePinType_UNKNOWN RemoteHardwarePinType = 0
	// GPIO pin can be read (if it is high / low)
	RemoteHardwarePinType_DIGITAL_READ RemoteHardwarePinType = 1
	// GPIO pin can be written to (high / low)
	RemoteHardwarePinType_DIGITAL_WRITE RemoteHardwarePinType = 2
)

// Enum value maps for RemoteHardwarePinType.
var (
	RemoteHardwarePinType_name = map[int32]string{
		0: "UNKNOWN",
		1: "DIGITAL_READ",
		2: "DIGITAL_WRITE",
	}
	RemoteHardwarePinType_value = map[string]int32{
		"UNKNOWN":       0,
		"DIGITAL_READ":  1,
		"DIGITAL_WRITE": 2,
	}
)

func (x RemoteHardwarePinType) Enum() *RemoteHardwarePinType {
	p := new(RemoteHardwarePinType)
	*p = x
	return p
}

func (x RemoteHardwarePinType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RemoteHardwarePinType) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_module_config_proto_enumTypes[0].Descriptor()
}

func (RemoteHardwarePinType) Type() protoreflect.EnumType {
	return &file_meshtastic_module_config_proto_enumTypes[0]
}

func (x RemoteHardwarePinType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use RemoteHardwarePinType.Descriptor instead.
func (RemoteHardwarePinType) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_module_config_proto_rawDescGZIP(), []int{0}
}

type ModuleConfig_DetectionSensorConfig_TriggerType int32

const (
	// Event is triggered if pin is low
	ModuleConfig_DetectionSensorConfig_LOGIC_LOW ModuleConfig_DetectionSensorConfig_TriggerType = 0
	// Event is triggered if pin is high
	ModuleConfig_DetectionSensorConfig_LOGIC_HIGH ModuleConfig_DetectionSensorConfig_TriggerType = 1
	// Event is triggered when pin goes high to low
	ModuleConfig_DetectionSensorConfig_FALLING_EDGE ModuleConfig_DetectionSensorConfig_TriggerType = 2
	// Event is triggered when pin goes low to high
	ModuleConfig_DetectionSensorConfig_RISING_EDGE ModuleConfig_DetectionSensorConfig_TriggerType = 3
	// Event is triggered on every pin state change, low is considered to be
	// "active"
	ModuleConfig_DetectionSensorConfig_EITHER_EDGE_ACTIVE_LOW ModuleConfig_DetectionSensorConfig_TriggerType = 4
	// Event is triggered on every pin state change, high is considered to be
	// "active"
	ModuleConfig_DetectionSensorConfig_EITHER_EDGE_ACTIVE_HIGH ModuleConfig_DetectionSensorConfig_TriggerType = 5
)

// Enum value maps for ModuleConfig_DetectionSensorConfig_TriggerType.
var (
	ModuleConfig_DetectionSensorConfig_TriggerType_name = map[int32]string{
		0: "LOGIC_LOW",
		1: "LOGIC_HIGH",
		2: "FALLING_EDGE",
		3: "RISING_EDGE",
		4: "EITHER_EDGE_ACTIVE_LOW",
		5: "EITHER_EDGE_ACTIVE_HIGH",
	}
	ModuleConfig_DetectionSensorConfig_TriggerType_value = map[string]int32{
		"LOGIC_LOW":               0,
		"LOGIC_HIGH":              1,
		"FALLING_EDGE":            2,
		"RISING_EDGE":             3,
		"EITHER_EDGE_ACTIVE_LOW":  4,
		"EITHER_EDGE_ACTIVE_HIGH": 5,
	}
)

func (x ModuleConfig_DetectionSensorConfig_TriggerType) Enum() *ModuleConfig_DetectionSensorConfig_TriggerType {
	p := new(ModuleConfig_DetectionSensorConfig_TriggerType)
	*p = x
	return p
}

func (x ModuleConfig_DetectionSensorConfig_TriggerType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ModuleConfig_DetectionSensorConfig_TriggerType) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_module_config_proto_enumTypes[1].Descriptor()
}

func (ModuleConfig_DetectionSensorConfig_TriggerType) Type() protoreflect.EnumType {
	return &file_meshtastic_module_config_proto_enumTypes[1]
}

func (x ModuleConfig_DetectionSensorConfig_TriggerType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ModuleConfig_DetectionSensorConfig_TriggerType.Descriptor instead.
func (ModuleConfig_DetectionSensorConfig_TriggerType) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_module_config_proto_rawDescGZIP(), []int{0, 4, 0}
}

// Baudrate for codec2 voice
type ModuleConfig_AudioConfig_Audio_Baud int32

const (
	ModuleConfig_AudioConfig_CODEC2_DEFAULT ModuleConfig_AudioConfig_Audio_Baud = 0
	ModuleConfig_AudioConfig_CODEC2_3200    ModuleConfig_AudioConfig_Audio_Baud = 1
	ModuleConfig_AudioConfig_CODEC2_2400    ModuleConfig_AudioConfig_Audio_Baud = 2
	ModuleConfig_AudioConfig_CODEC2_1600    ModuleConfig_AudioConfig_Audio_Baud = 3
	ModuleConfig_AudioConfig_CODEC2_1400    ModuleConfig_AudioConfig_Audio_Baud = 4
	ModuleConfig_AudioConfig_CODEC2_1300    ModuleConfig_AudioConfig_Audio_Baud = 5
	ModuleConfig_AudioConfig_CODEC2_1200    ModuleConfig_AudioConfig_Audio_Baud = 6
	ModuleConfig_AudioConfig_CODEC2_700     ModuleConfig_AudioConfig_Audio_Baud = 7
	ModuleConfig_AudioConfig_CODEC2_700B    ModuleConfig_AudioConfig_Audio_Baud = 8
)

// Enum value maps for ModuleConfig_AudioConfig_Audio_Baud.
var (
	ModuleConfig_AudioConfig_Audio_Baud_name = map[int32]string{
		0: "CODEC2_DEFAULT",
		1: "CODEC2_3200",
		2: "CODEC2_2400",
		3: "CODEC2_1600",
		4: "CODEC2_1400",
		5: "CODEC2_1300",
		6: "CODEC2_1200",
		7: "CODEC2_700",
		8: "CODEC2_700B",
	}
	ModuleConfig_AudioConfig_Audio_Baud_value = map[string]int32{
		"CODEC2_DEFAULT": 0,
		"CODEC2_3200":    1,
		"CODEC2_2400":    2,
		"CODEC2_1600":    3,
		"CODEC2_1400":    4,
		"CODEC2_1300":    5,
		"CODEC2_1200":    6,
		"CODEC2_700":     7,
		"CODEC2_700B":    8,
	}
)

func (x ModuleConfig_AudioConfig_Audio_Baud) Enum() *ModuleConfig_AudioConfig_Audio_Baud {
	p := new(ModuleConfig_AudioConfig_Audio_Baud)
	*p = x
	return p
}

func (x ModuleConfig_AudioConfig_Audio_Baud) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ModuleConfig_AudioConfig_Audio_Baud) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_module_config_proto_enumTypes[2].Descriptor()
}

func (ModuleConfig_AudioConfig_Audio_Baud) Type() protoreflect.EnumType {
	return &file_meshtastic_module_config_proto_enumTypes[2]
}

func (x ModuleConfig_AudioConfig_Audio_Baud) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ModuleConfig_AudioConfig_Audio_Baud.Descriptor instead.
func (ModuleConfig_AudioConfig_Audio_Baud) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_module_config_proto_rawDescGZIP(), []int{0, 5, 0}
}

// TODO: REPLACE
type ModuleConfig_SerialConfig_Serial_Baud int32

const (
	ModuleConfig_SerialConfig_BAUD_DEFAULT ModuleConfig_SerialConfig_Serial_Baud = 0
	ModuleConfig_SerialConfig_BAUD_110     ModuleConfig_SerialConfig_Serial_Baud = 1
	ModuleConfig_SerialConfig_BAUD_300     ModuleConfig_SerialConfig_Serial_Baud = 2
	ModuleConfig_SerialConfig_BAUD_600     ModuleConfig_SerialConfig_Serial_Baud = 3
	ModuleConfig_SerialConfig_BAUD_1200    ModuleConfig_SerialConfig_Serial_Baud = 4
	ModuleConfig_SerialConfig_BAUD_2400    ModuleConfig_SerialConfig_Serial_Baud = 5
	ModuleConfig_SerialConfig_BAUD_4800    ModuleConfig_SerialConfig_Serial_Baud = 6
	ModuleConfig_SerialConfig_BAUD_9600    ModuleConfig_SerialConfig_Serial_Baud = 7
	ModuleConfig_SerialConfig_BAUD_19200   ModuleConfig_SerialConfig_Serial_Baud = 8
	ModuleConfig_SerialConfig_BAUD_38400   ModuleConfig_SerialConfig_Serial_Baud = 9
	ModuleConfig_SerialConfig_BAUD_57600   ModuleConfig_SerialConfig_Serial_Baud = 10
	ModuleConfig_SerialConfig_BAUD_115200  ModuleConfig_SerialConfig_Serial_Baud = 11
	ModuleConfig_SerialConfig_BAUD_230400  ModuleConfig_SerialConfig_Serial_Baud = 12
	ModuleConfig_SerialConfig_BAUD_460800  ModuleConfig_SerialConfig_Serial_Baud = 13
	ModuleConfig_SerialConfig_BAUD_576000  ModuleConfig_SerialConfig_Serial_Baud = 14
	ModuleConfig_SerialConfig_BAUD_921600  ModuleConfig_SerialConfig_Serial_Baud = 15
)

// Enum value maps for ModuleConfig_SerialConfig_Serial_Baud.
var (
	ModuleConfig_SerialConfig_Serial_Baud_name = map[int32]string{
		0:  "BAUD_DEFAULT",
		1:  "BAUD_110",
		2:  "BAUD_300",
		3:  "BAUD_600",
		4:  "BAUD_1200",
		5:  "BAUD_2400",
		6:  "BAUD_4800",
		7:  "BAUD_9600",
		8:  "BAUD_19200",
		9:  "BAUD_38400",
		10: "BAUD_57600",
		11: "BAUD_115200",
		12: "BAUD_230400",
		13: "BAUD_460800",
		14: "BAUD_576000",
		15: "BAUD_921600",
	}
	ModuleConfig_SerialConfig_Serial_Baud_value = map[string]int32{
		"BAUD_DEFAULT": 0,
		"BAUD_110":     1,
		"BAUD_300":     2,
		"BAUD_600":     3,
		"BAUD_1200":    4,
		"BAUD_2400":    5,
		"BAUD_4800":    6,
		"BAUD_9600":    7,
		"BAUD_19200":   8,
		"BAUD_38400":   9,
		"BAUD_57600":   10,
		"BAUD_115200":  11,
		"BAUD_230400":  12,
		"BAUD_460800":  13,
		"BAUD_576000":  14,
		"BAUD_921600":  15,
	}
)

func (x ModuleConfig_SerialConfig_Serial_Baud) Enum() *ModuleConfig_SerialConfig_Serial_Baud {
	p := new(ModuleConfig_SerialConfig_Serial_Baud)
	*p = x
	return p
}

func (x ModuleConfig_SerialConfig_Serial_Baud) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ModuleConfig_SerialConfig_Serial_Baud) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_module_config_proto_enumTypes[3].Descriptor()
}

func (ModuleConfig_SerialConfig_Serial_Baud) Type() protoreflect.EnumType {
	return &file_meshtastic_module_config_proto_enumTypes[3]
}

func (x ModuleConfig_SerialConfig_Serial_Baud) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ModuleConfig_SerialConfig_Serial_Baud.Descriptor instead.
func (ModuleConfig_SerialConfig_Serial_Baud) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_module_config_proto_rawDescGZIP(), []int{0, 7, 0}
}

// TODO: REPLACE
type ModuleConfig_SerialConfig_Serial_Mode int32

const (
	ModuleConfig_SerialConfig_DEFAULT ModuleConfig_SerialConfig_Serial_Mode = 0
	ModuleConfig_SerialConfig_SIMPLE  ModuleConfig_SerialConfig_Serial_Mode = 1
	ModuleConfig_SerialConfig_PROTO   ModuleConfig_SerialConfig_Serial_Mode = 2
	ModuleConfig_SerialConfig_TEXTMSG ModuleConfig_SerialConfig_Serial_Mode = 3
	ModuleConfig_SerialConfig_NMEA    ModuleConfig_SerialConfig_Serial_Mode = 4
	// NMEA messages specifically tailored for CalTopo
	ModuleConfig_SerialConfig_CALTOPO ModuleConfig_SerialConfig_Serial_Mode = 5
	// Ecowitt WS85 weather station
	ModuleConfig_SerialConfig_WS85 ModuleConfig_SerialConfig_Serial_Mode = 6
	// VE.Direct is a serial protocol used by Victron Energy products
	// https://beta.ivc.no/wiki/index.php/Victron_VE_Direct_DIY_Cable
	ModuleConfig_SerialConfig_VE_DIRECT ModuleConfig_SerialConfig_Serial_Mode = 7
)

// Enum value maps for ModuleConfig_SerialConfig_Serial_Mode.
var (
	ModuleConfig_SerialConfig_Serial_Mode_name = map[int32]string{
		0: "DEFAULT",
		1: "SIMPLE",
		2: "PROTO",
		3: "TEXTMSG",
		4: "NMEA",
		5: "CALTOPO",
		6: "WS85",
		7: "VE_DIRECT",
	}
	ModuleConfig_SerialConfig_Serial_Mode_value = map[string]int32{
		"DEFAULT":   0,
		"SIMPLE":    1,
		"PROTO":     2,
		"TEXTMSG":   3,
		"NMEA":      4,
		"CALTOPO":   5,
		"WS85":      6,
		"VE_DIRECT": 7,
	}
)

func (x ModuleConfig_SerialConfig_Serial_Mode) Enum() *ModuleConfig_SerialConfig_Serial_Mode {
	p := new(ModuleConfig_SerialConfig_Serial_Mode)
	*p = x
	return p
}

func (x ModuleConfig_SerialConfig_Serial_Mode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ModuleConfig_SerialConfig_Serial_Mode) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_module_config_proto_enumTypes[4].Descriptor()
}

func (ModuleConfig_SerialConfig_Serial_Mode) Type() protoreflect.EnumType {
	return &file_meshtastic_module_config_proto_enumTypes[4]
}

func (x ModuleConfig_SerialConfig_Serial_Mode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ModuleConfig_SerialConfig_Serial_Mode.Descriptor instead.
func (ModuleConfig_SerialConfig_Serial_Mode) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_module_config_proto_rawDescGZIP(), []int{0, 7, 1}
}

// TODO: REPLACE
type ModuleConfig_CannedMessageConfig_InputEventChar int32

const (
	// TODO: REPLACE
	ModuleConfig_CannedMessageConfig_NONE ModuleConfig_CannedMessageConfig_InputEventChar = 0
	// TODO: REPLACE
	ModuleConfig_CannedMessageConfig_UP ModuleConfig_CannedMessageConfig_InputEventChar = 17
	// TODO: REPLACE
	ModuleConfig_CannedMessageConfig_DOWN ModuleConfig_CannedMessageConfig_InputEventChar = 18
	// TODO: REPLACE
	ModuleConfig_CannedMessageConfig_LEFT ModuleConfig_CannedMessageConfig_InputEventChar = 19
	// TODO: REPLACE
	ModuleConfig_CannedMessageConfig_RIGHT ModuleConfig_CannedMessageConfig_InputEventChar = 20
	// '\n'
	ModuleConfig_CannedMessageConfig_SELECT ModuleConfig_CannedMessageConfig_InputEventChar = 10
	// TODO: REPLACE
	ModuleConfig_CannedMessageConfig_BACK ModuleConfig_CannedMessageConfig_InputEventChar = 27
	// TODO: REPLACE
	ModuleConfig_CannedMessageConfig_CANCEL ModuleConfig_CannedMessageConfig_InputEventChar = 24
)

// Enum value maps for ModuleConfig_CannedMessageConfig_InputEventChar.
var (
	ModuleConfig_CannedMessageConfig_InputEventChar_name = map[int32]string{
		0:  "NONE",
		17: "UP",
		18: "DOWN",
		19: "LEFT",
		20: "RIGHT",
		10: "SELECT",
		27: "BACK",
		24: "CANCEL",
	}
	ModuleConfig_CannedMessageConfig_InputEventChar_value = map[string]int32{
		"NONE":   0,
		"UP":     17,
		"DOWN":   18,
		"LEFT":   19,
		"RIGHT":  20,
		"SELECT": 10,
		"BACK":   27,
		"CANCEL": 24,
	}
)

func (x ModuleConfig_CannedMessageConfig_InputEventChar) Enum() *ModuleConfig_CannedMessageConfig_InputEventChar {
	p := new(ModuleConfig_CannedMessageConfig_InputEventChar)
	*p = x
	return p
}

func (x ModuleConfig_CannedMessageConfig_InputEventChar) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ModuleConfig_CannedMessageConfig_InputEventChar) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_module_config_proto_enumTypes[5].Descriptor()
}

func (ModuleConfig_CannedMessageConfig_InputEventChar) Type() protoreflect.EnumType {
	return &file_meshtastic_module_config_proto_enumTypes[5]
}

func (x ModuleConfig_CannedMessageConfig_InputEventChar) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ModuleConfig_CannedMessageConfig_InputEventChar.Descriptor instead.
func (ModuleConfig_CannedMessageConfig_InputEventChar) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_module_config_proto_rawDescGZIP(), []int{0, 12, 0}
}

// Module Config
type ModuleConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// TODO: REPLACE
	//
	// Types that are valid to be assigned to PayloadVariant:
	//
	//	*ModuleConfig_Mqtt
	//	*ModuleConfig_Serial
	//	*ModuleConfig_ExternalNotification
	//	*ModuleConfig_StoreForward
	//	*ModuleConfig_RangeTest
	//	*ModuleConfig_Telemetry
	//	*ModuleConfig_CannedMessage
	//	*ModuleConfig_Audio
	//	*ModuleConfig_RemoteHardware
	//	*ModuleConfig_NeighborInfo
	//	*ModuleConfig_AmbientLighting
	//	*ModuleConfig_DetectionSensor
	//	*ModuleConfig_Paxcounter
	PayloadVariant isModuleConfig_PayloadVariant `protobuf_oneof:"payload_variant"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ModuleConfig) Reset() {
	*x = ModuleConfig{}
	mi := &file_meshtastic_module_config_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ModuleConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ModuleConfig) ProtoMessage() {}

func (x *ModuleConfig) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_module_config_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ModuleConfig.ProtoReflect.Descriptor instead.
func (*ModuleConfig) Descriptor() ([]byte, []int) {
	return file_meshtastic_module_config_proto_rawDescGZIP(), []int{0}
}

func (x *ModuleConfig) GetPayloadVariant() isModuleConfig_PayloadVariant {
	if x != nil {
		return x.PayloadVariant
	}
	return nil
}

func (x *ModuleConfig) GetMqtt() *ModuleConfig_MQTTConfig {
	if x != nil {
		if x, ok := x.PayloadVariant.(*ModuleConfig_Mqtt); ok {
			return x.Mqtt
		}
	}
	return nil
}

func (x *ModuleConfig) GetSerial() *ModuleConfig_SerialConfig {
	if x != nil {
		if x, ok := x.PayloadVariant.(*ModuleConfig_Serial); ok {
			return x.Serial
		}
	}
	return nil
}

func (x *ModuleConfig) GetExternalNotification() *ModuleConfig_ExternalNotificationConfig {
	if x != nil {
		if x, ok := x.PayloadVariant.(*ModuleConfig_ExternalNotification); ok {
			return x.ExternalNotification
		}
	}
	return nil
}

func (x *ModuleConfig) GetStoreForward() *ModuleConfig_StoreForwardConfig {
	if x != nil {
		if x, ok := x.PayloadVariant.(*ModuleConfig_StoreForward); ok {
			return x.StoreForward
		}
	}
	return nil
}

func (x *ModuleConfig) GetRangeTest() *ModuleConfig_RangeTestConfig {
	if x != nil {
		if x, ok := x.PayloadVariant.(*ModuleConfig_RangeTest); ok {
			return x.RangeTest
		}
	}
	return nil
}

func (x *ModuleConfig) GetTelemetry() *ModuleConfig_TelemetryConfig {
	if x != nil {
		if x, ok := x.PayloadVariant.(*ModuleConfig_Telemetry); ok {
			return x.Telemetry
		}
	}
	return nil
}

func (x *ModuleConfig) GetCannedMessage() *ModuleConfig_CannedMessageConfig {
	if x != nil {
		if x, ok := x.PayloadVariant.(*ModuleConfig_CannedMessage); ok {
			return x.CannedMessage
		}
	}
	return nil
}

func (x *ModuleConfig) GetAudio() *ModuleConfig_AudioConfig {
	if x != nil {
		if x, ok := x.PayloadVariant.(*ModuleConfig_Audio); ok {
			return x.Audio
		}
	}
	return nil
}

func (x *ModuleConfig) GetRemoteHardware() *ModuleConfig_RemoteHardwareConfig {
	if x != nil {
		if x, ok := x.PayloadVariant.(*ModuleConfig_RemoteHardware); ok {
			return x.RemoteHardware
		}
	}
	return nil
}

func (x *ModuleConfig) GetNeighborInfo() *ModuleConfig_NeighborInfoConfig {
	if x != nil {
		if x, ok := x.PayloadVariant.(*ModuleConfig_NeighborInfo); ok {
			return x.NeighborInfo
		}
	}
	return nil
}

func (x *ModuleConfig) GetAmbientLighting() *ModuleConfig_AmbientLightingConfig {
	if x != nil {
		if x, ok := x.PayloadVariant.(*ModuleConfig_AmbientLighting); ok {
			return x.AmbientLighting
		}
	}
	return nil
}

func (x *ModuleConfig) GetDetectionSensor() *ModuleConfig_DetectionSensorConfig {
	if x != nil {
		if x, ok := x.PayloadVariant.(*ModuleConfig_DetectionSensor); ok {
			return x.DetectionSensor
		}
	}
	return nil
}

func (x *ModuleConfig) GetPaxcounter() *ModuleConfig_PaxcounterConfig {
	if x != nil {
		if x, ok := x.PayloadVariant.(*ModuleConfig_Paxcounter); ok {
			return x.Paxcounter
		}
	}
	return nil
}

type isModuleConfig_PayloadVariant interface {
	isModuleConfig_PayloadVariant()
}

type ModuleConfig_Mqtt struct {
	// TODO: REPLACE
	Mqtt *ModuleConfig_MQTTConfig `protobuf:"bytes,1,opt,name=mqtt,proto3,oneof"`
}

type ModuleConfig_Serial struct {
	// TODO: REPLACE
	Serial *ModuleConfig_SerialConfig `protobuf:"bytes,2,opt,name=serial,proto3,oneof"`
}

type ModuleConfig_ExternalNotification struct {
	// TODO: REPLACE
	ExternalNotification *ModuleConfig_ExternalNotificationConfig `protobuf:"bytes,3,opt,name=external_notification,json=externalNotification,proto3,oneof"`
}

type ModuleConfig_StoreForward struct {
	// TODO: REPLACE
	StoreForward *ModuleConfig_StoreForwardConfig `protobuf:"bytes,4,opt,name=store_forward,json=storeForward,proto3,oneof"`
}

type ModuleConfig_RangeTest struct {
	// TODO: REPLACE
	RangeTest *ModuleConfig_RangeTestConfig `protobuf:"bytes,5,opt,name=range_test,json=rangeTest,proto3,oneof"`
}

type ModuleConfig_Telemetry struct {
	// TODO: REPLACE
	Telemetry *ModuleConfig_TelemetryConfig `protobuf:"bytes,6,opt,name=telemetry,proto3,oneof"`
}

type ModuleConfig_CannedMessage struct {
	// TODO: REPLACE
	CannedMessage *ModuleConfig_CannedMessageConfig `protobuf:"bytes,7,opt,name=canned_message,json=cannedMessage,proto3,oneof"`
}

type ModuleConfig_Audio struct {
	// TODO: REPLACE
	Audio *ModuleConfig_AudioConfig `protobuf:"bytes,8,opt,name=audio,proto3,oneof"`
}

type ModuleConfig_RemoteHardware struct {
	// TODO: REPLACE
	RemoteHardware *ModuleConfig_RemoteHardwareConfig `protobuf:"bytes,9,opt,name=remote_hardware,json=remoteHardware,proto3,oneof"`
}

type ModuleConfig_NeighborInfo struct {
	// TODO: REPLACE
	NeighborInfo *ModuleConfig_NeighborInfoConfig `protobuf:"bytes,10,opt,name=neighbor_info,json=neighborInfo,proto3,oneof"`
}

type ModuleConfig_AmbientLighting struct {
	// TODO: REPLACE
	AmbientLighting *ModuleConfig_AmbientLightingConfig `protobuf:"bytes,11,opt,name=ambient_lighting,json=ambientLighting,proto3,oneof"`
}

type ModuleConfig_DetectionSensor struct {
	// TODO: REPLACE
	DetectionSensor *ModuleConfig_DetectionSensorConfig `protobuf:"bytes,12,opt,name=detection_sensor,json=detectionSensor,proto3,oneof"`
}

type ModuleConfig_Paxcounter struct {
	// TODO: REPLACE
	Paxcounter *ModuleConfig_PaxcounterConfig `protobuf:"bytes,13,opt,name=paxcounter,proto3,oneof"`
}

func (*ModuleConfig_Mqtt) isModuleConfig_PayloadVariant() {}

func (*ModuleConfig_Serial) isModuleConfig_PayloadVariant() {}

func (*ModuleConfig_ExternalNotification) isModuleConfig_PayloadVariant() {}

func (*ModuleConfig_StoreForward) isModuleConfig_PayloadVariant() {}

func (*ModuleConfig_RangeTest) isModuleConfig_PayloadVariant() {}

func (*ModuleConfig_Telemetry) isModuleConfig_PayloadVariant() {}

func (*ModuleConfig_CannedMessage) isModuleConfig_PayloadVariant() {}

func (*ModuleConfig_Audio) isModuleConfig_PayloadVariant() {}

func (*ModuleConfig_RemoteHardware) isModuleConfig_PayloadVariant() {}

func (*ModuleConfig_NeighborInfo) isModuleConfig_PayloadVariant() {}

func (*ModuleConfig_AmbientLighting) isModuleConfig_PayloadVariant() {}

func (*ModuleConfig_DetectionSensor) isModuleConfig_PayloadVariant() {}

func (*ModuleConfig_Paxcounter) isModuleConfig_PayloadVariant() {}

// A GPIO pin definition for remote hardware module
type RemoteHardwarePin struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// GPIO Pin number (must match Arduino)
	GpioPin uint32 `protobuf:"varint,1,opt,name=gpio_pin,json=gpioPin,proto3" json:"gpio_pin,omitempty"`
	// Name for the GPIO pin (i.e. Front gate, mailbox, etc)
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Type of GPIO access available to consumers on the mesh
	Type          RemoteHardwarePinType `protobuf:"varint,3,opt,name=type,proto3,enum=meshtastic.RemoteHardwarePinType" json:"type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RemoteHardwarePin) Reset() {
	*x = RemoteHardwarePin{}
	mi := &file_meshtastic_module_config_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RemoteHardwarePin) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoteHardwarePin) ProtoMessage() {}

func (x *RemoteHardwarePin) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_module_config_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoteHardwarePin.ProtoReflect.Descriptor instead.
func (*RemoteHardwarePin) Descriptor() ([]byte, []int) {
	return file_meshtastic_module_config_proto_rawDescGZIP(), []int{1}
}

func (x *RemoteHardwarePin) GetGpioPin() uint32 {
	if x != nil {
		return x.GpioPin
	}
	return 0
}

func (x *RemoteHardwarePin) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *RemoteHardwarePin) GetType() RemoteHardwarePinType {
	if x != nil {
		return x.Type
	}
	return RemoteHardwarePinType_UNKNOWN
}

// MQTT Client Config
type ModuleConfig_MQTTConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If a meshtastic node is able to reach the internet it will normally attempt to gateway any channels that are marked as
	// is_uplink_enabled or is_downlink_enabled.
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// The server to use for our MQTT global message gateway feature.
	// If not set, the default server will be used
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	// MQTT username to use (most useful for a custom MQTT server).
	// If using a custom server, this will be honoured even if empty.
	// If using the default server, this will only be honoured if set, otherwise the device will use the default username
	Username string `protobuf:"bytes,3,opt,name=username,proto3" json:"username,omitempty"`
	// MQTT password to use (most useful for a custom MQTT server).
	// If using a custom server, this will be honoured even if empty.
	// If using the default server, this will only be honoured if set, otherwise the device will use the default password
	Password string `protobuf:"bytes,4,opt,name=password,proto3" json:"password,omitempty"`
	// Whether to send encrypted or decrypted packets to MQTT.
	// This parameter is only honoured if you also set server
	// (the default official mqtt.meshtastic.org server can handle encrypted packets)
	// Decrypted packets may be useful for external systems that want to consume meshtastic packets
	EncryptionEnabled bool `protobuf:"varint,5,opt,name=encryption_enabled,json=encryptionEnabled,proto3" json:"encryption_enabled,omitempty"`
	// Whether to send / consume json packets on MQTT
	JsonEnabled bool `protobuf:"varint,6,opt,name=json_enabled,json=jsonEnabled,proto3" json:"json_enabled,omitempty"`
	// If true, we attempt to establish a secure connection using TLS
	TlsEnabled bool `protobuf:"varint,7,opt,name=tls_enabled,json=tlsEnabled,proto3" json:"tls_enabled,omitempty"`
	// The root topic to use for MQTT messages. Default is "msh".
	// This is useful if you want to use a single MQTT server for multiple meshtastic networks and separate them via ACLs
	Root string `protobuf:"bytes,8,opt,name=root,proto3" json:"root,omitempty"`
	// If true, we can use the connected phone / client to proxy messages to MQTT instead of a direct connection
	ProxyToClientEnabled bool `protobuf:"varint,9,opt,name=proxy_to_client_enabled,json=proxyToClientEnabled,proto3" json:"proxy_to_client_enabled,omitempty"`
	// If true, we will periodically report unencrypted information about our node to a map via MQTT
	MapReportingEnabled bool `protobuf:"varint,10,opt,name=map_reporting_enabled,json=mapReportingEnabled,proto3" json:"map_reporting_enabled,omitempty"`
	// Settings for reporting information about our node to a map via MQTT
	MapReportSettings *ModuleConfig_MapReportSettings `protobuf:"bytes,11,opt,name=map_report_settings,json=mapReportSettings,proto3" json:"map_report_settings,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ModuleConfig_MQTTConfig) Reset() {
	*x = ModuleConfig_MQTTConfig{}
	mi := &file_meshtastic_module_config_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ModuleConfig_MQTTConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ModuleConfig_MQTTConfig) ProtoMessage() {}

func (x *ModuleConfig_MQTTConfig) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_module_config_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ModuleConfig_MQTTConfig.ProtoReflect.Descriptor instead.
func (*ModuleConfig_MQTTConfig) Descriptor() ([]byte, []int) {
	return file_meshtastic_module_config_proto_rawDescGZIP(), []int{0, 0}
}

func (x *ModuleConfig_MQTTConfig) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *ModuleConfig_MQTTConfig) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *ModuleConfig_MQTTConfig) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

func (x *ModuleConfig_MQTTConfig) GetPassword() string {
	if x != nil {
		return x.Password
	}
	return ""
}

func (x *ModuleConfig_MQTTConfig) GetEncryptionEnabled() bool {
	if x != nil {
		return x.EncryptionEnabled
	}
	return false
}

func (x *ModuleConfig_MQTTConfig) GetJsonEnabled() bool {
	if x != nil {
		return x.JsonEnabled
	}
	return false
}

func (x *ModuleConfig_MQTTConfig) GetTlsEnabled() bool {
	if x != nil {
		return x.TlsEnabled
	}
	return false
}

func (x *ModuleConfig_MQTTConfig) GetRoot() string {
	if x != nil {
		return x.Root
	}
	return ""
}

func (x *ModuleConfig_MQTTConfig) GetProxyToClientEnabled() bool {
	if x != nil {
		return x.ProxyToClientEnabled
	}
	return false
}

func (x *ModuleConfig_MQTTConfig) GetMapReportingEnabled() bool {
	if x != nil {
		return x.MapReportingEnabled
	}
	return false
}

func (x *ModuleConfig_MQTTConfig) GetMapReportSettings() *ModuleConfig_MapReportSettings {
	if x != nil {
		return x.MapReportSettings
	}
	return nil
}

// Settings for reporting unencrypted information about our node to a map via MQTT
type ModuleConfig_MapReportSettings struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// How often we should report our info to the map (in seconds)
	PublishIntervalSecs uint32 `protobuf:"varint,1,opt,name=publish_interval_secs,json=publishIntervalSecs,proto3" json:"publish_interval_secs,omitempty"`
	// Bits of precision for the location sent (default of 32 is full precision).
	PositionPrecision uint32 `protobuf:"varint,2,opt,name=position_precision,json=positionPrecision,proto3" json:"position_precision,omitempty"`
	// Whether we have opted-in to report our location to the map
	ShouldReportLocation bool `protobuf:"varint,3,opt,name=should_report_location,json=shouldReportLocation,proto3" json:"should_report_location,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *ModuleConfig_MapReportSettings) Reset() {
	*x = ModuleConfig_MapReportSettings{}
	mi := &file_meshtastic_module_config_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ModuleConfig_MapReportSettings) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ModuleConfig_MapReportSettings) ProtoMessage() {}

func (x *ModuleConfig_MapReportSettings) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_module_config_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ModuleConfig_MapReportSettings.ProtoReflect.Descriptor instead.
func (*ModuleConfig_MapReportSettings) Descriptor() ([]byte, []int) {
	return file_meshtastic_module_config_proto_rawDescGZIP(), []int{0, 1}
}

func (x *ModuleConfig_MapReportSettings) GetPublishIntervalSecs() uint32 {
	if x != nil {
		return x.PublishIntervalSecs
	}
	return 0
}

func (x *ModuleConfig_MapReportSettings) GetPositionPrecision() uint32 {
	if x != nil {
		return x.PositionPrecision
	}
	return 0
}

func (x *ModuleConfig_MapReportSettings) GetShouldReportLocation() bool {
	if x != nil {
		return x.ShouldReportLocation
	}
	return false
}

// RemoteHardwareModule Config
type ModuleConfig_RemoteHardwareConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether the Module is enabled
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Whether the Module allows consumers to read / write to pins not defined in available_pins
	AllowUndefinedPinAccess bool `protobuf:"varint,2,opt,name=allow_undefined_pin_access,json=allowUndefinedPinAccess,proto3" json:"allow_undefined_pin_access,omitempty"`
	// Exposes the available pins to the mesh for reading and writing
	AvailablePins []*RemoteHardwarePin `protobuf:"bytes,3,rep,name=available_pins,json=availablePins,proto3" json:"available_pins,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ModuleConfig_RemoteHardwareConfig) Reset() {
	*x = ModuleConfig_RemoteHardwareConfig{}
	mi := &file_meshtastic_module_config_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ModuleConfig_RemoteHardwareConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ModuleConfig_RemoteHardwareConfig) ProtoMessage() {}

func (x *ModuleConfig_RemoteHardwareConfig) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_module_config_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ModuleConfig_RemoteHardwareConfig.ProtoReflect.Descriptor instead.
func (*ModuleConfig_RemoteHardwareConfig) Descriptor() ([]byte, []int) {
	return file_meshtastic_module_config_proto_rawDescGZIP(), []int{0, 2}
}

func (x *ModuleConfig_RemoteHardwareConfig) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *ModuleConfig_RemoteHardwareConfig) GetAllowUndefinedPinAccess() bool {
	if x != nil {
		return x.AllowUndefinedPinAccess
	}
	return false
}

func (x *ModuleConfig_RemoteHardwareConfig) GetAvailablePins() []*RemoteHardwarePin {
	if x != nil {
		return x.AvailablePins
	}
	return nil
}

// NeighborInfoModule Config
type ModuleConfig_NeighborInfoConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether the Module is enabled
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Interval in seconds of how often we should try to send our
	// Neighbor Info (minimum is 14400, i.e., 4 hours)
	UpdateInterval uint32 `protobuf:"varint,2,opt,name=update_interval,json=updateInterval,proto3" json:"update_interval,omitempty"`
	// Whether in addition to sending it to MQTT and the PhoneAPI, our NeighborInfo should be transmitted over LoRa.
	// Note that this is not available on a channel with default key and name.
	TransmitOverLora bool `protobuf:"varint,3,opt,name=transmit_over_lora,json=transmitOverLora,proto3" json:"transmit_over_lora,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ModuleConfig_NeighborInfoConfig) Reset() {
	*x = ModuleConfig_NeighborInfoConfig{}
	mi := &file_meshtastic_module_config_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ModuleConfig_NeighborInfoConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ModuleConfig_NeighborInfoConfig) ProtoMessage() {}

func (x *ModuleConfig_NeighborInfoConfig) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_module_config_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ModuleConfig_NeighborInfoConfig.ProtoReflect.Descriptor instead.
func (*ModuleConfig_NeighborInfoConfig) Descriptor() ([]byte, []int) {
	return file_meshtastic_module_config_proto_rawDescGZIP(), []int{0, 3}
}

func (x *ModuleConfig_NeighborInfoConfig) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *ModuleConfig_NeighborInfoConfig) GetUpdateInterval() uint32 {
	if x != nil {
		return x.UpdateInterval
	}
	return 0
}

func (x *ModuleConfig_NeighborInfoConfig) GetTransmitOverLora() bool {
	if x != nil {
		return x.TransmitOverLora
	}
	return false
}

// Detection Sensor Module Config
type ModuleConfig_DetectionSensorConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether the Module is enabled
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Interval in seconds of how often we can send a message to the mesh when a
	// trigger event is detected
	MinimumBroadcastSecs uint32 `protobuf:"varint,2,opt,name=minimum_broadcast_secs,json=minimumBroadcastSecs,proto3" json:"minimum_broadcast_secs,omitempty"`
	// Interval in seconds of how often we should send a message to the mesh
	// with the current state regardless of trigger events When set to 0, only
	// trigger events will be broadcasted Works as a sort of status heartbeat
	// for peace of mind
	StateBroadcastSecs uint32 `protobuf:"varint,3,opt,name=state_broadcast_secs,json=stateBroadcastSecs,proto3" json:"state_broadcast_secs,omitempty"`
	// Send ASCII bell with alert message
	// Useful for triggering ext. notification on bell
	SendBell bool `protobuf:"varint,4,opt,name=send_bell,json=sendBell,proto3" json:"send_bell,omitempty"`
	// Friendly name used to format message sent to mesh
	// Example: A name "Motion" would result in a message "Motion detected"
	// Maximum length of 20 characters
	Name string `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	// GPIO pin to monitor for state changes
	MonitorPin uint32 `protobuf:"varint,6,opt,name=monitor_pin,json=monitorPin,proto3" json:"monitor_pin,omitempty"`
	// The type of trigger event to be used
	DetectionTriggerType ModuleConfig_DetectionSensorConfig_TriggerType `protobuf:"varint,7,opt,name=detection_trigger_type,json=detectionTriggerType,proto3,enum=meshtastic.ModuleConfig_DetectionSensorConfig_TriggerType" json:"detection_trigger_type,omitempty"`
	// Whether or not use INPUT_PULLUP mode for GPIO pin
	// Only applicable if the board uses pull-up resistors on the pin
	UsePullup     bool `protobuf:"varint,8,opt,name=use_pullup,json=usePullup,proto3" json:"use_pullup,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ModuleConfig_DetectionSensorConfig) Reset() {
	*x = ModuleConfig_DetectionSensorConfig{}
	mi := &file_meshtastic_module_config_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ModuleConfig_DetectionSensorConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ModuleConfig_DetectionSensorConfig) ProtoMessage() {}

func (x *ModuleConfig_DetectionSensorConfig) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_module_config_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ModuleConfig_DetectionSensorConfig.ProtoReflect.Descriptor instead.
func (*ModuleConfig_DetectionSensorConfig) Descriptor() ([]byte, []int) {
	return file_meshtastic_module_config_proto_rawDescGZIP(), []int{0, 4}
}

func (x *ModuleConfig_DetectionSensorConfig) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *ModuleConfig_DetectionSensorConfig) GetMinimumBroadcastSecs() uint32 {
	if x != nil {
		return x.MinimumBroadcastSecs
	}
	return 0
}

func (x *ModuleConfig_DetectionSensorConfig) GetStateBroadcastSecs() uint32 {
	if x != nil {
		return x.StateBroadcastSecs
	}
	return 0
}

func (x *ModuleConfig_DetectionSensorConfig) GetSendBell() bool {
	if x != nil {
		return x.SendBell
	}
	return false
}

func (x *ModuleConfig_DetectionSensorConfig) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ModuleConfig_DetectionSensorConfig) GetMonitorPin() uint32 {
	if x != nil {
		return x.MonitorPin
	}
	return 0
}

func (x *ModuleConfig_DetectionSensorConfig) GetDetectionTriggerType() ModuleConfig_DetectionSensorConfig_TriggerType {
	if x != nil {
		return x.DetectionTriggerType
	}
	return ModuleConfig_DetectionSensorConfig_LOGIC_LOW
}

func (x *ModuleConfig_DetectionSensorConfig) GetUsePullup() bool {
	if x != nil {
		return x.UsePullup
	}
	return false
}

// Audio Config for codec2 voice
type ModuleConfig_AudioConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether Audio is enabled
	Codec2Enabled bool `protobuf:"varint,1,opt,name=codec2_enabled,json=codec2Enabled,proto3" json:"codec2_enabled,omitempty"`
	// PTT Pin
	PttPin uint32 `protobuf:"varint,2,opt,name=ptt_pin,json=pttPin,proto3" json:"ptt_pin,omitempty"`
	// The audio sample rate to use for codec2
	Bitrate ModuleConfig_AudioConfig_Audio_Baud `protobuf:"varint,3,opt,name=bitrate,proto3,enum=meshtastic.ModuleConfig_AudioConfig_Audio_Baud" json:"bitrate,omitempty"`
	// I2S Word Select
	I2SWs uint32 `protobuf:"varint,4,opt,name=i2s_ws,json=i2sWs,proto3" json:"i2s_ws,omitempty"`
	// I2S Data IN
	I2SSd uint32 `protobuf:"varint,5,opt,name=i2s_sd,json=i2sSd,proto3" json:"i2s_sd,omitempty"`
	// I2S Data OUT
	I2SDin uint32 `protobuf:"varint,6,opt,name=i2s_din,json=i2sDin,proto3" json:"i2s_din,omitempty"`
	// I2S Clock
	I2SSck        uint32 `protobuf:"varint,7,opt,name=i2s_sck,json=i2sSck,proto3" json:"i2s_sck,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ModuleConfig_AudioConfig) Reset() {
	*x = ModuleConfig_AudioConfig{}
	mi := &file_meshtastic_module_config_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ModuleConfig_AudioConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ModuleConfig_AudioConfig) ProtoMessage() {}

func (x *ModuleConfig_AudioConfig) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_module_config_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ModuleConfig_AudioConfig.ProtoReflect.Descriptor instead.
func (*ModuleConfig_AudioConfig) Descriptor() ([]byte, []int) {
	return file_meshtastic_module_config_proto_rawDescGZIP(), []int{0, 5}
}

func (x *ModuleConfig_AudioConfig) GetCodec2Enabled() bool {
	if x != nil {
		return x.Codec2Enabled
	}
	return false
}

func (x *ModuleConfig_AudioConfig) GetPttPin() uint32 {
	if x != nil {
		return x.PttPin
	}
	return 0
}

func (x *ModuleConfig_AudioConfig) GetBitrate() ModuleConfig_AudioConfig_Audio_Baud {
	if x != nil {
		return x.Bitrate
	}
	return ModuleConfig_AudioConfig_CODEC2_DEFAULT
}

func (x *ModuleConfig_AudioConfig) GetI2SWs() uint32 {
	if x != nil {
		return x.I2SWs
	}
	return 0
}

func (x *ModuleConfig_AudioConfig) GetI2SSd() uint32 {
	if x != nil {
		return x.I2SSd
	}
	return 0
}

func (x *ModuleConfig_AudioConfig) GetI2SDin() uint32 {
	if x != nil {
		return x.I2SDin
	}
	return 0
}

func (x *ModuleConfig_AudioConfig) GetI2SSck() uint32 {
	if x != nil {
		return x.I2SSck
	}
	return 0
}

// Config for the Paxcounter Module
type ModuleConfig_PaxcounterConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Enable the Paxcounter Module
	Enabled                  bool   `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	PaxcounterUpdateInterval uint32 `protobuf:"varint,2,opt,name=paxcounter_update_interval,json=paxcounterUpdateInterval,proto3" json:"paxcounter_update_interval,omitempty"`
	// WiFi RSSI threshold. Defaults to -80
	WifiThreshold int32 `protobuf:"varint,3,opt,name=wifi_threshold,json=wifiThreshold,proto3" json:"wifi_threshold,omitempty"`
	// BLE RSSI threshold. Defaults to -80
	BleThreshold  int32 `protobuf:"varint,4,opt,name=ble_threshold,json=bleThreshold,proto3" json:"ble_threshold,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ModuleConfig_PaxcounterConfig) Reset() {
	*x = ModuleConfig_PaxcounterConfig{}
	mi := &file_meshtastic_module_config_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ModuleConfig_PaxcounterConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ModuleConfig_PaxcounterConfig) ProtoMessage() {}

func (x *ModuleConfig_PaxcounterConfig) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_module_config_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ModuleConfig_PaxcounterConfig.ProtoReflect.Descriptor instead.
func (*ModuleConfig_PaxcounterConfig) Descriptor() ([]byte, []int) {
	return file_meshtastic_module_config_proto_rawDescGZIP(), []int{0, 6}
}

func (x *ModuleConfig_PaxcounterConfig) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *ModuleConfig_PaxcounterConfig) GetPaxcounterUpdateInterval() uint32 {
	if x != nil {
		return x.PaxcounterUpdateInterval
	}
	return 0
}

func (x *ModuleConfig_PaxcounterConfig) GetWifiThreshold() int32 {
	if x != nil {
		return x.WifiThreshold
	}
	return 0
}

func (x *ModuleConfig_PaxcounterConfig) GetBleThreshold() int32 {
	if x != nil {
		return x.BleThreshold
	}
	return 0
}

// Serial Config
type ModuleConfig_SerialConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Preferences for the SerialModule
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// TODO: REPLACE
	Echo bool `protobuf:"varint,2,opt,name=echo,proto3" json:"echo,omitempty"`
	// RX pin (should match Arduino gpio pin number)
	Rxd uint32 `protobuf:"varint,3,opt,name=rxd,proto3" json:"rxd,omitempty"`
	// TX pin (should match Arduino gpio pin number)
	Txd uint32 `protobuf:"varint,4,opt,name=txd,proto3" json:"txd,omitempty"`
	// Serial baud rate
	Baud ModuleConfig_SerialConfig_Serial_Baud `protobuf:"varint,5,opt,name=baud,proto3,enum=meshtastic.ModuleConfig_SerialConfig_Serial_Baud" json:"baud,omitempty"`
	// TODO: REPLACE
	Timeout uint32 `protobuf:"varint,6,opt,name=timeout,proto3" json:"timeout,omitempty"`
	// Mode for serial module operation
	Mode ModuleConfig_SerialConfig_Serial_Mode `protobuf:"varint,7,opt,name=mode,proto3,enum=meshtastic.ModuleConfig_SerialConfig_Serial_Mode" json:"mode,omitempty"`
	// Overrides the platform's defacto Serial port instance to use with Serial module config settings
	// This is currently only usable in output modes like NMEA / CalTopo and may behave strangely or not work at all in other modes
	// Existing logging over the Serial Console will still be present
	OverrideConsoleSerialPort bool `protobuf:"varint,8,opt,name=override_console_serial_port,json=overrideConsoleSerialPort,proto3" json:"override_console_serial_port,omitempty"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *ModuleConfig_SerialConfig) Reset() {
	*x = ModuleConfig_SerialConfig{}
	mi := &file_meshtastic_module_config_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ModuleConfig_SerialConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ModuleConfig_SerialConfig) ProtoMessage() {}

func (x *ModuleConfig_SerialConfig) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_module_config_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ModuleConfig_SerialConfig.ProtoReflect.Descriptor instead.
func (*ModuleConfig_SerialConfig) Descriptor() ([]byte, []int) {
	return file_meshtastic_module_config_proto_rawDescGZIP(), []int{0, 7}
}

func (x *ModuleConfig_SerialConfig) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *ModuleConfig_SerialConfig) GetEcho() bool {
	if x != nil {
		return x.Echo
	}
	return false
}

func (x *ModuleConfig_SerialConfig) GetRxd() uint32 {
	if x != nil {
		return x.Rxd
	}
	return 0
}

func (x *ModuleConfig_SerialConfig) GetTxd() uint32 {
	if x != nil {
		return x.Txd
	}
	return 0
}

func (x *ModuleConfig_SerialConfig) GetBaud() ModuleConfig_SerialConfig_Serial_Baud {
	if x != nil {
		return x.Baud
	}
	return ModuleConfig_SerialConfig_BAUD_DEFAULT
}

func (x *ModuleConfig_SerialConfig) GetTimeout() uint32 {
	if x != nil {
		return x.Timeout
	}
	return 0
}

func (x *ModuleConfig_SerialConfig) GetMode() ModuleConfig_SerialConfig_Serial_Mode {
	if x != nil {
		return x.Mode
	}
	return ModuleConfig_SerialConfig_DEFAULT
}

func (x *ModuleConfig_SerialConfig) GetOverrideConsoleSerialPort() bool {
	if x != nil {
		return x.OverrideConsoleSerialPort
	}
	return false
}

// External Notifications Config
type ModuleConfig_ExternalNotificationConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Enable the ExternalNotificationModule
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// When using in On/Off mode, keep the output on for this many
	// milliseconds. Default 1000ms (1 second).
	OutputMs uint32 `protobuf:"varint,2,opt,name=output_ms,json=outputMs,proto3" json:"output_ms,omitempty"`
	// Define the output pin GPIO setting Defaults to
	// EXT_NOTIFY_OUT if set for the board.
	// In standalone devices this pin should drive the LED to match the UI.
	Output uint32 `protobuf:"varint,3,opt,name=output,proto3" json:"output,omitempty"`
	// Optional: Define a secondary output pin for a vibra motor
	// This is used in standalone devices to match the UI.
	OutputVibra uint32 `protobuf:"varint,8,opt,name=output_vibra,json=outputVibra,proto3" json:"output_vibra,omitempty"`
	// Optional: Define a tertiary output pin for an active buzzer
	// This is used in standalone devices to to match the UI.
	OutputBuzzer uint32 `protobuf:"varint,9,opt,name=output_buzzer,json=outputBuzzer,proto3" json:"output_buzzer,omitempty"`
	// IF this is true, the 'output' Pin will be pulled active high, false
	// means active low.
	Active bool `protobuf:"varint,4,opt,name=active,proto3" json:"active,omitempty"`
	// True: Alert when a text message arrives (output)
	AlertMessage bool `protobuf:"varint,5,opt,name=alert_message,json=alertMessage,proto3" json:"alert_message,omitempty"`
	// True: Alert when a text message arrives (output_vibra)
	AlertMessageVibra bool `protobuf:"varint,10,opt,name=alert_message_vibra,json=alertMessageVibra,proto3" json:"alert_message_vibra,omitempty"`
	// True: Alert when a text message arrives (output_buzzer)
	AlertMessageBuzzer bool `protobuf:"varint,11,opt,name=alert_message_buzzer,json=alertMessageBuzzer,proto3" json:"alert_message_buzzer,omitempty"`
	// True: Alert when the bell character is received (output)
	AlertBell bool `protobuf:"varint,6,opt,name=alert_bell,json=alertBell,proto3" json:"alert_bell,omitempty"`
	// True: Alert when the bell character is received (output_vibra)
	AlertBellVibra bool `protobuf:"varint,12,opt,name=alert_bell_vibra,json=alertBellVibra,proto3" json:"alert_bell_vibra,omitempty"`
	// True: Alert when the bell character is received (output_buzzer)
	AlertBellBuzzer bool `protobuf:"varint,13,opt,name=alert_bell_buzzer,json=alertBellBuzzer,proto3" json:"alert_bell_buzzer,omitempty"`
	// use a PWM output instead of a simple on/off output. This will ignore
	// the 'output', 'output_ms' and 'active' settings and use the
	// device.buzzer_gpio instead.
	UsePwm bool `protobuf:"varint,7,opt,name=use_pwm,json=usePwm,proto3" json:"use_pwm,omitempty"`
	// The notification will toggle with 'output_ms' for this time of seconds.
	// Default is 0 which means don't repeat at all. 60 would mean blink
	// and/or beep for 60 seconds
	NagTimeout uint32 `protobuf:"varint,14,opt,name=nag_timeout,json=nagTimeout,proto3" json:"nag_timeout,omitempty"`
	// When true, enables devices with native I2S audio output to use the RTTTL over speaker like a buzzer
	// T-Watch S3 and T-Deck for example have this capability
	UseI2SAsBuzzer bool `protobuf:"varint,15,opt,name=use_i2s_as_buzzer,json=useI2sAsBuzzer,proto3" json:"use_i2s_as_buzzer,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ModuleConfig_ExternalNotificationConfig) Reset() {
	*x = ModuleConfig_ExternalNotificationConfig{}
	mi := &file_meshtastic_module_config_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ModuleConfig_ExternalNotificationConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ModuleConfig_ExternalNotificationConfig) ProtoMessage() {}

func (x *ModuleConfig_ExternalNotificationConfig) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_module_config_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ModuleConfig_ExternalNotificationConfig.ProtoReflect.Descriptor instead.
func (*ModuleConfig_ExternalNotificationConfig) Descriptor() ([]byte, []int) {
	return file_meshtastic_module_config_proto_rawDescGZIP(), []int{0, 8}
}

func (x *ModuleConfig_ExternalNotificationConfig) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *ModuleConfig_ExternalNotificationConfig) GetOutputMs() uint32 {
	if x != nil {
		return x.OutputMs
	}
	return 0
}

func (x *ModuleConfig_ExternalNotificationConfig) GetOutput() uint32 {
	if x != nil {
		return x.Output
	}
	return 0
}

func (x *ModuleConfig_ExternalNotificationConfig) GetOutputVibra() uint32 {
	if x != nil {
		return x.OutputVibra
	}
	return 0
}

func (x *ModuleConfig_ExternalNotificationConfig) GetOutputBuzzer() uint32 {
	if x != nil {
		return x.OutputBuzzer
	}
	return 0
}

func (x *ModuleConfig_ExternalNotificationConfig) GetActive() bool {
	if x != nil {
		return x.Active
	}
	return false
}

func (x *ModuleConfig_ExternalNotificationConfig) GetAlertMessage() bool {
	if x != nil {
		return x.AlertMessage
	}
	return false
}

func (x *ModuleConfig_ExternalNotificationConfig) GetAlertMessageVibra() bool {
	if x != nil {
		return x.AlertMessageVibra
	}
	return false
}

func (x *ModuleConfig_ExternalNotificationConfig) GetAlertMessageBuzzer() bool {
	if x != nil {
		return x.AlertMessageBuzzer
	}
	return false
}

func (x *ModuleConfig_ExternalNotificationConfig) GetAlertBell() bool {
	if x != nil {
		return x.AlertBell
	}
	return false
}

func (x *ModuleConfig_ExternalNotificationConfig) GetAlertBellVibra() bool {
	if x != nil {
		return x.AlertBellVibra
	}
	return false
}

func (x *ModuleConfig_ExternalNotificationConfig) GetAlertBellBuzzer() bool {
	if x != nil {
		return x.AlertBellBuzzer
	}
	return false
}

func (x *ModuleConfig_ExternalNotificationConfig) GetUsePwm() bool {
	if x != nil {
		return x.UsePwm
	}
	return false
}

func (x *ModuleConfig_ExternalNotificationConfig) GetNagTimeout() uint32 {
	if x != nil {
		return x.NagTimeout
	}
	return 0
}

func (x *ModuleConfig_ExternalNotificationConfig) GetUseI2SAsBuzzer() bool {
	if x != nil {
		return x.UseI2SAsBuzzer
	}
	return false
}

// Store and Forward Module Config
type ModuleConfig_StoreForwardConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Enable the Store and Forward Module
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// TODO: REPLACE
	Heartbeat bool `protobuf:"varint,2,opt,name=heartbeat,proto3" json:"heartbeat,omitempty"`
	// TODO: REPLACE
	Records uint32 `protobuf:"varint,3,opt,name=records,proto3" json:"records,omitempty"`
	// TODO: REPLACE
	HistoryReturnMax uint32 `protobuf:"varint,4,opt,name=history_return_max,json=historyReturnMax,proto3" json:"history_return_max,omitempty"`
	// TODO: REPLACE
	HistoryReturnWindow uint32 `protobuf:"varint,5,opt,name=history_return_window,json=historyReturnWindow,proto3" json:"history_return_window,omitempty"`
	// Set to true to let this node act as a server that stores received messages and resends them upon request.
	IsServer      bool `protobuf:"varint,6,opt,name=is_server,json=isServer,proto3" json:"is_server,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ModuleConfig_StoreForwardConfig) Reset() {
	*x = ModuleConfig_StoreForwardConfig{}
	mi := &file_meshtastic_module_config_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ModuleConfig_StoreForwardConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ModuleConfig_StoreForwardConfig) ProtoMessage() {}

func (x *ModuleConfig_StoreForwardConfig) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_module_config_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ModuleConfig_StoreForwardConfig.ProtoReflect.Descriptor instead.
func (*ModuleConfig_StoreForwardConfig) Descriptor() ([]byte, []int) {
	return file_meshtastic_module_config_proto_rawDescGZIP(), []int{0, 9}
}

func (x *ModuleConfig_StoreForwardConfig) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *ModuleConfig_StoreForwardConfig) GetHeartbeat() bool {
	if x != nil {
		return x.Heartbeat
	}
	return false
}

func (x *ModuleConfig_StoreForwardConfig) GetRecords() uint32 {
	if x != nil {
		return x.Records
	}
	return 0
}

func (x *ModuleConfig_StoreForwardConfig) GetHistoryReturnMax() uint32 {
	if x != nil {
		return x.HistoryReturnMax
	}
	return 0
}

func (x *ModuleConfig_StoreForwardConfig) GetHistoryReturnWindow() uint32 {
	if x != nil {
		return x.HistoryReturnWindow
	}
	return 0
}

func (x *ModuleConfig_StoreForwardConfig) GetIsServer() bool {
	if x != nil {
		return x.IsServer
	}
	return false
}

// Preferences for the RangeTestModule
type ModuleConfig_RangeTestConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Enable the Range Test Module
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Send out range test messages from this node
	Sender uint32 `protobuf:"varint,2,opt,name=sender,proto3" json:"sender,omitempty"`
	// Bool value indicating that this node should save a RangeTest.csv file.
	// ESP32 Only
	Save          bool `protobuf:"varint,3,opt,name=save,proto3" json:"save,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ModuleConfig_RangeTestConfig) Reset() {
	*x = ModuleConfig_RangeTestConfig{}
	mi := &file_meshtastic_module_config_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ModuleConfig_RangeTestConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ModuleConfig_RangeTestConfig) ProtoMessage() {}

func (x *ModuleConfig_RangeTestConfig) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_module_config_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ModuleConfig_RangeTestConfig.ProtoReflect.Descriptor instead.
func (*ModuleConfig_RangeTestConfig) Descriptor() ([]byte, []int) {
	return file_meshtastic_module_config_proto_rawDescGZIP(), []int{0, 10}
}

func (x *ModuleConfig_RangeTestConfig) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *ModuleConfig_RangeTestConfig) GetSender() uint32 {
	if x != nil {
		return x.Sender
	}
	return 0
}

func (x *ModuleConfig_RangeTestConfig) GetSave() bool {
	if x != nil {
		return x.Save
	}
	return false
}

// Configuration for both device and environment metrics
type ModuleConfig_TelemetryConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Interval in seconds of how often we should try to send our
	// device metrics to the mesh
	DeviceUpdateInterval      uint32 `protobuf:"varint,1,opt,name=device_update_interval,json=deviceUpdateInterval,proto3" json:"device_update_interval,omitempty"`
	EnvironmentUpdateInterval uint32 `protobuf:"varint,2,opt,name=environment_update_interval,json=environmentUpdateInterval,proto3" json:"environment_update_interval,omitempty"`
	// Preferences for the Telemetry Module (Environment)
	// Enable/Disable the telemetry measurement module measurement collection
	EnvironmentMeasurementEnabled bool `protobuf:"varint,3,opt,name=environment_measurement_enabled,json=environmentMeasurementEnabled,proto3" json:"environment_measurement_enabled,omitempty"`
	// Enable/Disable the telemetry measurement module on-device display
	EnvironmentScreenEnabled bool `protobuf:"varint,4,opt,name=environment_screen_enabled,json=environmentScreenEnabled,proto3" json:"environment_screen_enabled,omitempty"`
	// We'll always read the sensor in Celsius, but sometimes we might want to
	// display the results in Fahrenheit as a "user preference".
	EnvironmentDisplayFahrenheit bool `protobuf:"varint,5,opt,name=environment_display_fahrenheit,json=environmentDisplayFahrenheit,proto3" json:"environment_display_fahrenheit,omitempty"`
	// Enable/Disable the air quality metrics
	AirQualityEnabled bool `protobuf:"varint,6,opt,name=air_quality_enabled,json=airQualityEnabled,proto3" json:"air_quality_enabled,omitempty"`
	// Interval in seconds of how often we should try to send our
	// air quality metrics to the mesh
	AirQualityInterval uint32 `protobuf:"varint,7,opt,name=air_quality_interval,json=airQualityInterval,proto3" json:"air_quality_interval,omitempty"`
	// Enable/disable Power metrics
	PowerMeasurementEnabled bool `protobuf:"varint,8,opt,name=power_measurement_enabled,json=powerMeasurementEnabled,proto3" json:"power_measurement_enabled,omitempty"`
	// Interval in seconds of how often we should try to send our
	// power metrics to the mesh
	PowerUpdateInterval uint32 `protobuf:"varint,9,opt,name=power_update_interval,json=powerUpdateInterval,proto3" json:"power_update_interval,omitempty"`
	// Enable/Disable the power measurement module on-device display
	PowerScreenEnabled bool `protobuf:"varint,10,opt,name=power_screen_enabled,json=powerScreenEnabled,proto3" json:"power_screen_enabled,omitempty"`
	// Preferences for the (Health) Telemetry Module
	// Enable/Disable the telemetry measurement module measurement collection
	HealthMeasurementEnabled bool `protobuf:"varint,11,opt,name=health_measurement_enabled,json=healthMeasurementEnabled,proto3" json:"health_measurement_enabled,omitempty"`
	// Interval in seconds of how often we should try to send our
	// health metrics to the mesh
	HealthUpdateInterval uint32 `protobuf:"varint,12,opt,name=health_update_interval,json=healthUpdateInterval,proto3" json:"health_update_interval,omitempty"`
	// Enable/Disable the health telemetry module on-device display
	HealthScreenEnabled bool `protobuf:"varint,13,opt,name=health_screen_enabled,json=healthScreenEnabled,proto3" json:"health_screen_enabled,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *ModuleConfig_TelemetryConfig) Reset() {
	*x = ModuleConfig_TelemetryConfig{}
	mi := &file_meshtastic_module_config_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ModuleConfig_TelemetryConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ModuleConfig_TelemetryConfig) ProtoMessage() {}

func (x *ModuleConfig_TelemetryConfig) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_module_config_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ModuleConfig_TelemetryConfig.ProtoReflect.Descriptor instead.
func (*ModuleConfig_TelemetryConfig) Descriptor() ([]byte, []int) {
	return file_meshtastic_module_config_proto_rawDescGZIP(), []int{0, 11}
}

func (x *ModuleConfig_TelemetryConfig) GetDeviceUpdateInterval() uint32 {
	if x != nil {
		return x.DeviceUpdateInterval
	}
	return 0
}

func (x *ModuleConfig_TelemetryConfig) GetEnvironmentUpdateInterval() uint32 {
	if x != nil {
		return x.EnvironmentUpdateInterval
	}
	return 0
}

func (x *ModuleConfig_TelemetryConfig) GetEnvironmentMeasurementEnabled() bool {
	if x != nil {
		return x.EnvironmentMeasurementEnabled
	}
	return false
}

func (x *ModuleConfig_TelemetryConfig) GetEnvironmentScreenEnabled() bool {
	if x != nil {
		return x.EnvironmentScreenEnabled
	}
	return false
}

func (x *ModuleConfig_TelemetryConfig) GetEnvironmentDisplayFahrenheit() bool {
	if x != nil {
		return x.EnvironmentDisplayFahrenheit
	}
	return false
}

func (x *ModuleConfig_TelemetryConfig) GetAirQualityEnabled() bool {
	if x != nil {
		return x.AirQualityEnabled
	}
	return false
}

func (x *ModuleConfig_TelemetryConfig) GetAirQualityInterval() uint32 {
	if x != nil {
		return x.AirQualityInterval
	}
	return 0
}

func (x *ModuleConfig_TelemetryConfig) GetPowerMeasurementEnabled() bool {
	if x != nil {
		return x.PowerMeasurementEnabled
	}
	return false
}

func (x *ModuleConfig_TelemetryConfig) GetPowerUpdateInterval() uint32 {
	if x != nil {
		return x.PowerUpdateInterval
	}
	return 0
}

func (x *ModuleConfig_TelemetryConfig) GetPowerScreenEnabled() bool {
	if x != nil {
		return x.PowerScreenEnabled
	}
	return false
}

func (x *ModuleConfig_TelemetryConfig) GetHealthMeasurementEnabled() bool {
	if x != nil {
		return x.HealthMeasurementEnabled
	}
	return false
}

func (x *ModuleConfig_TelemetryConfig) GetHealthUpdateInterval() uint32 {
	if x != nil {
		return x.HealthUpdateInterval
	}
	return 0
}

func (x *ModuleConfig_TelemetryConfig) GetHealthScreenEnabled() bool {
	if x != nil {
		return x.HealthScreenEnabled
	}
	return false
}

// Canned Messages Module Config
type ModuleConfig_CannedMessageConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Enable the rotary encoder #1. This is a 'dumb' encoder sending pulses on both A and B pins while rotating.
	Rotary1Enabled bool `protobuf:"varint,1,opt,name=rotary1_enabled,json=rotary1Enabled,proto3" json:"rotary1_enabled,omitempty"`
	// GPIO pin for rotary encoder A port.
	InputbrokerPinA uint32 `protobuf:"varint,2,opt,name=inputbroker_pin_a,json=inputbrokerPinA,proto3" json:"inputbroker_pin_a,omitempty"`
	// GPIO pin for rotary encoder B port.
	InputbrokerPinB uint32 `protobuf:"varint,3,opt,name=inputbroker_pin_b,json=inputbrokerPinB,proto3" json:"inputbroker_pin_b,omitempty"`
	// GPIO pin for rotary encoder Press port.
	InputbrokerPinPress uint32 `protobuf:"varint,4,opt,name=inputbroker_pin_press,json=inputbrokerPinPress,proto3" json:"inputbroker_pin_press,omitempty"`
	// Generate input event on CW of this kind.
	InputbrokerEventCw ModuleConfig_CannedMessageConfig_InputEventChar `protobuf:"varint,5,opt,name=inputbroker_event_cw,json=inputbrokerEventCw,proto3,enum=meshtastic.ModuleConfig_CannedMessageConfig_InputEventChar" json:"inputbroker_event_cw,omitempty"`
	// Generate input event on CCW of this kind.
	InputbrokerEventCcw ModuleConfig_CannedMessageConfig_InputEventChar `protobuf:"varint,6,opt,name=inputbroker_event_ccw,json=inputbrokerEventCcw,proto3,enum=meshtastic.ModuleConfig_CannedMessageConfig_InputEventChar" json:"inputbroker_event_ccw,omitempty"`
	// Generate input event on Press of this kind.
	InputbrokerEventPress ModuleConfig_CannedMessageConfig_InputEventChar `protobuf:"varint,7,opt,name=inputbroker_event_press,json=inputbrokerEventPress,proto3,enum=meshtastic.ModuleConfig_CannedMessageConfig_InputEventChar" json:"inputbroker_event_press,omitempty"`
	// Enable the Up/Down/Select input device. Can be RAK rotary encoder or 3 buttons. Uses the a/b/press definitions from inputbroker.
	Updown1Enabled bool `protobuf:"varint,8,opt,name=updown1_enabled,json=updown1Enabled,proto3" json:"updown1_enabled,omitempty"`
	// Enable/disable CannedMessageModule.
	Enabled bool `protobuf:"varint,9,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Input event origin accepted by the canned message module.
	// Can be e.g. "rotEnc1", "upDownEnc1", "scanAndSelect", "cardkb", "serialkb", or keyword "_any"
	AllowInputSource string `protobuf:"bytes,10,opt,name=allow_input_source,json=allowInputSource,proto3" json:"allow_input_source,omitempty"`
	// CannedMessageModule also sends a bell character with the messages.
	// ExternalNotificationModule can benefit from this feature.
	SendBell      bool `protobuf:"varint,11,opt,name=send_bell,json=sendBell,proto3" json:"send_bell,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ModuleConfig_CannedMessageConfig) Reset() {
	*x = ModuleConfig_CannedMessageConfig{}
	mi := &file_meshtastic_module_config_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ModuleConfig_CannedMessageConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ModuleConfig_CannedMessageConfig) ProtoMessage() {}

func (x *ModuleConfig_CannedMessageConfig) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_module_config_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ModuleConfig_CannedMessageConfig.ProtoReflect.Descriptor instead.
func (*ModuleConfig_CannedMessageConfig) Descriptor() ([]byte, []int) {
	return file_meshtastic_module_config_proto_rawDescGZIP(), []int{0, 12}
}

func (x *ModuleConfig_CannedMessageConfig) GetRotary1Enabled() bool {
	if x != nil {
		return x.Rotary1Enabled
	}
	return false
}

func (x *ModuleConfig_CannedMessageConfig) GetInputbrokerPinA() uint32 {
	if x != nil {
		return x.InputbrokerPinA
	}
	return 0
}

func (x *ModuleConfig_CannedMessageConfig) GetInputbrokerPinB() uint32 {
	if x != nil {
		return x.InputbrokerPinB
	}
	return 0
}

func (x *ModuleConfig_CannedMessageConfig) GetInputbrokerPinPress() uint32 {
	if x != nil {
		return x.InputbrokerPinPress
	}
	return 0
}

func (x *ModuleConfig_CannedMessageConfig) GetInputbrokerEventCw() ModuleConfig_CannedMessageConfig_InputEventChar {
	if x != nil {
		return x.InputbrokerEventCw
	}
	return ModuleConfig_CannedMessageConfig_NONE
}

func (x *ModuleConfig_CannedMessageConfig) GetInputbrokerEventCcw() ModuleConfig_CannedMessageConfig_InputEventChar {
	if x != nil {
		return x.InputbrokerEventCcw
	}
	return ModuleConfig_CannedMessageConfig_NONE
}

func (x *ModuleConfig_CannedMessageConfig) GetInputbrokerEventPress() ModuleConfig_CannedMessageConfig_InputEventChar {
	if x != nil {
		return x.InputbrokerEventPress
	}
	return ModuleConfig_CannedMessageConfig_NONE
}

func (x *ModuleConfig_CannedMessageConfig) GetUpdown1Enabled() bool {
	if x != nil {
		return x.Updown1Enabled
	}
	return false
}

func (x *ModuleConfig_CannedMessageConfig) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *ModuleConfig_CannedMessageConfig) GetAllowInputSource() string {
	if x != nil {
		return x.AllowInputSource
	}
	return ""
}

func (x *ModuleConfig_CannedMessageConfig) GetSendBell() bool {
	if x != nil {
		return x.SendBell
	}
	return false
}

// Ambient Lighting Module - Settings for control of onboard LEDs to allow users to adjust the brightness levels and respective color levels.
// Initially created for the RAK14001 RGB LED module.
type ModuleConfig_AmbientLightingConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Sets LED to on or off.
	LedState bool `protobuf:"varint,1,opt,name=led_state,json=ledState,proto3" json:"led_state,omitempty"`
	// Sets the current for the LED output. Default is 10.
	Current uint32 `protobuf:"varint,2,opt,name=current,proto3" json:"current,omitempty"`
	// Sets the red LED level. Values are 0-255.
	Red uint32 `protobuf:"varint,3,opt,name=red,proto3" json:"red,omitempty"`
	// Sets the green LED level. Values are 0-255.
	Green uint32 `protobuf:"varint,4,opt,name=green,proto3" json:"green,omitempty"`
	// Sets the blue LED level. Values are 0-255.
	Blue          uint32 `protobuf:"varint,5,opt,name=blue,proto3" json:"blue,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ModuleConfig_AmbientLightingConfig) Reset() {
	*x = ModuleConfig_AmbientLightingConfig{}
	mi := &file_meshtastic_module_config_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ModuleConfig_AmbientLightingConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ModuleConfig_AmbientLightingConfig) ProtoMessage() {}

func (x *ModuleConfig_AmbientLightingConfig) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_module_config_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ModuleConfig_AmbientLightingConfig.ProtoReflect.Descriptor instead.
func (*ModuleConfig_AmbientLightingConfig) Descriptor() ([]byte, []int) {
	return file_meshtastic_module_config_proto_rawDescGZIP(), []int{0, 13}
}

func (x *ModuleConfig_AmbientLightingConfig) GetLedState() bool {
	if x != nil {
		return x.LedState
	}
	return false
}

func (x *ModuleConfig_AmbientLightingConfig) GetCurrent() uint32 {
	if x != nil {
		return x.Current
	}
	return 0
}

func (x *ModuleConfig_AmbientLightingConfig) GetRed() uint32 {
	if x != nil {
		return x.Red
	}
	return 0
}

func (x *ModuleConfig_AmbientLightingConfig) GetGreen() uint32 {
	if x != nil {
		return x.Green
	}
	return 0
}

func (x *ModuleConfig_AmbientLightingConfig) GetBlue() uint32 {
	if x != nil {
		return x.Blue
	}
	return 0
}

var File_meshtastic_module_config_proto protoreflect.FileDescriptor

const file_meshtastic_module_config_proto_rawDesc = "" +
	"\n" +
	"\x1emeshtastic/module_config.proto\x12\n" +
	"meshtastic\"\xb72\n" +
	"\fModuleConfig\x129\n" +
	"\x04mqtt\x18\x01 \x01(\v2#.meshtastic.ModuleConfig.MQTTConfigH\x00R\x04mqtt\x12?\n" +
	"\x06serial\x18\x02 \x01(\v2%.meshtastic.ModuleConfig.SerialConfigH\x00R\x06serial\x12j\n" +
	"\x15external_notification\x18\x03 \x01(\v23.meshtastic.ModuleConfig.ExternalNotificationConfigH\x00R\x14externalNotification\x12R\n" +
	"\rstore_forward\x18\x04 \x01(\v2+.meshtastic.ModuleConfig.StoreForwardConfigH\x00R\fstoreForward\x12I\n" +
	"\n" +
	"range_test\x18\x05 \x01(\v2(.meshtastic.ModuleConfig.RangeTestConfigH\x00R\trangeTest\x12H\n" +
	"\ttelemetry\x18\x06 \x01(\v2(.meshtastic.ModuleConfig.TelemetryConfigH\x00R\ttelemetry\x12U\n" +
	"\x0ecanned_message\x18\a \x01(\v2,.meshtastic.ModuleConfig.CannedMessageConfigH\x00R\rcannedMessage\x12<\n" +
	"\x05audio\x18\b \x01(\v2$.meshtastic.ModuleConfig.AudioConfigH\x00R\x05audio\x12X\n" +
	"\x0fremote_hardware\x18\t \x01(\v2-.meshtastic.ModuleConfig.RemoteHardwareConfigH\x00R\x0eremoteHardware\x12R\n" +
	"\rneighbor_info\x18\n" +
	" \x01(\v2+.meshtastic.ModuleConfig.NeighborInfoConfigH\x00R\fneighborInfo\x12[\n" +
	"\x10ambient_lighting\x18\v \x01(\v2..meshtastic.ModuleConfig.AmbientLightingConfigH\x00R\x0fambientLighting\x12[\n" +
	"\x10detection_sensor\x18\f \x01(\v2..meshtastic.ModuleConfig.DetectionSensorConfigH\x00R\x0fdetectionSensor\x12K\n" +
	"\n" +
	"paxcounter\x18\r \x01(\v2).meshtastic.ModuleConfig.PaxcounterConfigH\x00R\n" +
	"paxcounter\x1a\xc6\x03\n" +
	"\n" +
	"MQTTConfig\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12\x18\n" +
	"\aaddress\x18\x02 \x01(\tR\aaddress\x12\x1a\n" +
	"\busername\x18\x03 \x01(\tR\busername\x12\x1a\n" +
	"\bpassword\x18\x04 \x01(\tR\bpassword\x12-\n" +
	"\x12encryption_enabled\x18\x05 \x01(\bR\x11encryptionEnabled\x12!\n" +
	"\fjson_enabled\x18\x06 \x01(\bR\vjsonEnabled\x12\x1f\n" +
	"\vtls_enabled\x18\a \x01(\bR\n" +
	"tlsEnabled\x12\x12\n" +
	"\x04root\x18\b \x01(\tR\x04root\x125\n" +
	"\x17proxy_to_client_enabled\x18\t \x01(\bR\x14proxyToClientEnabled\x122\n" +
	"\x15map_reporting_enabled\x18\n" +
	" \x01(\bR\x13mapReportingEnabled\x12Z\n" +
	"\x13map_report_settings\x18\v \x01(\v2*.meshtastic.ModuleConfig.MapReportSettingsR\x11mapReportSettings\x1a\xac\x01\n" +
	"\x11MapReportSettings\x122\n" +
	"\x15publish_interval_secs\x18\x01 \x01(\rR\x13publishIntervalSecs\x12-\n" +
	"\x12position_precision\x18\x02 \x01(\rR\x11positionPrecision\x124\n" +
	"\x16should_report_location\x18\x03 \x01(\bR\x14shouldReportLocation\x1a\xb3\x01\n" +
	"\x14RemoteHardwareConfig\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12;\n" +
	"\x1aallow_undefined_pin_access\x18\x02 \x01(\bR\x17allowUndefinedPinAccess\x12D\n" +
	"\x0eavailable_pins\x18\x03 \x03(\v2\x1d.meshtastic.RemoteHardwarePinR\ravailablePins\x1a\x85\x01\n" +
	"\x12NeighborInfoConfig\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12'\n" +
	"\x0fupdate_interval\x18\x02 \x01(\rR\x0eupdateInterval\x12,\n" +
	"\x12transmit_over_lora\x18\x03 \x01(\bR\x10transmitOverLora\x1a\x87\x04\n" +
	"\x15DetectionSensorConfig\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x124\n" +
	"\x16minimum_broadcast_secs\x18\x02 \x01(\rR\x14minimumBroadcastSecs\x120\n" +
	"\x14state_broadcast_secs\x18\x03 \x01(\rR\x12stateBroadcastSecs\x12\x1b\n" +
	"\tsend_bell\x18\x04 \x01(\bR\bsendBell\x12\x12\n" +
	"\x04name\x18\x05 \x01(\tR\x04name\x12\x1f\n" +
	"\vmonitor_pin\x18\x06 \x01(\rR\n" +
	"monitorPin\x12p\n" +
	"\x16detection_trigger_type\x18\a \x01(\x0e2:.meshtastic.ModuleConfig.DetectionSensorConfig.TriggerTypeR\x14detectionTriggerType\x12\x1d\n" +
	"\n" +
	"use_pullup\x18\b \x01(\bR\tusePullup\"\x88\x01\n" +
	"\vTriggerType\x12\r\n" +
	"\tLOGIC_LOW\x10\x00\x12\x0e\n" +
	"\n" +
	"LOGIC_HIGH\x10\x01\x12\x10\n" +
	"\fFALLING_EDGE\x10\x02\x12\x0f\n" +
	"\vRISING_EDGE\x10\x03\x12\x1a\n" +
	"\x16EITHER_EDGE_ACTIVE_LOW\x10\x04\x12\x1b\n" +
	"\x17EITHER_EDGE_ACTIVE_HIGH\x10\x05\x1a\xa2\x03\n" +
	"\vAudioConfig\x12%\n" +
	"\x0ecodec2_enabled\x18\x01 \x01(\bR\rcodec2Enabled\x12\x17\n" +
	"\aptt_pin\x18\x02 \x01(\rR\x06pttPin\x12I\n" +
	"\abitrate\x18\x03 \x01(\x0e2/.meshtastic.ModuleConfig.AudioConfig.Audio_BaudR\abitrate\x12\x15\n" +
	"\x06i2s_ws\x18\x04 \x01(\rR\x05i2sWs\x12\x15\n" +
	"\x06i2s_sd\x18\x05 \x01(\rR\x05i2sSd\x12\x17\n" +
	"\ai2s_din\x18\x06 \x01(\rR\x06i2sDin\x12\x17\n" +
	"\ai2s_sck\x18\a \x01(\rR\x06i2sSck\"\xa7\x01\n" +
	"\n" +
	"Audio_Baud\x12\x12\n" +
	"\x0eCODEC2_DEFAULT\x10\x00\x12\x0f\n" +
	"\vCODEC2_3200\x10\x01\x12\x0f\n" +
	"\vCODEC2_2400\x10\x02\x12\x0f\n" +
	"\vCODEC2_1600\x10\x03\x12\x0f\n" +
	"\vCODEC2_1400\x10\x04\x12\x0f\n" +
	"\vCODEC2_1300\x10\x05\x12\x0f\n" +
	"\vCODEC2_1200\x10\x06\x12\x0e\n" +
	"\n" +
	"CODEC2_700\x10\a\x12\x0f\n" +
	"\vCODEC2_700B\x10\b\x1a\xb6\x01\n" +
	"\x10PaxcounterConfig\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12<\n" +
	"\x1apaxcounter_update_interval\x18\x02 \x01(\rR\x18paxcounterUpdateInterval\x12%\n" +
	"\x0ewifi_threshold\x18\x03 \x01(\x05R\rwifiThreshold\x12#\n" +
	"\rble_threshold\x18\x04 \x01(\x05R\fbleThreshold\x1a\xc6\x05\n" +
	"\fSerialConfig\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12\x12\n" +
	"\x04echo\x18\x02 \x01(\bR\x04echo\x12\x10\n" +
	"\x03rxd\x18\x03 \x01(\rR\x03rxd\x12\x10\n" +
	"\x03txd\x18\x04 \x01(\rR\x03txd\x12E\n" +
	"\x04baud\x18\x05 \x01(\x0e21.meshtastic.ModuleConfig.SerialConfig.Serial_BaudR\x04baud\x12\x18\n" +
	"\atimeout\x18\x06 \x01(\rR\atimeout\x12E\n" +
	"\x04mode\x18\a \x01(\x0e21.meshtastic.ModuleConfig.SerialConfig.Serial_ModeR\x04mode\x12?\n" +
	"\x1coverride_console_serial_port\x18\b \x01(\bR\x19overrideConsoleSerialPort\"\x8a\x02\n" +
	"\vSerial_Baud\x12\x10\n" +
	"\fBAUD_DEFAULT\x10\x00\x12\f\n" +
	"\bBAUD_110\x10\x01\x12\f\n" +
	"\bBAUD_300\x10\x02\x12\f\n" +
	"\bBAUD_600\x10\x03\x12\r\n" +
	"\tBAUD_1200\x10\x04\x12\r\n" +
	"\tBAUD_2400\x10\x05\x12\r\n" +
	"\tBAUD_4800\x10\x06\x12\r\n" +
	"\tBAUD_9600\x10\a\x12\x0e\n" +
	"\n" +
	"BAUD_19200\x10\b\x12\x0e\n" +
	"\n" +
	"BAUD_38400\x10\t\x12\x0e\n" +
	"\n" +
	"BAUD_57600\x10\n" +
	"\x12\x0f\n" +
	"\vBAUD_115200\x10\v\x12\x0f\n" +
	"\vBAUD_230400\x10\f\x12\x0f\n" +
	"\vBAUD_460800\x10\r\x12\x0f\n" +
	"\vBAUD_576000\x10\x0e\x12\x0f\n" +
	"\vBAUD_921600\x10\x0f\"n\n" +
	"\vSerial_Mode\x12\v\n" +
	"\aDEFAULT\x10\x00\x12\n" +
	"\n" +
	"\x06SIMPLE\x10\x01\x12\t\n" +
	"\x05PROTO\x10\x02\x12\v\n" +
	"\aTEXTMSG\x10\x03\x12\b\n" +
	"\x04NMEA\x10\x04\x12\v\n" +
	"\aCALTOPO\x10\x05\x12\b\n" +
	"\x04WS85\x10\x06\x12\r\n" +
	"\tVE_DIRECT\x10\a\x1a\xac\x04\n" +
	"\x1aExternalNotificationConfig\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12\x1b\n" +
	"\toutput_ms\x18\x02 \x01(\rR\boutputMs\x12\x16\n" +
	"\x06output\x18\x03 \x01(\rR\x06output\x12!\n" +
	"\foutput_vibra\x18\b \x01(\rR\voutputVibra\x12#\n" +
	"\routput_buzzer\x18\t \x01(\rR\foutputBuzzer\x12\x16\n" +
	"\x06active\x18\x04 \x01(\bR\x06active\x12#\n" +
	"\ralert_message\x18\x05 \x01(\bR\falertMessage\x12.\n" +
	"\x13alert_message_vibra\x18\n" +
	" \x01(\bR\x11alertMessageVibra\x120\n" +
	"\x14alert_message_buzzer\x18\v \x01(\bR\x12alertMessageBuzzer\x12\x1d\n" +
	"\n" +
	"alert_bell\x18\x06 \x01(\bR\talertBell\x12(\n" +
	"\x10alert_bell_vibra\x18\f \x01(\bR\x0ealertBellVibra\x12*\n" +
	"\x11alert_bell_buzzer\x18\r \x01(\bR\x0falertBellBuzzer\x12\x17\n" +
	"\ause_pwm\x18\a \x01(\bR\x06usePwm\x12\x1f\n" +
	"\vnag_timeout\x18\x0e \x01(\rR\n" +
	"nagTimeout\x12)\n" +
	"\x11use_i2s_as_buzzer\x18\x0f \x01(\bR\x0euseI2sAsBuzzer\x1a\xe5\x01\n" +
	"\x12StoreForwardConfig\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12\x1c\n" +
	"\theartbeat\x18\x02 \x01(\bR\theartbeat\x12\x18\n" +
	"\arecords\x18\x03 \x01(\rR\arecords\x12,\n" +
	"\x12history_return_max\x18\x04 \x01(\rR\x10historyReturnMax\x122\n" +
	"\x15history_return_window\x18\x05 \x01(\rR\x13historyReturnWindow\x12\x1b\n" +
	"\tis_server\x18\x06 \x01(\bR\bisServer\x1aW\n" +
	"\x0fRangeTestConfig\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12\x16\n" +
	"\x06sender\x18\x02 \x01(\rR\x06sender\x12\x12\n" +
	"\x04save\x18\x03 \x01(\bR\x04save\x1a\xff\x05\n" +
	"\x0fTelemetryConfig\x124\n" +
	"\x16device_update_interval\x18\x01 \x01(\rR\x14deviceUpdateInterval\x12>\n" +
	"\x1benvironment_update_interval\x18\x02 \x01(\rR\x19environmentUpdateInterval\x12F\n" +
	"\x1fenvironment_measurement_enabled\x18\x03 \x01(\bR\x1denvironmentMeasurementEnabled\x12<\n" +
	"\x1aenvironment_screen_enabled\x18\x04 \x01(\bR\x18environmentScreenEnabled\x12D\n" +
	"\x1eenvironment_display_fahrenheit\x18\x05 \x01(\bR\x1cenvironmentDisplayFahrenheit\x12.\n" +
	"\x13air_quality_enabled\x18\x06 \x01(\bR\x11airQualityEnabled\x120\n" +
	"\x14air_quality_interval\x18\a \x01(\rR\x12airQualityInterval\x12:\n" +
	"\x19power_measurement_enabled\x18\b \x01(\bR\x17powerMeasurementEnabled\x122\n" +
	"\x15power_update_interval\x18\t \x01(\rR\x13powerUpdateInterval\x120\n" +
	"\x14power_screen_enabled\x18\n" +
	" \x01(\bR\x12powerScreenEnabled\x12<\n" +
	"\x1ahealth_measurement_enabled\x18\v \x01(\bR\x18healthMeasurementEnabled\x124\n" +
	"\x16health_update_interval\x18\f \x01(\rR\x14healthUpdateInterval\x122\n" +
	"\x15health_screen_enabled\x18\r \x01(\bR\x13healthScreenEnabled\x1a\x92\x06\n" +
	"\x13CannedMessageConfig\x12'\n" +
	"\x0frotary1_enabled\x18\x01 \x01(\bR\x0erotary1Enabled\x12*\n" +
	"\x11inputbroker_pin_a\x18\x02 \x01(\rR\x0finputbrokerPinA\x12*\n" +
	"\x11inputbroker_pin_b\x18\x03 \x01(\rR\x0finputbrokerPinB\x122\n" +
	"\x15inputbroker_pin_press\x18\x04 \x01(\rR\x13inputbrokerPinPress\x12m\n" +
	"\x14inputbroker_event_cw\x18\x05 \x01(\x0e2;.meshtastic.ModuleConfig.CannedMessageConfig.InputEventCharR\x12inputbrokerEventCw\x12o\n" +
	"\x15inputbroker_event_ccw\x18\x06 \x01(\x0e2;.meshtastic.ModuleConfig.CannedMessageConfig.InputEventCharR\x13inputbrokerEventCcw\x12s\n" +
	"\x17inputbroker_event_press\x18\a \x01(\x0e2;.meshtastic.ModuleConfig.CannedMessageConfig.InputEventCharR\x15inputbrokerEventPress\x12'\n" +
	"\x0fupdown1_enabled\x18\b \x01(\bR\x0eupdown1Enabled\x12\x18\n" +
	"\aenabled\x18\t \x01(\bR\aenabled\x12,\n" +
	"\x12allow_input_source\x18\n" +
	" \x01(\tR\x10allowInputSource\x12\x1b\n" +
	"\tsend_bell\x18\v \x01(\bR\bsendBell\"c\n" +
	"\x0eInputEventChar\x12\b\n" +
	"\x04NONE\x10\x00\x12\x06\n" +
	"\x02UP\x10\x11\x12\b\n" +
	"\x04DOWN\x10\x12\x12\b\n" +
	"\x04LEFT\x10\x13\x12\t\n" +
	"\x05RIGHT\x10\x14\x12\n" +
	"\n" +
	"\x06SELECT\x10\n" +
	"\x12\b\n" +
	"\x04BACK\x10\x1b\x12\n" +
	"\n" +
	"\x06CANCEL\x10\x18\x1a\x8a\x01\n" +
	"\x15AmbientLightingConfig\x12\x1b\n" +
	"\tled_state\x18\x01 \x01(\bR\bledState\x12\x18\n" +
	"\acurrent\x18\x02 \x01(\rR\acurrent\x12\x10\n" +
	"\x03red\x18\x03 \x01(\rR\x03red\x12\x14\n" +
	"\x05green\x18\x04 \x01(\rR\x05green\x12\x12\n" +
	"\x04blue\x18\x05 \x01(\rR\x04blueB\x11\n" +
	"\x0fpayload_variant\"y\n" +
	"\x11RemoteHardwarePin\x12\x19\n" +
	"\bgpio_pin\x18\x01 \x01(\rR\agpioPin\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x125\n" +
	"\x04type\x18\x03 \x01(\x0e2!.meshtastic.RemoteHardwarePinTypeR\x04type*I\n" +
	"\x15RemoteHardwarePinType\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\x10\n" +
	"\fDIGITAL_READ\x10\x01\x12\x11\n" +
	"\rDIGITAL_WRITE\x10\x02Bg\n" +
	"\x13com.geeksville.meshB\x12ModuleConfigProtosZ\"github.com/meshtastic/go/generated\xaa\x02\x14Meshtastic.Protobufs\xba\x02\x00b\x06proto3"

var (
	file_meshtastic_module_config_proto_rawDescOnce sync.Once
	file_meshtastic_module_config_proto_rawDescData []byte
)

func file_meshtastic_module_config_proto_rawDescGZIP() []byte {
	file_meshtastic_module_config_proto_rawDescOnce.Do(func() {
		file_meshtastic_module_config_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_meshtastic_module_config_proto_rawDesc), len(file_meshtastic_module_config_proto_rawDesc)))
	})
	return file_meshtastic_module_config_proto_rawDescData
}

var file_meshtastic_module_config_proto_enumTypes = make([]protoimpl.EnumInfo, 6)
var file_meshtastic_module_config_proto_msgTypes = make([]protoimpl.MessageInfo, 16)
var file_meshtastic_module_config_proto_goTypes = []any{
	(RemoteHardwarePinType)(0),                           // 0: meshtastic.RemoteHardwarePinType
	(ModuleConfig_DetectionSensorConfig_TriggerType)(0),  // 1: meshtastic.ModuleConfig.DetectionSensorConfig.TriggerType
	(ModuleConfig_AudioConfig_Audio_Baud)(0),             // 2: meshtastic.ModuleConfig.AudioConfig.Audio_Baud
	(ModuleConfig_SerialConfig_Serial_Baud)(0),           // 3: meshtastic.ModuleConfig.SerialConfig.Serial_Baud
	(ModuleConfig_SerialConfig_Serial_Mode)(0),           // 4: meshtastic.ModuleConfig.SerialConfig.Serial_Mode
	(ModuleConfig_CannedMessageConfig_InputEventChar)(0), // 5: meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar
	(*ModuleConfig)(nil),                                 // 6: meshtastic.ModuleConfig
	(*RemoteHardwarePin)(nil),                            // 7: meshtastic.RemoteHardwarePin
	(*ModuleConfig_MQTTConfig)(nil),                      // 8: meshtastic.ModuleConfig.MQTTConfig
	(*ModuleConfig_MapReportSettings)(nil),               // 9: meshtastic.ModuleConfig.MapReportSettings
	(*ModuleConfig_RemoteHardwareConfig)(nil),            // 10: meshtastic.ModuleConfig.RemoteHardwareConfig
	(*ModuleConfig_NeighborInfoConfig)(nil),              // 11: meshtastic.ModuleConfig.NeighborInfoConfig
	(*ModuleConfig_DetectionSensorConfig)(nil),           // 12: meshtastic.ModuleConfig.DetectionSensorConfig
	(*ModuleConfig_AudioConfig)(nil),                     // 13: meshtastic.ModuleConfig.AudioConfig
	(*ModuleConfig_PaxcounterConfig)(nil),                // 14: meshtastic.ModuleConfig.PaxcounterConfig
	(*ModuleConfig_SerialConfig)(nil),                    // 15: meshtastic.ModuleConfig.SerialConfig
	(*ModuleConfig_ExternalNotificationConfig)(nil),      // 16: meshtastic.ModuleConfig.ExternalNotificationConfig
	(*ModuleConfig_StoreForwardConfig)(nil),              // 17: meshtastic.ModuleConfig.StoreForwardConfig
	(*ModuleConfig_RangeTestConfig)(nil),                 // 18: meshtastic.ModuleConfig.RangeTestConfig
	(*ModuleConfig_TelemetryConfig)(nil),                 // 19: meshtastic.ModuleConfig.TelemetryConfig
	(*ModuleConfig_CannedMessageConfig)(nil),             // 20: meshtastic.ModuleConfig.CannedMessageConfig
	(*ModuleConfig_AmbientLightingConfig)(nil),           // 21: meshtastic.ModuleConfig.AmbientLightingConfig
}
var file_meshtastic_module_config_proto_depIdxs = []int32{
	8,  // 0: meshtastic.ModuleConfig.mqtt:type_name -> meshtastic.ModuleConfig.MQTTConfig
	15, // 1: meshtastic.ModuleConfig.serial:type_name -> meshtastic.ModuleConfig.SerialConfig
	16, // 2: meshtastic.ModuleConfig.external_notification:type_name -> meshtastic.ModuleConfig.ExternalNotificationConfig
	17, // 3: meshtastic.ModuleConfig.store_forward:type_name -> meshtastic.ModuleConfig.StoreForwardConfig
	18, // 4: meshtastic.ModuleConfig.range_test:type_name -> meshtastic.ModuleConfig.RangeTestConfig
	19, // 5: meshtastic.ModuleConfig.telemetry:type_name -> meshtastic.ModuleConfig.TelemetryConfig
	20, // 6: meshtastic.ModuleConfig.canned_message:type_name -> meshtastic.ModuleConfig.CannedMessageConfig
	13, // 7: meshtastic.ModuleConfig.audio:type_name -> meshtastic.ModuleConfig.AudioConfig
	10, // 8: meshtastic.ModuleConfig.remote_hardware:type_name -> meshtastic.ModuleConfig.RemoteHardwareConfig
	11, // 9: meshtastic.ModuleConfig.neighbor_info:type_name -> meshtastic.ModuleConfig.NeighborInfoConfig
	21, // 10: meshtastic.ModuleConfig.ambient_lighting:type_name -> meshtastic.ModuleConfig.AmbientLightingConfig
	12, // 11: meshtastic.ModuleConfig.detection_sensor:type_name -> meshtastic.ModuleConfig.DetectionSensorConfig
	14, // 12: meshtastic.ModuleConfig.paxcounter:type_name -> meshtastic.ModuleConfig.PaxcounterConfig
	0,  // 13: meshtastic.RemoteHardwarePin.type:type_name -> meshtastic.RemoteHardwarePinType
	9,  // 14: meshtastic.ModuleConfig.MQTTConfig.map_report_settings:type_name -> meshtastic.ModuleConfig.MapReportSettings
	7,  // 15: meshtastic.ModuleConfig.RemoteHardwareConfig.available_pins:type_name -> meshtastic.RemoteHardwarePin
	1,  // 16: meshtastic.ModuleConfig.DetectionSensorConfig.detection_trigger_type:type_name -> meshtastic.ModuleConfig.DetectionSensorConfig.TriggerType
	2,  // 17: meshtastic.ModuleConfig.AudioConfig.bitrate:type_name -> meshtastic.ModuleConfig.AudioConfig.Audio_Baud
	3,  // 18: meshtastic.ModuleConfig.SerialConfig.baud:type_name -> meshtastic.ModuleConfig.SerialConfig.Serial_Baud
	4,  // 19: meshtastic.ModuleConfig.SerialConfig.mode:type_name -> meshtastic.ModuleConfig.SerialConfig.Serial_Mode
	5,  // 20: meshtastic.ModuleConfig.CannedMessageConfig.inputbroker_event_cw:type_name -> meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar
	5,  // 21: meshtastic.ModuleConfig.CannedMessageConfig.inputbroker_event_ccw:type_name -> meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar
	5,  // 22: meshtastic.ModuleConfig.CannedMessageConfig.inputbroker_event_press:type_name -> meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar
	23, // [23:23] is the sub-list for method output_type
	23, // [23:23] is the sub-list for method input_type
	23, // [23:23] is the sub-list for extension type_name
	23, // [23:23] is the sub-list for extension extendee
	0,  // [0:23] is the sub-list for field type_name
}

func init() { file_meshtastic_module_config_proto_init() }
func file_meshtastic_module_config_proto_init() {
	if File_meshtastic_module_config_proto != nil {
		return
	}
	file_meshtastic_module_config_proto_msgTypes[0].OneofWrappers = []any{
		(*ModuleConfig_Mqtt)(nil),
		(*ModuleConfig_Serial)(nil),
		(*ModuleConfig_ExternalNotification)(nil),
		(*ModuleConfig_StoreForward)(nil),
		(*ModuleConfig_RangeTest)(nil),
		(*ModuleConfig_Telemetry)(nil),
		(*ModuleConfig_CannedMessage)(nil),
		(*ModuleConfig_Audio)(nil),
		(*ModuleConfig_RemoteHardware)(nil),
		(*ModuleConfig_NeighborInfo)(nil),
		(*ModuleConfig_AmbientLighting)(nil),
		(*ModuleConfig_DetectionSensor)(nil),
		(*ModuleConfig_Paxcounter)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_meshtastic_module_config_proto_rawDesc), len(file_meshtastic_module_config_proto_rawDesc)),
			NumEnums:      6,
			NumMessages:   16,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_meshtastic_module_config_proto_goTypes,
		DependencyIndexes: file_meshtastic_module_config_proto_depIdxs,
		EnumInfos:         file_meshtastic_module_config_proto_enumTypes,
		MessageInfos:      file_meshtastic_module_config_proto_msgTypes,
	}.Build()
	File_meshtastic_module_config_proto = out.File
	file_meshtastic_module_config_proto_goTypes = nil
	file_meshtastic_module_config_proto_depIdxs = nil
}
