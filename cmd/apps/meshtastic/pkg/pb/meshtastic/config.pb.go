// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v3.21.12
// source: meshtastic/config.proto

package generated

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Defines the device's role on the Mesh network
type Config_DeviceConfig_Role int32

const (
	// Description: App connected or stand alone messaging device.
	// Technical Details: Default Role
	Config_DeviceConfig_CLIENT Config_DeviceConfig_Role = 0
	// Description: Device that does not forward packets from other devices.
	Config_DeviceConfig_CLIENT_MUTE Config_DeviceConfig_Role = 1
	// Description: Infrastructure node for extending network coverage by relaying messages. Visible in Nodes list.
	// Technical Details: Mesh packets will prefer to be routed over this node. This node will not be used by client apps.
	//
	//	The wifi radio and the oled screen will be put to sleep.
	//	This mode may still potentially have higher power usage due to it's preference in message rebroadcasting on the mesh.
	Config_DeviceConfig_ROUTER Config_DeviceConfig_Role = 2
	// Deprecated: Marked as deprecated in meshtastic/config.proto.
	Config_DeviceConfig_ROUTER_CLIENT Config_DeviceConfig_Role = 3
	// Description: Infrastructure node for extending network coverage by relaying messages with minimal overhead. Not visible in Nodes list.
	// Technical Details: Mesh packets will simply be rebroadcasted over this node. Nodes configured with this role will not originate NodeInfo, Position, Telemetry
	//
	//	or any other packet type. They will simply rebroadcast any mesh packets on the same frequency, channel num, spread factor, and coding rate.
	Config_DeviceConfig_REPEATER Config_DeviceConfig_Role = 4
	// Description: Broadcasts GPS position packets as priority.
	// Technical Details: Position Mesh packets will be prioritized higher and sent more frequently by default.
	//
	//	When used in conjunction with power.is_power_saving = true, nodes will wake up,
	//	send position, and then sleep for position.position_broadcast_secs seconds.
	Config_DeviceConfig_TRACKER Config_DeviceConfig_Role = 5
	// Description: Broadcasts telemetry packets as priority.
	// Technical Details: Telemetry Mesh packets will be prioritized higher and sent more frequently by default.
	//
	//	When used in conjunction with power.is_power_saving = true, nodes will wake up,
	//	send environment telemetry, and then sleep for telemetry.environment_update_interval seconds.
	Config_DeviceConfig_SENSOR Config_DeviceConfig_Role = 6
	// Description: Optimized for ATAK system communication and reduces routine broadcasts.
	// Technical Details: Used for nodes dedicated for connection to an ATAK EUD.
	//
	//	Turns off many of the routine broadcasts to favor CoT packet stream
	//	from the Meshtastic ATAK plugin -> IMeshService -> Node
	Config_DeviceConfig_TAK Config_DeviceConfig_Role = 7
	// Description: Device that only broadcasts as needed for stealth or power savings.
	// Technical Details: Used for nodes that "only speak when spoken to"
	//
	//	Turns all of the routine broadcasts but allows for ad-hoc communication
	//	Still rebroadcasts, but with local only rebroadcast mode (known meshes only)
	//	Can be used for clandestine operation or to dramatically reduce airtime / power consumption
	Config_DeviceConfig_CLIENT_HIDDEN Config_DeviceConfig_Role = 8
	// Description: Broadcasts location as message to default channel regularly for to assist with device recovery.
	// Technical Details: Used to automatically send a text message to the mesh
	//
	//	with the current position of the device on a frequent interval:
	//	"I'm lost! Position: lat / long"
	Config_DeviceConfig_LOST_AND_FOUND Config_DeviceConfig_Role = 9
	// Description: Enables automatic TAK PLI broadcasts and reduces routine broadcasts.
	// Technical Details: Turns off many of the routine broadcasts to favor ATAK CoT packet stream
	//
	//	and automatic TAK PLI (position location information) broadcasts.
	//	Uses position module configuration to determine TAK PLI broadcast interval.
	Config_DeviceConfig_TAK_TRACKER Config_DeviceConfig_Role = 10
	// Description: Will always rebroadcast packets, but will do so after all other modes.
	// Technical Details: Used for router nodes that are intended to provide additional coverage
	//
	//	in areas not already covered by other routers, or to bridge around problematic terrain,
	//	but should not be given priority over other routers in order to avoid unnecessaraily
	//	consuming hops.
	Config_DeviceConfig_ROUTER_LATE Config_DeviceConfig_Role = 11
)

// Enum value maps for Config_DeviceConfig_Role.
var (
	Config_DeviceConfig_Role_name = map[int32]string{
		0:  "CLIENT",
		1:  "CLIENT_MUTE",
		2:  "ROUTER",
		3:  "ROUTER_CLIENT",
		4:  "REPEATER",
		5:  "TRACKER",
		6:  "SENSOR",
		7:  "TAK",
		8:  "CLIENT_HIDDEN",
		9:  "LOST_AND_FOUND",
		10: "TAK_TRACKER",
		11: "ROUTER_LATE",
	}
	Config_DeviceConfig_Role_value = map[string]int32{
		"CLIENT":         0,
		"CLIENT_MUTE":    1,
		"ROUTER":         2,
		"ROUTER_CLIENT":  3,
		"REPEATER":       4,
		"TRACKER":        5,
		"SENSOR":         6,
		"TAK":            7,
		"CLIENT_HIDDEN":  8,
		"LOST_AND_FOUND": 9,
		"TAK_TRACKER":    10,
		"ROUTER_LATE":    11,
	}
)

func (x Config_DeviceConfig_Role) Enum() *Config_DeviceConfig_Role {
	p := new(Config_DeviceConfig_Role)
	*p = x
	return p
}

func (x Config_DeviceConfig_Role) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Config_DeviceConfig_Role) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_config_proto_enumTypes[0].Descriptor()
}

func (Config_DeviceConfig_Role) Type() protoreflect.EnumType {
	return &file_meshtastic_config_proto_enumTypes[0]
}

func (x Config_DeviceConfig_Role) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Config_DeviceConfig_Role.Descriptor instead.
func (Config_DeviceConfig_Role) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_config_proto_rawDescGZIP(), []int{0, 0, 0}
}

// Defines the device's behavior for how messages are rebroadcast
type Config_DeviceConfig_RebroadcastMode int32

const (
	// Default behavior.
	// Rebroadcast any observed message, if it was on our private channel or from another mesh with the same lora params.
	Config_DeviceConfig_ALL Config_DeviceConfig_RebroadcastMode = 0
	// Same as behavior as ALL but skips packet decoding and simply rebroadcasts them.
	// Only available in Repeater role. Setting this on any other roles will result in ALL behavior.
	Config_DeviceConfig_ALL_SKIP_DECODING Config_DeviceConfig_RebroadcastMode = 1
	// Ignores observed messages from foreign meshes that are open or those which it cannot decrypt.
	// Only rebroadcasts message on the nodes local primary / secondary channels.
	Config_DeviceConfig_LOCAL_ONLY Config_DeviceConfig_RebroadcastMode = 2
	// Ignores observed messages from foreign meshes like LOCAL_ONLY,
	// but takes it step further by also ignoring messages from nodenums not in the node's known list (NodeDB)
	Config_DeviceConfig_KNOWN_ONLY Config_DeviceConfig_RebroadcastMode = 3
	// Only permitted for SENSOR, TRACKER and TAK_TRACKER roles, this will inhibit all rebroadcasts, not unlike CLIENT_MUTE role.
	Config_DeviceConfig_NONE Config_DeviceConfig_RebroadcastMode = 4
	// Ignores packets from non-standard portnums such as: TAK, RangeTest, PaxCounter, etc.
	// Only rebroadcasts packets with standard portnums: NodeInfo, Text, Position, Telemetry, and Routing.
	Config_DeviceConfig_CORE_PORTNUMS_ONLY Config_DeviceConfig_RebroadcastMode = 5
)

// Enum value maps for Config_DeviceConfig_RebroadcastMode.
var (
	Config_DeviceConfig_RebroadcastMode_name = map[int32]string{
		0: "ALL",
		1: "ALL_SKIP_DECODING",
		2: "LOCAL_ONLY",
		3: "KNOWN_ONLY",
		4: "NONE",
		5: "CORE_PORTNUMS_ONLY",
	}
	Config_DeviceConfig_RebroadcastMode_value = map[string]int32{
		"ALL":                0,
		"ALL_SKIP_DECODING":  1,
		"LOCAL_ONLY":         2,
		"KNOWN_ONLY":         3,
		"NONE":               4,
		"CORE_PORTNUMS_ONLY": 5,
	}
)

func (x Config_DeviceConfig_RebroadcastMode) Enum() *Config_DeviceConfig_RebroadcastMode {
	p := new(Config_DeviceConfig_RebroadcastMode)
	*p = x
	return p
}

func (x Config_DeviceConfig_RebroadcastMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Config_DeviceConfig_RebroadcastMode) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_config_proto_enumTypes[1].Descriptor()
}

func (Config_DeviceConfig_RebroadcastMode) Type() protoreflect.EnumType {
	return &file_meshtastic_config_proto_enumTypes[1]
}

func (x Config_DeviceConfig_RebroadcastMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Config_DeviceConfig_RebroadcastMode.Descriptor instead.
func (Config_DeviceConfig_RebroadcastMode) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_config_proto_rawDescGZIP(), []int{0, 0, 1}
}

// Defines buzzer behavior for audio feedback
type Config_DeviceConfig_BuzzerMode int32

const (
	// Default behavior.
	// Buzzer is enabled for all audio feedback including button presses and alerts.
	Config_DeviceConfig_ALL_ENABLED Config_DeviceConfig_BuzzerMode = 0
	// Disabled.
	// All buzzer audio feedback is disabled.
	Config_DeviceConfig_DISABLED Config_DeviceConfig_BuzzerMode = 1
	// Notifications Only.
	// Buzzer is enabled only for notifications and alerts, but not for button presses.
	// External notification config determines the specifics of the notification behavior.
	Config_DeviceConfig_NOTIFICATIONS_ONLY Config_DeviceConfig_BuzzerMode = 2
	// Non-notification system buzzer tones only.
	// Buzzer is enabled only for non-notification tones such as button presses, startup, shutdown, but not for alerts.
	Config_DeviceConfig_SYSTEM_ONLY Config_DeviceConfig_BuzzerMode = 3
)

// Enum value maps for Config_DeviceConfig_BuzzerMode.
var (
	Config_DeviceConfig_BuzzerMode_name = map[int32]string{
		0: "ALL_ENABLED",
		1: "DISABLED",
		2: "NOTIFICATIONS_ONLY",
		3: "SYSTEM_ONLY",
	}
	Config_DeviceConfig_BuzzerMode_value = map[string]int32{
		"ALL_ENABLED":        0,
		"DISABLED":           1,
		"NOTIFICATIONS_ONLY": 2,
		"SYSTEM_ONLY":        3,
	}
)

func (x Config_DeviceConfig_BuzzerMode) Enum() *Config_DeviceConfig_BuzzerMode {
	p := new(Config_DeviceConfig_BuzzerMode)
	*p = x
	return p
}

func (x Config_DeviceConfig_BuzzerMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Config_DeviceConfig_BuzzerMode) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_config_proto_enumTypes[2].Descriptor()
}

func (Config_DeviceConfig_BuzzerMode) Type() protoreflect.EnumType {
	return &file_meshtastic_config_proto_enumTypes[2]
}

func (x Config_DeviceConfig_BuzzerMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Config_DeviceConfig_BuzzerMode.Descriptor instead.
func (Config_DeviceConfig_BuzzerMode) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_config_proto_rawDescGZIP(), []int{0, 0, 2}
}

// Bit field of boolean configuration options, indicating which optional
// fields to include when assembling POSITION messages.
// Longitude, latitude, altitude, speed, heading, and DOP
// are always included (also time if GPS-synced)
// NOTE: the more fields are included, the larger the message will be -
//
//	leading to longer airtime and a higher risk of packet loss
type Config_PositionConfig_PositionFlags int32

const (
	// Required for compilation
	Config_PositionConfig_UNSET Config_PositionConfig_PositionFlags = 0
	// Include an altitude value (if available)
	Config_PositionConfig_ALTITUDE Config_PositionConfig_PositionFlags = 1
	// Altitude value is MSL
	Config_PositionConfig_ALTITUDE_MSL Config_PositionConfig_PositionFlags = 2
	// Include geoidal separation
	Config_PositionConfig_GEOIDAL_SEPARATION Config_PositionConfig_PositionFlags = 4
	// Include the DOP value ; PDOP used by default, see below
	Config_PositionConfig_DOP Config_PositionConfig_PositionFlags = 8
	// If POS_DOP set, send separate HDOP / VDOP values instead of PDOP
	Config_PositionConfig_HVDOP Config_PositionConfig_PositionFlags = 16
	// Include number of "satellites in view"
	Config_PositionConfig_SATINVIEW Config_PositionConfig_PositionFlags = 32
	// Include a sequence number incremented per packet
	Config_PositionConfig_SEQ_NO Config_PositionConfig_PositionFlags = 64
	// Include positional timestamp (from GPS solution)
	Config_PositionConfig_TIMESTAMP Config_PositionConfig_PositionFlags = 128
	// Include positional heading
	// Intended for use with vehicle not walking speeds
	// walking speeds are likely to be error prone like the compass
	Config_PositionConfig_HEADING Config_PositionConfig_PositionFlags = 256
	// Include positional speed
	// Intended for use with vehicle not walking speeds
	// walking speeds are likely to be error prone like the compass
	Config_PositionConfig_SPEED Config_PositionConfig_PositionFlags = 512
)

// Enum value maps for Config_PositionConfig_PositionFlags.
var (
	Config_PositionConfig_PositionFlags_name = map[int32]string{
		0:   "UNSET",
		1:   "ALTITUDE",
		2:   "ALTITUDE_MSL",
		4:   "GEOIDAL_SEPARATION",
		8:   "DOP",
		16:  "HVDOP",
		32:  "SATINVIEW",
		64:  "SEQ_NO",
		128: "TIMESTAMP",
		256: "HEADING",
		512: "SPEED",
	}
	Config_PositionConfig_PositionFlags_value = map[string]int32{
		"UNSET":              0,
		"ALTITUDE":           1,
		"ALTITUDE_MSL":       2,
		"GEOIDAL_SEPARATION": 4,
		"DOP":                8,
		"HVDOP":              16,
		"SATINVIEW":          32,
		"SEQ_NO":             64,
		"TIMESTAMP":          128,
		"HEADING":            256,
		"SPEED":              512,
	}
)

func (x Config_PositionConfig_PositionFlags) Enum() *Config_PositionConfig_PositionFlags {
	p := new(Config_PositionConfig_PositionFlags)
	*p = x
	return p
}

func (x Config_PositionConfig_PositionFlags) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Config_PositionConfig_PositionFlags) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_config_proto_enumTypes[3].Descriptor()
}

func (Config_PositionConfig_PositionFlags) Type() protoreflect.EnumType {
	return &file_meshtastic_config_proto_enumTypes[3]
}

func (x Config_PositionConfig_PositionFlags) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Config_PositionConfig_PositionFlags.Descriptor instead.
func (Config_PositionConfig_PositionFlags) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_config_proto_rawDescGZIP(), []int{0, 1, 0}
}

type Config_PositionConfig_GpsMode int32

const (
	// GPS is present but disabled
	Config_PositionConfig_DISABLED Config_PositionConfig_GpsMode = 0
	// GPS is present and enabled
	Config_PositionConfig_ENABLED Config_PositionConfig_GpsMode = 1
	// GPS is not present on the device
	Config_PositionConfig_NOT_PRESENT Config_PositionConfig_GpsMode = 2
)

// Enum value maps for Config_PositionConfig_GpsMode.
var (
	Config_PositionConfig_GpsMode_name = map[int32]string{
		0: "DISABLED",
		1: "ENABLED",
		2: "NOT_PRESENT",
	}
	Config_PositionConfig_GpsMode_value = map[string]int32{
		"DISABLED":    0,
		"ENABLED":     1,
		"NOT_PRESENT": 2,
	}
)

func (x Config_PositionConfig_GpsMode) Enum() *Config_PositionConfig_GpsMode {
	p := new(Config_PositionConfig_GpsMode)
	*p = x
	return p
}

func (x Config_PositionConfig_GpsMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Config_PositionConfig_GpsMode) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_config_proto_enumTypes[4].Descriptor()
}

func (Config_PositionConfig_GpsMode) Type() protoreflect.EnumType {
	return &file_meshtastic_config_proto_enumTypes[4]
}

func (x Config_PositionConfig_GpsMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Config_PositionConfig_GpsMode.Descriptor instead.
func (Config_PositionConfig_GpsMode) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_config_proto_rawDescGZIP(), []int{0, 1, 1}
}

type Config_NetworkConfig_AddressMode int32

const (
	// obtain ip address via DHCP
	Config_NetworkConfig_DHCP Config_NetworkConfig_AddressMode = 0
	// use static ip address
	Config_NetworkConfig_STATIC Config_NetworkConfig_AddressMode = 1
)

// Enum value maps for Config_NetworkConfig_AddressMode.
var (
	Config_NetworkConfig_AddressMode_name = map[int32]string{
		0: "DHCP",
		1: "STATIC",
	}
	Config_NetworkConfig_AddressMode_value = map[string]int32{
		"DHCP":   0,
		"STATIC": 1,
	}
)

func (x Config_NetworkConfig_AddressMode) Enum() *Config_NetworkConfig_AddressMode {
	p := new(Config_NetworkConfig_AddressMode)
	*p = x
	return p
}

func (x Config_NetworkConfig_AddressMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Config_NetworkConfig_AddressMode) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_config_proto_enumTypes[5].Descriptor()
}

func (Config_NetworkConfig_AddressMode) Type() protoreflect.EnumType {
	return &file_meshtastic_config_proto_enumTypes[5]
}

func (x Config_NetworkConfig_AddressMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Config_NetworkConfig_AddressMode.Descriptor instead.
func (Config_NetworkConfig_AddressMode) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_config_proto_rawDescGZIP(), []int{0, 3, 0}
}

// Available flags auxiliary network protocols
type Config_NetworkConfig_ProtocolFlags int32

const (
	// Do not broadcast packets over any network protocol
	Config_NetworkConfig_NO_BROADCAST Config_NetworkConfig_ProtocolFlags = 0
	// Enable broadcasting packets via UDP over the local network
	Config_NetworkConfig_UDP_BROADCAST Config_NetworkConfig_ProtocolFlags = 1
)

// Enum value maps for Config_NetworkConfig_ProtocolFlags.
var (
	Config_NetworkConfig_ProtocolFlags_name = map[int32]string{
		0: "NO_BROADCAST",
		1: "UDP_BROADCAST",
	}
	Config_NetworkConfig_ProtocolFlags_value = map[string]int32{
		"NO_BROADCAST":  0,
		"UDP_BROADCAST": 1,
	}
)

func (x Config_NetworkConfig_ProtocolFlags) Enum() *Config_NetworkConfig_ProtocolFlags {
	p := new(Config_NetworkConfig_ProtocolFlags)
	*p = x
	return p
}

func (x Config_NetworkConfig_ProtocolFlags) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Config_NetworkConfig_ProtocolFlags) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_config_proto_enumTypes[6].Descriptor()
}

func (Config_NetworkConfig_ProtocolFlags) Type() protoreflect.EnumType {
	return &file_meshtastic_config_proto_enumTypes[6]
}

func (x Config_NetworkConfig_ProtocolFlags) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Config_NetworkConfig_ProtocolFlags.Descriptor instead.
func (Config_NetworkConfig_ProtocolFlags) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_config_proto_rawDescGZIP(), []int{0, 3, 1}
}

// How the GPS coordinates are displayed on the OLED screen.
type Config_DisplayConfig_GpsCoordinateFormat int32

const (
	// GPS coordinates are displayed in the normal decimal degrees format:
	// DD.DDDDDD DDD.DDDDDD
	Config_DisplayConfig_DEC Config_DisplayConfig_GpsCoordinateFormat = 0
	// GPS coordinates are displayed in the degrees minutes seconds format:
	// DD°MM'SS"C DDD°MM'SS"C, where C is the compass point representing the locations quadrant
	Config_DisplayConfig_DMS Config_DisplayConfig_GpsCoordinateFormat = 1
	// Universal Transverse Mercator format:
	// ZZB EEEEEE NNNNNNN, where Z is zone, B is band, E is easting, N is northing
	Config_DisplayConfig_UTM Config_DisplayConfig_GpsCoordinateFormat = 2
	// Military Grid Reference System format:
	// ZZB CD EEEEE NNNNN, where Z is zone, B is band, C is the east 100k square, D is the north 100k square,
	// E is easting, N is northing
	Config_DisplayConfig_MGRS Config_DisplayConfig_GpsCoordinateFormat = 3
	// Open Location Code (aka Plus Codes).
	Config_DisplayConfig_OLC Config_DisplayConfig_GpsCoordinateFormat = 4
	// Ordnance Survey Grid Reference (the National Grid System of the UK).
	// Format: AB EEEEE NNNNN, where A is the east 100k square, B is the north 100k square,
	// E is the easting, N is the northing
	Config_DisplayConfig_OSGR Config_DisplayConfig_GpsCoordinateFormat = 5
)

// Enum value maps for Config_DisplayConfig_GpsCoordinateFormat.
var (
	Config_DisplayConfig_GpsCoordinateFormat_name = map[int32]string{
		0: "DEC",
		1: "DMS",
		2: "UTM",
		3: "MGRS",
		4: "OLC",
		5: "OSGR",
	}
	Config_DisplayConfig_GpsCoordinateFormat_value = map[string]int32{
		"DEC":  0,
		"DMS":  1,
		"UTM":  2,
		"MGRS": 3,
		"OLC":  4,
		"OSGR": 5,
	}
)

func (x Config_DisplayConfig_GpsCoordinateFormat) Enum() *Config_DisplayConfig_GpsCoordinateFormat {
	p := new(Config_DisplayConfig_GpsCoordinateFormat)
	*p = x
	return p
}

func (x Config_DisplayConfig_GpsCoordinateFormat) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Config_DisplayConfig_GpsCoordinateFormat) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_config_proto_enumTypes[7].Descriptor()
}

func (Config_DisplayConfig_GpsCoordinateFormat) Type() protoreflect.EnumType {
	return &file_meshtastic_config_proto_enumTypes[7]
}

func (x Config_DisplayConfig_GpsCoordinateFormat) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Config_DisplayConfig_GpsCoordinateFormat.Descriptor instead.
func (Config_DisplayConfig_GpsCoordinateFormat) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_config_proto_rawDescGZIP(), []int{0, 4, 0}
}

// Unit display preference
type Config_DisplayConfig_DisplayUnits int32

const (
	// Metric (Default)
	Config_DisplayConfig_METRIC Config_DisplayConfig_DisplayUnits = 0
	// Imperial
	Config_DisplayConfig_IMPERIAL Config_DisplayConfig_DisplayUnits = 1
)

// Enum value maps for Config_DisplayConfig_DisplayUnits.
var (
	Config_DisplayConfig_DisplayUnits_name = map[int32]string{
		0: "METRIC",
		1: "IMPERIAL",
	}
	Config_DisplayConfig_DisplayUnits_value = map[string]int32{
		"METRIC":   0,
		"IMPERIAL": 1,
	}
)

func (x Config_DisplayConfig_DisplayUnits) Enum() *Config_DisplayConfig_DisplayUnits {
	p := new(Config_DisplayConfig_DisplayUnits)
	*p = x
	return p
}

func (x Config_DisplayConfig_DisplayUnits) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Config_DisplayConfig_DisplayUnits) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_config_proto_enumTypes[8].Descriptor()
}

func (Config_DisplayConfig_DisplayUnits) Type() protoreflect.EnumType {
	return &file_meshtastic_config_proto_enumTypes[8]
}

func (x Config_DisplayConfig_DisplayUnits) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Config_DisplayConfig_DisplayUnits.Descriptor instead.
func (Config_DisplayConfig_DisplayUnits) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_config_proto_rawDescGZIP(), []int{0, 4, 1}
}

// Override OLED outo detect with this if it fails.
type Config_DisplayConfig_OledType int32

const (
	// Default / Autodetect
	Config_DisplayConfig_OLED_AUTO Config_DisplayConfig_OledType = 0
	// Default / Autodetect
	Config_DisplayConfig_OLED_SSD1306 Config_DisplayConfig_OledType = 1
	// Default / Autodetect
	Config_DisplayConfig_OLED_SH1106 Config_DisplayConfig_OledType = 2
	// Can not be auto detected but set by proto. Used for 128x128 screens
	Config_DisplayConfig_OLED_SH1107 Config_DisplayConfig_OledType = 3
	// Can not be auto detected but set by proto. Used for 128x64 screens
	Config_DisplayConfig_OLED_SH1107_128_64 Config_DisplayConfig_OledType = 4
)

// Enum value maps for Config_DisplayConfig_OledType.
var (
	Config_DisplayConfig_OledType_name = map[int32]string{
		0: "OLED_AUTO",
		1: "OLED_SSD1306",
		2: "OLED_SH1106",
		3: "OLED_SH1107",
		4: "OLED_SH1107_128_64",
	}
	Config_DisplayConfig_OledType_value = map[string]int32{
		"OLED_AUTO":          0,
		"OLED_SSD1306":       1,
		"OLED_SH1106":        2,
		"OLED_SH1107":        3,
		"OLED_SH1107_128_64": 4,
	}
)

func (x Config_DisplayConfig_OledType) Enum() *Config_DisplayConfig_OledType {
	p := new(Config_DisplayConfig_OledType)
	*p = x
	return p
}

func (x Config_DisplayConfig_OledType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Config_DisplayConfig_OledType) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_config_proto_enumTypes[9].Descriptor()
}

func (Config_DisplayConfig_OledType) Type() protoreflect.EnumType {
	return &file_meshtastic_config_proto_enumTypes[9]
}

func (x Config_DisplayConfig_OledType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Config_DisplayConfig_OledType.Descriptor instead.
func (Config_DisplayConfig_OledType) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_config_proto_rawDescGZIP(), []int{0, 4, 2}
}

type Config_DisplayConfig_DisplayMode int32

const (
	// Default. The old style for the 128x64 OLED screen
	Config_DisplayConfig_DEFAULT Config_DisplayConfig_DisplayMode = 0
	// Rearrange display elements to cater for bicolor OLED displays
	Config_DisplayConfig_TWOCOLOR Config_DisplayConfig_DisplayMode = 1
	// Same as TwoColor, but with inverted top bar. Not so good for Epaper displays
	Config_DisplayConfig_INVERTED Config_DisplayConfig_DisplayMode = 2
	// TFT Full Color Displays (not implemented yet)
	Config_DisplayConfig_COLOR Config_DisplayConfig_DisplayMode = 3
)

// Enum value maps for Config_DisplayConfig_DisplayMode.
var (
	Config_DisplayConfig_DisplayMode_name = map[int32]string{
		0: "DEFAULT",
		1: "TWOCOLOR",
		2: "INVERTED",
		3: "COLOR",
	}
	Config_DisplayConfig_DisplayMode_value = map[string]int32{
		"DEFAULT":  0,
		"TWOCOLOR": 1,
		"INVERTED": 2,
		"COLOR":    3,
	}
)

func (x Config_DisplayConfig_DisplayMode) Enum() *Config_DisplayConfig_DisplayMode {
	p := new(Config_DisplayConfig_DisplayMode)
	*p = x
	return p
}

func (x Config_DisplayConfig_DisplayMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Config_DisplayConfig_DisplayMode) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_config_proto_enumTypes[10].Descriptor()
}

func (Config_DisplayConfig_DisplayMode) Type() protoreflect.EnumType {
	return &file_meshtastic_config_proto_enumTypes[10]
}

func (x Config_DisplayConfig_DisplayMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Config_DisplayConfig_DisplayMode.Descriptor instead.
func (Config_DisplayConfig_DisplayMode) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_config_proto_rawDescGZIP(), []int{0, 4, 3}
}

type Config_DisplayConfig_CompassOrientation int32

const (
	// The compass and the display are in the same orientation.
	Config_DisplayConfig_DEGREES_0 Config_DisplayConfig_CompassOrientation = 0
	// Rotate the compass by 90 degrees.
	Config_DisplayConfig_DEGREES_90 Config_DisplayConfig_CompassOrientation = 1
	// Rotate the compass by 180 degrees.
	Config_DisplayConfig_DEGREES_180 Config_DisplayConfig_CompassOrientation = 2
	// Rotate the compass by 270 degrees.
	Config_DisplayConfig_DEGREES_270 Config_DisplayConfig_CompassOrientation = 3
	// Don't rotate the compass, but invert the result.
	Config_DisplayConfig_DEGREES_0_INVERTED Config_DisplayConfig_CompassOrientation = 4
	// Rotate the compass by 90 degrees and invert.
	Config_DisplayConfig_DEGREES_90_INVERTED Config_DisplayConfig_CompassOrientation = 5
	// Rotate the compass by 180 degrees and invert.
	Config_DisplayConfig_DEGREES_180_INVERTED Config_DisplayConfig_CompassOrientation = 6
	// Rotate the compass by 270 degrees and invert.
	Config_DisplayConfig_DEGREES_270_INVERTED Config_DisplayConfig_CompassOrientation = 7
)

// Enum value maps for Config_DisplayConfig_CompassOrientation.
var (
	Config_DisplayConfig_CompassOrientation_name = map[int32]string{
		0: "DEGREES_0",
		1: "DEGREES_90",
		2: "DEGREES_180",
		3: "DEGREES_270",
		4: "DEGREES_0_INVERTED",
		5: "DEGREES_90_INVERTED",
		6: "DEGREES_180_INVERTED",
		7: "DEGREES_270_INVERTED",
	}
	Config_DisplayConfig_CompassOrientation_value = map[string]int32{
		"DEGREES_0":            0,
		"DEGREES_90":           1,
		"DEGREES_180":          2,
		"DEGREES_270":          3,
		"DEGREES_0_INVERTED":   4,
		"DEGREES_90_INVERTED":  5,
		"DEGREES_180_INVERTED": 6,
		"DEGREES_270_INVERTED": 7,
	}
)

func (x Config_DisplayConfig_CompassOrientation) Enum() *Config_DisplayConfig_CompassOrientation {
	p := new(Config_DisplayConfig_CompassOrientation)
	*p = x
	return p
}

func (x Config_DisplayConfig_CompassOrientation) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Config_DisplayConfig_CompassOrientation) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_config_proto_enumTypes[11].Descriptor()
}

func (Config_DisplayConfig_CompassOrientation) Type() protoreflect.EnumType {
	return &file_meshtastic_config_proto_enumTypes[11]
}

func (x Config_DisplayConfig_CompassOrientation) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Config_DisplayConfig_CompassOrientation.Descriptor instead.
func (Config_DisplayConfig_CompassOrientation) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_config_proto_rawDescGZIP(), []int{0, 4, 4}
}

type Config_LoRaConfig_RegionCode int32

const (
	// Region is not set
	Config_LoRaConfig_UNSET Config_LoRaConfig_RegionCode = 0
	// United States
	Config_LoRaConfig_US Config_LoRaConfig_RegionCode = 1
	// European Union 433mhz
	Config_LoRaConfig_EU_433 Config_LoRaConfig_RegionCode = 2
	// European Union 868mhz
	Config_LoRaConfig_EU_868 Config_LoRaConfig_RegionCode = 3
	// China
	Config_LoRaConfig_CN Config_LoRaConfig_RegionCode = 4
	// Japan
	Config_LoRaConfig_JP Config_LoRaConfig_RegionCode = 5
	// Australia / New Zealand
	Config_LoRaConfig_ANZ Config_LoRaConfig_RegionCode = 6
	// Korea
	Config_LoRaConfig_KR Config_LoRaConfig_RegionCode = 7
	// Taiwan
	Config_LoRaConfig_TW Config_LoRaConfig_RegionCode = 8
	// Russia
	Config_LoRaConfig_RU Config_LoRaConfig_RegionCode = 9
	// India
	Config_LoRaConfig_IN Config_LoRaConfig_RegionCode = 10
	// New Zealand 865mhz
	Config_LoRaConfig_NZ_865 Config_LoRaConfig_RegionCode = 11
	// Thailand
	Config_LoRaConfig_TH Config_LoRaConfig_RegionCode = 12
	// WLAN Band
	Config_LoRaConfig_LORA_24 Config_LoRaConfig_RegionCode = 13
	// Ukraine 433mhz
	Config_LoRaConfig_UA_433 Config_LoRaConfig_RegionCode = 14
	// Ukraine 868mhz
	Config_LoRaConfig_UA_868 Config_LoRaConfig_RegionCode = 15
	// Malaysia 433mhz
	Config_LoRaConfig_MY_433 Config_LoRaConfig_RegionCode = 16
	// Malaysia 919mhz
	Config_LoRaConfig_MY_919 Config_LoRaConfig_RegionCode = 17
	// Singapore 923mhz
	Config_LoRaConfig_SG_923 Config_LoRaConfig_RegionCode = 18
	// Philippines 433mhz
	Config_LoRaConfig_PH_433 Config_LoRaConfig_RegionCode = 19
	// Philippines 868mhz
	Config_LoRaConfig_PH_868 Config_LoRaConfig_RegionCode = 20
	// Philippines 915mhz
	Config_LoRaConfig_PH_915 Config_LoRaConfig_RegionCode = 21
	// Australia / New Zealand 433MHz
	Config_LoRaConfig_ANZ_433 Config_LoRaConfig_RegionCode = 22
	// Kazakhstan 433MHz
	Config_LoRaConfig_KZ_433 Config_LoRaConfig_RegionCode = 23
	// Kazakhstan 863MHz
	Config_LoRaConfig_KZ_863 Config_LoRaConfig_RegionCode = 24
)

// Enum value maps for Config_LoRaConfig_RegionCode.
var (
	Config_LoRaConfig_RegionCode_name = map[int32]string{
		0:  "UNSET",
		1:  "US",
		2:  "EU_433",
		3:  "EU_868",
		4:  "CN",
		5:  "JP",
		6:  "ANZ",
		7:  "KR",
		8:  "TW",
		9:  "RU",
		10: "IN",
		11: "NZ_865",
		12: "TH",
		13: "LORA_24",
		14: "UA_433",
		15: "UA_868",
		16: "MY_433",
		17: "MY_919",
		18: "SG_923",
		19: "PH_433",
		20: "PH_868",
		21: "PH_915",
		22: "ANZ_433",
		23: "KZ_433",
		24: "KZ_863",
	}
	Config_LoRaConfig_RegionCode_value = map[string]int32{
		"UNSET":   0,
		"US":      1,
		"EU_433":  2,
		"EU_868":  3,
		"CN":      4,
		"JP":      5,
		"ANZ":     6,
		"KR":      7,
		"TW":      8,
		"RU":      9,
		"IN":      10,
		"NZ_865":  11,
		"TH":      12,
		"LORA_24": 13,
		"UA_433":  14,
		"UA_868":  15,
		"MY_433":  16,
		"MY_919":  17,
		"SG_923":  18,
		"PH_433":  19,
		"PH_868":  20,
		"PH_915":  21,
		"ANZ_433": 22,
		"KZ_433":  23,
		"KZ_863":  24,
	}
)

func (x Config_LoRaConfig_RegionCode) Enum() *Config_LoRaConfig_RegionCode {
	p := new(Config_LoRaConfig_RegionCode)
	*p = x
	return p
}

func (x Config_LoRaConfig_RegionCode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Config_LoRaConfig_RegionCode) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_config_proto_enumTypes[12].Descriptor()
}

func (Config_LoRaConfig_RegionCode) Type() protoreflect.EnumType {
	return &file_meshtastic_config_proto_enumTypes[12]
}

func (x Config_LoRaConfig_RegionCode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Config_LoRaConfig_RegionCode.Descriptor instead.
func (Config_LoRaConfig_RegionCode) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_config_proto_rawDescGZIP(), []int{0, 5, 0}
}

// Standard predefined channel settings
// Note: these mappings must match ModemPreset Choice in the device code.
type Config_LoRaConfig_ModemPreset int32

const (
	// Long Range - Fast
	Config_LoRaConfig_LONG_FAST Config_LoRaConfig_ModemPreset = 0
	// Long Range - Slow
	Config_LoRaConfig_LONG_SLOW Config_LoRaConfig_ModemPreset = 1
	// Very Long Range - Slow
	// Deprecated in 2.5: Works only with txco and is unusably slow
	//
	// Deprecated: Marked as deprecated in meshtastic/config.proto.
	Config_LoRaConfig_VERY_LONG_SLOW Config_LoRaConfig_ModemPreset = 2
	// Medium Range - Slow
	Config_LoRaConfig_MEDIUM_SLOW Config_LoRaConfig_ModemPreset = 3
	// Medium Range - Fast
	Config_LoRaConfig_MEDIUM_FAST Config_LoRaConfig_ModemPreset = 4
	// Short Range - Slow
	Config_LoRaConfig_SHORT_SLOW Config_LoRaConfig_ModemPreset = 5
	// Short Range - Fast
	Config_LoRaConfig_SHORT_FAST Config_LoRaConfig_ModemPreset = 6
	// Long Range - Moderately Fast
	Config_LoRaConfig_LONG_MODERATE Config_LoRaConfig_ModemPreset = 7
	// Short Range - Turbo
	// This is the fastest preset and the only one with 500kHz bandwidth.
	// It is not legal to use in all regions due to this wider bandwidth.
	Config_LoRaConfig_SHORT_TURBO Config_LoRaConfig_ModemPreset = 8
)

// Enum value maps for Config_LoRaConfig_ModemPreset.
var (
	Config_LoRaConfig_ModemPreset_name = map[int32]string{
		0: "LONG_FAST",
		1: "LONG_SLOW",
		2: "VERY_LONG_SLOW",
		3: "MEDIUM_SLOW",
		4: "MEDIUM_FAST",
		5: "SHORT_SLOW",
		6: "SHORT_FAST",
		7: "LONG_MODERATE",
		8: "SHORT_TURBO",
	}
	Config_LoRaConfig_ModemPreset_value = map[string]int32{
		"LONG_FAST":      0,
		"LONG_SLOW":      1,
		"VERY_LONG_SLOW": 2,
		"MEDIUM_SLOW":    3,
		"MEDIUM_FAST":    4,
		"SHORT_SLOW":     5,
		"SHORT_FAST":     6,
		"LONG_MODERATE":  7,
		"SHORT_TURBO":    8,
	}
)

func (x Config_LoRaConfig_ModemPreset) Enum() *Config_LoRaConfig_ModemPreset {
	p := new(Config_LoRaConfig_ModemPreset)
	*p = x
	return p
}

func (x Config_LoRaConfig_ModemPreset) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Config_LoRaConfig_ModemPreset) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_config_proto_enumTypes[13].Descriptor()
}

func (Config_LoRaConfig_ModemPreset) Type() protoreflect.EnumType {
	return &file_meshtastic_config_proto_enumTypes[13]
}

func (x Config_LoRaConfig_ModemPreset) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Config_LoRaConfig_ModemPreset.Descriptor instead.
func (Config_LoRaConfig_ModemPreset) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_config_proto_rawDescGZIP(), []int{0, 5, 1}
}

type Config_BluetoothConfig_PairingMode int32

const (
	// Device generates a random PIN that will be shown on the screen of the device for pairing
	Config_BluetoothConfig_RANDOM_PIN Config_BluetoothConfig_PairingMode = 0
	// Device requires a specified fixed PIN for pairing
	Config_BluetoothConfig_FIXED_PIN Config_BluetoothConfig_PairingMode = 1
	// Device requires no PIN for pairing
	Config_BluetoothConfig_NO_PIN Config_BluetoothConfig_PairingMode = 2
)

// Enum value maps for Config_BluetoothConfig_PairingMode.
var (
	Config_BluetoothConfig_PairingMode_name = map[int32]string{
		0: "RANDOM_PIN",
		1: "FIXED_PIN",
		2: "NO_PIN",
	}
	Config_BluetoothConfig_PairingMode_value = map[string]int32{
		"RANDOM_PIN": 0,
		"FIXED_PIN":  1,
		"NO_PIN":     2,
	}
)

func (x Config_BluetoothConfig_PairingMode) Enum() *Config_BluetoothConfig_PairingMode {
	p := new(Config_BluetoothConfig_PairingMode)
	*p = x
	return p
}

func (x Config_BluetoothConfig_PairingMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Config_BluetoothConfig_PairingMode) Descriptor() protoreflect.EnumDescriptor {
	return file_meshtastic_config_proto_enumTypes[14].Descriptor()
}

func (Config_BluetoothConfig_PairingMode) Type() protoreflect.EnumType {
	return &file_meshtastic_config_proto_enumTypes[14]
}

func (x Config_BluetoothConfig_PairingMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Config_BluetoothConfig_PairingMode.Descriptor instead.
func (Config_BluetoothConfig_PairingMode) EnumDescriptor() ([]byte, []int) {
	return file_meshtastic_config_proto_rawDescGZIP(), []int{0, 6, 0}
}

type Config struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Payload Variant
	//
	// Types that are valid to be assigned to PayloadVariant:
	//
	//	*Config_Device
	//	*Config_Position
	//	*Config_Power
	//	*Config_Network
	//	*Config_Display
	//	*Config_Lora
	//	*Config_Bluetooth
	//	*Config_Security
	//	*Config_Sessionkey
	//	*Config_DeviceUi
	PayloadVariant isConfig_PayloadVariant `protobuf_oneof:"payload_variant"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *Config) Reset() {
	*x = Config{}
	mi := &file_meshtastic_config_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Config) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Config) ProtoMessage() {}

func (x *Config) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_config_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Config.ProtoReflect.Descriptor instead.
func (*Config) Descriptor() ([]byte, []int) {
	return file_meshtastic_config_proto_rawDescGZIP(), []int{0}
}

func (x *Config) GetPayloadVariant() isConfig_PayloadVariant {
	if x != nil {
		return x.PayloadVariant
	}
	return nil
}

func (x *Config) GetDevice() *Config_DeviceConfig {
	if x != nil {
		if x, ok := x.PayloadVariant.(*Config_Device); ok {
			return x.Device
		}
	}
	return nil
}

func (x *Config) GetPosition() *Config_PositionConfig {
	if x != nil {
		if x, ok := x.PayloadVariant.(*Config_Position); ok {
			return x.Position
		}
	}
	return nil
}

func (x *Config) GetPower() *Config_PowerConfig {
	if x != nil {
		if x, ok := x.PayloadVariant.(*Config_Power); ok {
			return x.Power
		}
	}
	return nil
}

func (x *Config) GetNetwork() *Config_NetworkConfig {
	if x != nil {
		if x, ok := x.PayloadVariant.(*Config_Network); ok {
			return x.Network
		}
	}
	return nil
}

func (x *Config) GetDisplay() *Config_DisplayConfig {
	if x != nil {
		if x, ok := x.PayloadVariant.(*Config_Display); ok {
			return x.Display
		}
	}
	return nil
}

func (x *Config) GetLora() *Config_LoRaConfig {
	if x != nil {
		if x, ok := x.PayloadVariant.(*Config_Lora); ok {
			return x.Lora
		}
	}
	return nil
}

func (x *Config) GetBluetooth() *Config_BluetoothConfig {
	if x != nil {
		if x, ok := x.PayloadVariant.(*Config_Bluetooth); ok {
			return x.Bluetooth
		}
	}
	return nil
}

func (x *Config) GetSecurity() *Config_SecurityConfig {
	if x != nil {
		if x, ok := x.PayloadVariant.(*Config_Security); ok {
			return x.Security
		}
	}
	return nil
}

func (x *Config) GetSessionkey() *Config_SessionkeyConfig {
	if x != nil {
		if x, ok := x.PayloadVariant.(*Config_Sessionkey); ok {
			return x.Sessionkey
		}
	}
	return nil
}

func (x *Config) GetDeviceUi() *DeviceUIConfig {
	if x != nil {
		if x, ok := x.PayloadVariant.(*Config_DeviceUi); ok {
			return x.DeviceUi
		}
	}
	return nil
}

type isConfig_PayloadVariant interface {
	isConfig_PayloadVariant()
}

type Config_Device struct {
	Device *Config_DeviceConfig `protobuf:"bytes,1,opt,name=device,proto3,oneof"`
}

type Config_Position struct {
	Position *Config_PositionConfig `protobuf:"bytes,2,opt,name=position,proto3,oneof"`
}

type Config_Power struct {
	Power *Config_PowerConfig `protobuf:"bytes,3,opt,name=power,proto3,oneof"`
}

type Config_Network struct {
	Network *Config_NetworkConfig `protobuf:"bytes,4,opt,name=network,proto3,oneof"`
}

type Config_Display struct {
	Display *Config_DisplayConfig `protobuf:"bytes,5,opt,name=display,proto3,oneof"`
}

type Config_Lora struct {
	Lora *Config_LoRaConfig `protobuf:"bytes,6,opt,name=lora,proto3,oneof"`
}

type Config_Bluetooth struct {
	Bluetooth *Config_BluetoothConfig `protobuf:"bytes,7,opt,name=bluetooth,proto3,oneof"`
}

type Config_Security struct {
	Security *Config_SecurityConfig `protobuf:"bytes,8,opt,name=security,proto3,oneof"`
}

type Config_Sessionkey struct {
	Sessionkey *Config_SessionkeyConfig `protobuf:"bytes,9,opt,name=sessionkey,proto3,oneof"`
}

type Config_DeviceUi struct {
	DeviceUi *DeviceUIConfig `protobuf:"bytes,10,opt,name=device_ui,json=deviceUi,proto3,oneof"`
}

func (*Config_Device) isConfig_PayloadVariant() {}

func (*Config_Position) isConfig_PayloadVariant() {}

func (*Config_Power) isConfig_PayloadVariant() {}

func (*Config_Network) isConfig_PayloadVariant() {}

func (*Config_Display) isConfig_PayloadVariant() {}

func (*Config_Lora) isConfig_PayloadVariant() {}

func (*Config_Bluetooth) isConfig_PayloadVariant() {}

func (*Config_Security) isConfig_PayloadVariant() {}

func (*Config_Sessionkey) isConfig_PayloadVariant() {}

func (*Config_DeviceUi) isConfig_PayloadVariant() {}

// Configuration
type Config_DeviceConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Sets the role of node
	Role Config_DeviceConfig_Role `protobuf:"varint,1,opt,name=role,proto3,enum=meshtastic.Config_DeviceConfig_Role" json:"role,omitempty"`
	// Disabling this will disable the SerialConsole by not initilizing the StreamAPI
	// Moved to SecurityConfig
	//
	// Deprecated: Marked as deprecated in meshtastic/config.proto.
	SerialEnabled bool `protobuf:"varint,2,opt,name=serial_enabled,json=serialEnabled,proto3" json:"serial_enabled,omitempty"`
	// For boards without a hard wired button, this is the pin number that will be used
	// Boards that have more than one button can swap the function with this one. defaults to BUTTON_PIN if defined.
	ButtonGpio uint32 `protobuf:"varint,4,opt,name=button_gpio,json=buttonGpio,proto3" json:"button_gpio,omitempty"`
	// For boards without a PWM buzzer, this is the pin number that will be used
	// Defaults to PIN_BUZZER if defined.
	BuzzerGpio uint32 `protobuf:"varint,5,opt,name=buzzer_gpio,json=buzzerGpio,proto3" json:"buzzer_gpio,omitempty"`
	// Sets the role of node
	RebroadcastMode Config_DeviceConfig_RebroadcastMode `protobuf:"varint,6,opt,name=rebroadcast_mode,json=rebroadcastMode,proto3,enum=meshtastic.Config_DeviceConfig_RebroadcastMode" json:"rebroadcast_mode,omitempty"`
	// Send our nodeinfo this often
	// Defaults to 900 Seconds (15 minutes)
	NodeInfoBroadcastSecs uint32 `protobuf:"varint,7,opt,name=node_info_broadcast_secs,json=nodeInfoBroadcastSecs,proto3" json:"node_info_broadcast_secs,omitempty"`
	// Treat double tap interrupt on supported accelerometers as a button press if set to true
	DoubleTapAsButtonPress bool `protobuf:"varint,8,opt,name=double_tap_as_button_press,json=doubleTapAsButtonPress,proto3" json:"double_tap_as_button_press,omitempty"`
	// If true, device is considered to be "managed" by a mesh administrator
	// Clients should then limit available configuration and administrative options inside the user interface
	// Moved to SecurityConfig
	//
	// Deprecated: Marked as deprecated in meshtastic/config.proto.
	IsManaged bool `protobuf:"varint,9,opt,name=is_managed,json=isManaged,proto3" json:"is_managed,omitempty"`
	// Disables the triple-press of user button to enable or disable GPS
	DisableTripleClick bool `protobuf:"varint,10,opt,name=disable_triple_click,json=disableTripleClick,proto3" json:"disable_triple_click,omitempty"`
	// POSIX Timezone definition string from https://github.com/nayarsystems/posix_tz_db/blob/master/zones.csv.
	Tzdef string `protobuf:"bytes,11,opt,name=tzdef,proto3" json:"tzdef,omitempty"`
	// If true, disable the default blinking LED (LED_PIN) behavior on the device
	LedHeartbeatDisabled bool `protobuf:"varint,12,opt,name=led_heartbeat_disabled,json=ledHeartbeatDisabled,proto3" json:"led_heartbeat_disabled,omitempty"`
	// Controls buzzer behavior for audio feedback
	// Defaults to ENABLED
	BuzzerMode    Config_DeviceConfig_BuzzerMode `protobuf:"varint,13,opt,name=buzzer_mode,json=buzzerMode,proto3,enum=meshtastic.Config_DeviceConfig_BuzzerMode" json:"buzzer_mode,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Config_DeviceConfig) Reset() {
	*x = Config_DeviceConfig{}
	mi := &file_meshtastic_config_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Config_DeviceConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Config_DeviceConfig) ProtoMessage() {}

func (x *Config_DeviceConfig) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_config_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Config_DeviceConfig.ProtoReflect.Descriptor instead.
func (*Config_DeviceConfig) Descriptor() ([]byte, []int) {
	return file_meshtastic_config_proto_rawDescGZIP(), []int{0, 0}
}

func (x *Config_DeviceConfig) GetRole() Config_DeviceConfig_Role {
	if x != nil {
		return x.Role
	}
	return Config_DeviceConfig_CLIENT
}

// Deprecated: Marked as deprecated in meshtastic/config.proto.
func (x *Config_DeviceConfig) GetSerialEnabled() bool {
	if x != nil {
		return x.SerialEnabled
	}
	return false
}

func (x *Config_DeviceConfig) GetButtonGpio() uint32 {
	if x != nil {
		return x.ButtonGpio
	}
	return 0
}

func (x *Config_DeviceConfig) GetBuzzerGpio() uint32 {
	if x != nil {
		return x.BuzzerGpio
	}
	return 0
}

func (x *Config_DeviceConfig) GetRebroadcastMode() Config_DeviceConfig_RebroadcastMode {
	if x != nil {
		return x.RebroadcastMode
	}
	return Config_DeviceConfig_ALL
}

func (x *Config_DeviceConfig) GetNodeInfoBroadcastSecs() uint32 {
	if x != nil {
		return x.NodeInfoBroadcastSecs
	}
	return 0
}

func (x *Config_DeviceConfig) GetDoubleTapAsButtonPress() bool {
	if x != nil {
		return x.DoubleTapAsButtonPress
	}
	return false
}

// Deprecated: Marked as deprecated in meshtastic/config.proto.
func (x *Config_DeviceConfig) GetIsManaged() bool {
	if x != nil {
		return x.IsManaged
	}
	return false
}

func (x *Config_DeviceConfig) GetDisableTripleClick() bool {
	if x != nil {
		return x.DisableTripleClick
	}
	return false
}

func (x *Config_DeviceConfig) GetTzdef() string {
	if x != nil {
		return x.Tzdef
	}
	return ""
}

func (x *Config_DeviceConfig) GetLedHeartbeatDisabled() bool {
	if x != nil {
		return x.LedHeartbeatDisabled
	}
	return false
}

func (x *Config_DeviceConfig) GetBuzzerMode() Config_DeviceConfig_BuzzerMode {
	if x != nil {
		return x.BuzzerMode
	}
	return Config_DeviceConfig_ALL_ENABLED
}

// Position Config
type Config_PositionConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// We should send our position this often (but only if it has changed significantly)
	// Defaults to 15 minutes
	PositionBroadcastSecs uint32 `protobuf:"varint,1,opt,name=position_broadcast_secs,json=positionBroadcastSecs,proto3" json:"position_broadcast_secs,omitempty"`
	// Adaptive position braoadcast, which is now the default.
	PositionBroadcastSmartEnabled bool `protobuf:"varint,2,opt,name=position_broadcast_smart_enabled,json=positionBroadcastSmartEnabled,proto3" json:"position_broadcast_smart_enabled,omitempty"`
	// If set, this node is at a fixed position.
	// We will generate GPS position updates at the regular interval, but use whatever the last lat/lon/alt we have for the node.
	// The lat/lon/alt can be set by an internal GPS or with the help of the app.
	FixedPosition bool `protobuf:"varint,3,opt,name=fixed_position,json=fixedPosition,proto3" json:"fixed_position,omitempty"`
	// Is GPS enabled for this node?
	//
	// Deprecated: Marked as deprecated in meshtastic/config.proto.
	GpsEnabled bool `protobuf:"varint,4,opt,name=gps_enabled,json=gpsEnabled,proto3" json:"gps_enabled,omitempty"`
	// How often should we try to get GPS position (in seconds)
	// or zero for the default of once every 30 seconds
	// or a very large value (maxint) to update only once at boot.
	GpsUpdateInterval uint32 `protobuf:"varint,5,opt,name=gps_update_interval,json=gpsUpdateInterval,proto3" json:"gps_update_interval,omitempty"`
	// Deprecated in favor of using smart / regular broadcast intervals as implicit attempt time
	//
	// Deprecated: Marked as deprecated in meshtastic/config.proto.
	GpsAttemptTime uint32 `protobuf:"varint,6,opt,name=gps_attempt_time,json=gpsAttemptTime,proto3" json:"gps_attempt_time,omitempty"`
	// Bit field of boolean configuration options for POSITION messages
	// (bitwise OR of PositionFlags)
	PositionFlags uint32 `protobuf:"varint,7,opt,name=position_flags,json=positionFlags,proto3" json:"position_flags,omitempty"`
	// (Re)define GPS_RX_PIN for your board.
	RxGpio uint32 `protobuf:"varint,8,opt,name=rx_gpio,json=rxGpio,proto3" json:"rx_gpio,omitempty"`
	// (Re)define GPS_TX_PIN for your board.
	TxGpio uint32 `protobuf:"varint,9,opt,name=tx_gpio,json=txGpio,proto3" json:"tx_gpio,omitempty"`
	// The minimum distance in meters traveled (since the last send) before we can send a position to the mesh if position_broadcast_smart_enabled
	BroadcastSmartMinimumDistance uint32 `protobuf:"varint,10,opt,name=broadcast_smart_minimum_distance,json=broadcastSmartMinimumDistance,proto3" json:"broadcast_smart_minimum_distance,omitempty"`
	// The minimum number of seconds (since the last send) before we can send a position to the mesh if position_broadcast_smart_enabled
	BroadcastSmartMinimumIntervalSecs uint32 `protobuf:"varint,11,opt,name=broadcast_smart_minimum_interval_secs,json=broadcastSmartMinimumIntervalSecs,proto3" json:"broadcast_smart_minimum_interval_secs,omitempty"`
	// (Re)define PIN_GPS_EN for your board.
	GpsEnGpio uint32 `protobuf:"varint,12,opt,name=gps_en_gpio,json=gpsEnGpio,proto3" json:"gps_en_gpio,omitempty"`
	// Set where GPS is enabled, disabled, or not present
	GpsMode       Config_PositionConfig_GpsMode `protobuf:"varint,13,opt,name=gps_mode,json=gpsMode,proto3,enum=meshtastic.Config_PositionConfig_GpsMode" json:"gps_mode,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Config_PositionConfig) Reset() {
	*x = Config_PositionConfig{}
	mi := &file_meshtastic_config_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Config_PositionConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Config_PositionConfig) ProtoMessage() {}

func (x *Config_PositionConfig) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_config_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Config_PositionConfig.ProtoReflect.Descriptor instead.
func (*Config_PositionConfig) Descriptor() ([]byte, []int) {
	return file_meshtastic_config_proto_rawDescGZIP(), []int{0, 1}
}

func (x *Config_PositionConfig) GetPositionBroadcastSecs() uint32 {
	if x != nil {
		return x.PositionBroadcastSecs
	}
	return 0
}

func (x *Config_PositionConfig) GetPositionBroadcastSmartEnabled() bool {
	if x != nil {
		return x.PositionBroadcastSmartEnabled
	}
	return false
}

func (x *Config_PositionConfig) GetFixedPosition() bool {
	if x != nil {
		return x.FixedPosition
	}
	return false
}

// Deprecated: Marked as deprecated in meshtastic/config.proto.
func (x *Config_PositionConfig) GetGpsEnabled() bool {
	if x != nil {
		return x.GpsEnabled
	}
	return false
}

func (x *Config_PositionConfig) GetGpsUpdateInterval() uint32 {
	if x != nil {
		return x.GpsUpdateInterval
	}
	return 0
}

// Deprecated: Marked as deprecated in meshtastic/config.proto.
func (x *Config_PositionConfig) GetGpsAttemptTime() uint32 {
	if x != nil {
		return x.GpsAttemptTime
	}
	return 0
}

func (x *Config_PositionConfig) GetPositionFlags() uint32 {
	if x != nil {
		return x.PositionFlags
	}
	return 0
}

func (x *Config_PositionConfig) GetRxGpio() uint32 {
	if x != nil {
		return x.RxGpio
	}
	return 0
}

func (x *Config_PositionConfig) GetTxGpio() uint32 {
	if x != nil {
		return x.TxGpio
	}
	return 0
}

func (x *Config_PositionConfig) GetBroadcastSmartMinimumDistance() uint32 {
	if x != nil {
		return x.BroadcastSmartMinimumDistance
	}
	return 0
}

func (x *Config_PositionConfig) GetBroadcastSmartMinimumIntervalSecs() uint32 {
	if x != nil {
		return x.BroadcastSmartMinimumIntervalSecs
	}
	return 0
}

func (x *Config_PositionConfig) GetGpsEnGpio() uint32 {
	if x != nil {
		return x.GpsEnGpio
	}
	return 0
}

func (x *Config_PositionConfig) GetGpsMode() Config_PositionConfig_GpsMode {
	if x != nil {
		return x.GpsMode
	}
	return Config_PositionConfig_DISABLED
}

// Power Config\
// See [Power Config](/docs/settings/config/power) for additional power config details.
type Config_PowerConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Description: Will sleep everything as much as possible, for the tracker and sensor role this will also include the lora radio.
	// Don't use this setting if you want to use your device with the phone apps or are using a device without a user button.
	// Technical Details: Works for ESP32 devices and NRF52 devices in the Sensor or Tracker roles
	IsPowerSaving bool `protobuf:"varint,1,opt,name=is_power_saving,json=isPowerSaving,proto3" json:"is_power_saving,omitempty"`
	// Description: If non-zero, the device will fully power off this many seconds after external power is removed.
	OnBatteryShutdownAfterSecs uint32 `protobuf:"varint,2,opt,name=on_battery_shutdown_after_secs,json=onBatteryShutdownAfterSecs,proto3" json:"on_battery_shutdown_after_secs,omitempty"`
	// Ratio of voltage divider for battery pin eg. 3.20 (R1=100k, R2=220k)
	// Overrides the ADC_MULTIPLIER defined in variant for battery voltage calculation.
	// https://meshtastic.org/docs/configuration/radio/power/#adc-multiplier-override
	// Should be set to floating point value between 2 and 6
	AdcMultiplierOverride float32 `protobuf:"fixed32,3,opt,name=adc_multiplier_override,json=adcMultiplierOverride,proto3" json:"adc_multiplier_override,omitempty"`
	// Description: The number of seconds for to wait before turning off BLE in No Bluetooth states
	// Technical Details: ESP32 Only 0 for default of 1 minute
	WaitBluetoothSecs uint32 `protobuf:"varint,4,opt,name=wait_bluetooth_secs,json=waitBluetoothSecs,proto3" json:"wait_bluetooth_secs,omitempty"`
	// Super Deep Sleep Seconds
	// While in Light Sleep if mesh_sds_timeout_secs is exceeded we will lower into super deep sleep
	// for this value (default 1 year) or a button press
	// 0 for default of one year
	SdsSecs uint32 `protobuf:"varint,6,opt,name=sds_secs,json=sdsSecs,proto3" json:"sds_secs,omitempty"`
	// Description: In light sleep the CPU is suspended, LoRa radio is on, BLE is off an GPS is on
	// Technical Details: ESP32 Only 0 for default of 300
	LsSecs uint32 `protobuf:"varint,7,opt,name=ls_secs,json=lsSecs,proto3" json:"ls_secs,omitempty"`
	// Description: While in light sleep when we receive packets on the LoRa radio we will wake and handle them and stay awake in no BLE mode for this value
	// Technical Details: ESP32 Only 0 for default of 10 seconds
	MinWakeSecs uint32 `protobuf:"varint,8,opt,name=min_wake_secs,json=minWakeSecs,proto3" json:"min_wake_secs,omitempty"`
	// I2C address of INA_2XX to use for reading device battery voltage
	DeviceBatteryInaAddress uint32 `protobuf:"varint,9,opt,name=device_battery_ina_address,json=deviceBatteryInaAddress,proto3" json:"device_battery_ina_address,omitempty"`
	// If non-zero, we want powermon log outputs.  With the particular (bitfield) sources enabled.
	// Note: we picked an ID of 32 so that lower more efficient IDs can be used for more frequently used options.
	PowermonEnables uint64 `protobuf:"varint,32,opt,name=powermon_enables,json=powermonEnables,proto3" json:"powermon_enables,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *Config_PowerConfig) Reset() {
	*x = Config_PowerConfig{}
	mi := &file_meshtastic_config_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Config_PowerConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Config_PowerConfig) ProtoMessage() {}

func (x *Config_PowerConfig) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_config_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Config_PowerConfig.ProtoReflect.Descriptor instead.
func (*Config_PowerConfig) Descriptor() ([]byte, []int) {
	return file_meshtastic_config_proto_rawDescGZIP(), []int{0, 2}
}

func (x *Config_PowerConfig) GetIsPowerSaving() bool {
	if x != nil {
		return x.IsPowerSaving
	}
	return false
}

func (x *Config_PowerConfig) GetOnBatteryShutdownAfterSecs() uint32 {
	if x != nil {
		return x.OnBatteryShutdownAfterSecs
	}
	return 0
}

func (x *Config_PowerConfig) GetAdcMultiplierOverride() float32 {
	if x != nil {
		return x.AdcMultiplierOverride
	}
	return 0
}

func (x *Config_PowerConfig) GetWaitBluetoothSecs() uint32 {
	if x != nil {
		return x.WaitBluetoothSecs
	}
	return 0
}

func (x *Config_PowerConfig) GetSdsSecs() uint32 {
	if x != nil {
		return x.SdsSecs
	}
	return 0
}

func (x *Config_PowerConfig) GetLsSecs() uint32 {
	if x != nil {
		return x.LsSecs
	}
	return 0
}

func (x *Config_PowerConfig) GetMinWakeSecs() uint32 {
	if x != nil {
		return x.MinWakeSecs
	}
	return 0
}

func (x *Config_PowerConfig) GetDeviceBatteryInaAddress() uint32 {
	if x != nil {
		return x.DeviceBatteryInaAddress
	}
	return 0
}

func (x *Config_PowerConfig) GetPowermonEnables() uint64 {
	if x != nil {
		return x.PowermonEnables
	}
	return 0
}

// Network Config
type Config_NetworkConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Enable WiFi (disables Bluetooth)
	WifiEnabled bool `protobuf:"varint,1,opt,name=wifi_enabled,json=wifiEnabled,proto3" json:"wifi_enabled,omitempty"`
	// If set, this node will try to join the specified wifi network and
	// acquire an address via DHCP
	WifiSsid string `protobuf:"bytes,3,opt,name=wifi_ssid,json=wifiSsid,proto3" json:"wifi_ssid,omitempty"`
	// If set, will be use to authenticate to the named wifi
	WifiPsk string `protobuf:"bytes,4,opt,name=wifi_psk,json=wifiPsk,proto3" json:"wifi_psk,omitempty"`
	// NTP server to use if WiFi is conneced, defaults to `meshtastic.pool.ntp.org`
	NtpServer string `protobuf:"bytes,5,opt,name=ntp_server,json=ntpServer,proto3" json:"ntp_server,omitempty"`
	// Enable Ethernet
	EthEnabled bool `protobuf:"varint,6,opt,name=eth_enabled,json=ethEnabled,proto3" json:"eth_enabled,omitempty"`
	// acquire an address via DHCP or assign static
	AddressMode Config_NetworkConfig_AddressMode `protobuf:"varint,7,opt,name=address_mode,json=addressMode,proto3,enum=meshtastic.Config_NetworkConfig_AddressMode" json:"address_mode,omitempty"`
	// struct to keep static address
	Ipv4Config *Config_NetworkConfig_IpV4Config `protobuf:"bytes,8,opt,name=ipv4_config,json=ipv4Config,proto3" json:"ipv4_config,omitempty"`
	// rsyslog Server and Port
	RsyslogServer string `protobuf:"bytes,9,opt,name=rsyslog_server,json=rsyslogServer,proto3" json:"rsyslog_server,omitempty"`
	// Flags for enabling/disabling network protocols
	EnabledProtocols uint32 `protobuf:"varint,10,opt,name=enabled_protocols,json=enabledProtocols,proto3" json:"enabled_protocols,omitempty"`
	// Enable/Disable ipv6 support
	Ipv6Enabled   bool `protobuf:"varint,11,opt,name=ipv6_enabled,json=ipv6Enabled,proto3" json:"ipv6_enabled,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Config_NetworkConfig) Reset() {
	*x = Config_NetworkConfig{}
	mi := &file_meshtastic_config_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Config_NetworkConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Config_NetworkConfig) ProtoMessage() {}

func (x *Config_NetworkConfig) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_config_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Config_NetworkConfig.ProtoReflect.Descriptor instead.
func (*Config_NetworkConfig) Descriptor() ([]byte, []int) {
	return file_meshtastic_config_proto_rawDescGZIP(), []int{0, 3}
}

func (x *Config_NetworkConfig) GetWifiEnabled() bool {
	if x != nil {
		return x.WifiEnabled
	}
	return false
}

func (x *Config_NetworkConfig) GetWifiSsid() string {
	if x != nil {
		return x.WifiSsid
	}
	return ""
}

func (x *Config_NetworkConfig) GetWifiPsk() string {
	if x != nil {
		return x.WifiPsk
	}
	return ""
}

func (x *Config_NetworkConfig) GetNtpServer() string {
	if x != nil {
		return x.NtpServer
	}
	return ""
}

func (x *Config_NetworkConfig) GetEthEnabled() bool {
	if x != nil {
		return x.EthEnabled
	}
	return false
}

func (x *Config_NetworkConfig) GetAddressMode() Config_NetworkConfig_AddressMode {
	if x != nil {
		return x.AddressMode
	}
	return Config_NetworkConfig_DHCP
}

func (x *Config_NetworkConfig) GetIpv4Config() *Config_NetworkConfig_IpV4Config {
	if x != nil {
		return x.Ipv4Config
	}
	return nil
}

func (x *Config_NetworkConfig) GetRsyslogServer() string {
	if x != nil {
		return x.RsyslogServer
	}
	return ""
}

func (x *Config_NetworkConfig) GetEnabledProtocols() uint32 {
	if x != nil {
		return x.EnabledProtocols
	}
	return 0
}

func (x *Config_NetworkConfig) GetIpv6Enabled() bool {
	if x != nil {
		return x.Ipv6Enabled
	}
	return false
}

// Display Config
type Config_DisplayConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Number of seconds the screen stays on after pressing the user button or receiving a message
	// 0 for default of one minute MAXUINT for always on
	ScreenOnSecs uint32 `protobuf:"varint,1,opt,name=screen_on_secs,json=screenOnSecs,proto3" json:"screen_on_secs,omitempty"`
	// How the GPS coordinates are formatted on the OLED screen.
	GpsFormat Config_DisplayConfig_GpsCoordinateFormat `protobuf:"varint,2,opt,name=gps_format,json=gpsFormat,proto3,enum=meshtastic.Config_DisplayConfig_GpsCoordinateFormat" json:"gps_format,omitempty"`
	// Automatically toggles to the next page on the screen like a carousel, based the specified interval in seconds.
	// Potentially useful for devices without user buttons.
	AutoScreenCarouselSecs uint32 `protobuf:"varint,3,opt,name=auto_screen_carousel_secs,json=autoScreenCarouselSecs,proto3" json:"auto_screen_carousel_secs,omitempty"`
	// If this is set, the displayed compass will always point north. if unset, the old behaviour
	// (top of display is heading direction) is used.
	CompassNorthTop bool `protobuf:"varint,4,opt,name=compass_north_top,json=compassNorthTop,proto3" json:"compass_north_top,omitempty"`
	// Flip screen vertically, for cases that mount the screen upside down
	FlipScreen bool `protobuf:"varint,5,opt,name=flip_screen,json=flipScreen,proto3" json:"flip_screen,omitempty"`
	// Perferred display units
	Units Config_DisplayConfig_DisplayUnits `protobuf:"varint,6,opt,name=units,proto3,enum=meshtastic.Config_DisplayConfig_DisplayUnits" json:"units,omitempty"`
	// Override auto-detect in screen
	Oled Config_DisplayConfig_OledType `protobuf:"varint,7,opt,name=oled,proto3,enum=meshtastic.Config_DisplayConfig_OledType" json:"oled,omitempty"`
	// Display Mode
	Displaymode Config_DisplayConfig_DisplayMode `protobuf:"varint,8,opt,name=displaymode,proto3,enum=meshtastic.Config_DisplayConfig_DisplayMode" json:"displaymode,omitempty"`
	// Print first line in pseudo-bold? FALSE is original style, TRUE is bold
	HeadingBold bool `protobuf:"varint,9,opt,name=heading_bold,json=headingBold,proto3" json:"heading_bold,omitempty"`
	// Should we wake the screen up on accelerometer detected motion or tap
	WakeOnTapOrMotion bool `protobuf:"varint,10,opt,name=wake_on_tap_or_motion,json=wakeOnTapOrMotion,proto3" json:"wake_on_tap_or_motion,omitempty"`
	// Indicates how to rotate or invert the compass output to accurate display on the display.
	CompassOrientation Config_DisplayConfig_CompassOrientation `protobuf:"varint,11,opt,name=compass_orientation,json=compassOrientation,proto3,enum=meshtastic.Config_DisplayConfig_CompassOrientation" json:"compass_orientation,omitempty"`
	// If false (default), the device will display the time in 24-hour format on screen.
	// If true, the device will display the time in 12-hour format on screen.
	Use_12HClock  bool `protobuf:"varint,12,opt,name=use_12h_clock,json=use12hClock,proto3" json:"use_12h_clock,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Config_DisplayConfig) Reset() {
	*x = Config_DisplayConfig{}
	mi := &file_meshtastic_config_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Config_DisplayConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Config_DisplayConfig) ProtoMessage() {}

func (x *Config_DisplayConfig) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_config_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Config_DisplayConfig.ProtoReflect.Descriptor instead.
func (*Config_DisplayConfig) Descriptor() ([]byte, []int) {
	return file_meshtastic_config_proto_rawDescGZIP(), []int{0, 4}
}

func (x *Config_DisplayConfig) GetScreenOnSecs() uint32 {
	if x != nil {
		return x.ScreenOnSecs
	}
	return 0
}

func (x *Config_DisplayConfig) GetGpsFormat() Config_DisplayConfig_GpsCoordinateFormat {
	if x != nil {
		return x.GpsFormat
	}
	return Config_DisplayConfig_DEC
}

func (x *Config_DisplayConfig) GetAutoScreenCarouselSecs() uint32 {
	if x != nil {
		return x.AutoScreenCarouselSecs
	}
	return 0
}

func (x *Config_DisplayConfig) GetCompassNorthTop() bool {
	if x != nil {
		return x.CompassNorthTop
	}
	return false
}

func (x *Config_DisplayConfig) GetFlipScreen() bool {
	if x != nil {
		return x.FlipScreen
	}
	return false
}

func (x *Config_DisplayConfig) GetUnits() Config_DisplayConfig_DisplayUnits {
	if x != nil {
		return x.Units
	}
	return Config_DisplayConfig_METRIC
}

func (x *Config_DisplayConfig) GetOled() Config_DisplayConfig_OledType {
	if x != nil {
		return x.Oled
	}
	return Config_DisplayConfig_OLED_AUTO
}

func (x *Config_DisplayConfig) GetDisplaymode() Config_DisplayConfig_DisplayMode {
	if x != nil {
		return x.Displaymode
	}
	return Config_DisplayConfig_DEFAULT
}

func (x *Config_DisplayConfig) GetHeadingBold() bool {
	if x != nil {
		return x.HeadingBold
	}
	return false
}

func (x *Config_DisplayConfig) GetWakeOnTapOrMotion() bool {
	if x != nil {
		return x.WakeOnTapOrMotion
	}
	return false
}

func (x *Config_DisplayConfig) GetCompassOrientation() Config_DisplayConfig_CompassOrientation {
	if x != nil {
		return x.CompassOrientation
	}
	return Config_DisplayConfig_DEGREES_0
}

func (x *Config_DisplayConfig) GetUse_12HClock() bool {
	if x != nil {
		return x.Use_12HClock
	}
	return false
}

// Lora Config
type Config_LoRaConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// When enabled, the `modem_preset` fields will be adhered to, else the `bandwidth`/`spread_factor`/`coding_rate`
	// will be taked from their respective manually defined fields
	UsePreset bool `protobuf:"varint,1,opt,name=use_preset,json=usePreset,proto3" json:"use_preset,omitempty"`
	// Either modem_config or bandwidth/spreading/coding will be specified - NOT BOTH.
	// As a heuristic: If bandwidth is specified, do not use modem_config.
	// Because protobufs take ZERO space when the value is zero this works out nicely.
	// This value is replaced by bandwidth/spread_factor/coding_rate.
	// If you'd like to experiment with other options add them to MeshRadio.cpp in the device code.
	ModemPreset Config_LoRaConfig_ModemPreset `protobuf:"varint,2,opt,name=modem_preset,json=modemPreset,proto3,enum=meshtastic.Config_LoRaConfig_ModemPreset" json:"modem_preset,omitempty"`
	// Bandwidth in MHz
	// Certain bandwidth numbers are 'special' and will be converted to the
	// appropriate floating point value: 31 -> 31.25MHz
	Bandwidth uint32 `protobuf:"varint,3,opt,name=bandwidth,proto3" json:"bandwidth,omitempty"`
	// A number from 7 to 12.
	// Indicates number of chirps per symbol as 1<<spread_factor.
	SpreadFactor uint32 `protobuf:"varint,4,opt,name=spread_factor,json=spreadFactor,proto3" json:"spread_factor,omitempty"`
	// The denominator of the coding rate.
	// ie for 4/5, the value is 5. 4/8 the value is 8.
	CodingRate uint32 `protobuf:"varint,5,opt,name=coding_rate,json=codingRate,proto3" json:"coding_rate,omitempty"`
	// This parameter is for advanced users with advanced test equipment, we do not recommend most users use it.
	// A frequency offset that is added to to the calculated band center frequency.
	// Used to correct for crystal calibration errors.
	FrequencyOffset float32 `protobuf:"fixed32,6,opt,name=frequency_offset,json=frequencyOffset,proto3" json:"frequency_offset,omitempty"`
	// The region code for the radio (US, CN, EU433, etc...)
	Region Config_LoRaConfig_RegionCode `protobuf:"varint,7,opt,name=region,proto3,enum=meshtastic.Config_LoRaConfig_RegionCode" json:"region,omitempty"`
	// Maximum number of hops. This can't be greater than 7.
	// Default of 3
	// Attempting to set a value > 7 results in the default
	HopLimit uint32 `protobuf:"varint,8,opt,name=hop_limit,json=hopLimit,proto3" json:"hop_limit,omitempty"`
	// Disable TX from the LoRa radio. Useful for hot-swapping antennas and other tests.
	// Defaults to false
	TxEnabled bool `protobuf:"varint,9,opt,name=tx_enabled,json=txEnabled,proto3" json:"tx_enabled,omitempty"`
	// If zero, then use default max legal continuous power (ie. something that won't
	// burn out the radio hardware)
	// In most cases you should use zero here.
	// Units are in dBm.
	TxPower int32 `protobuf:"varint,10,opt,name=tx_power,json=txPower,proto3" json:"tx_power,omitempty"`
	// This controls the actual hardware frequency the radio transmits on.
	// Most users should never need to be exposed to this field/concept.
	// A channel number between 1 and NUM_CHANNELS (whatever the max is in the current region).
	// If ZERO then the rule is "use the old channel name hash based
	// algorithm to derive the channel number")
	// If using the hash algorithm the channel number will be: hash(channel_name) %
	// NUM_CHANNELS (Where num channels depends on the regulatory region).
	ChannelNum uint32 `protobuf:"varint,11,opt,name=channel_num,json=channelNum,proto3" json:"channel_num,omitempty"`
	// If true, duty cycle limits will be exceeded and thus you're possibly not following
	// the local regulations if you're not a HAM.
	// Has no effect if the duty cycle of the used region is 100%.
	OverrideDutyCycle bool `protobuf:"varint,12,opt,name=override_duty_cycle,json=overrideDutyCycle,proto3" json:"override_duty_cycle,omitempty"`
	// If true, sets RX boosted gain mode on SX126X based radios
	Sx126XRxBoostedGain bool `protobuf:"varint,13,opt,name=sx126x_rx_boosted_gain,json=sx126xRxBoostedGain,proto3" json:"sx126x_rx_boosted_gain,omitempty"`
	// This parameter is for advanced users and licensed HAM radio operators.
	// Ignore Channel Calculation and use this frequency instead. The frequency_offset
	// will still be applied. This will allow you to use out-of-band frequencies.
	// Please respect your local laws and regulations. If you are a HAM, make sure you
	// enable HAM mode and turn off encryption.
	OverrideFrequency float32 `protobuf:"fixed32,14,opt,name=override_frequency,json=overrideFrequency,proto3" json:"override_frequency,omitempty"`
	// If true, disable the build-in PA FAN using pin define in RF95_FAN_EN.
	PaFanDisabled bool `protobuf:"varint,15,opt,name=pa_fan_disabled,json=paFanDisabled,proto3" json:"pa_fan_disabled,omitempty"`
	// For testing it is useful sometimes to force a node to never listen to
	// particular other nodes (simulating radio out of range). All nodenums listed
	// in ignore_incoming will have packets they send dropped on receive (by router.cpp)
	IgnoreIncoming []uint32 `protobuf:"varint,103,rep,packed,name=ignore_incoming,json=ignoreIncoming,proto3" json:"ignore_incoming,omitempty"`
	// If true, the device will not process any packets received via LoRa that passed via MQTT anywhere on the path towards it.
	IgnoreMqtt bool `protobuf:"varint,104,opt,name=ignore_mqtt,json=ignoreMqtt,proto3" json:"ignore_mqtt,omitempty"`
	// Sets the ok_to_mqtt bit on outgoing packets
	ConfigOkToMqtt bool `protobuf:"varint,105,opt,name=config_ok_to_mqtt,json=configOkToMqtt,proto3" json:"config_ok_to_mqtt,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *Config_LoRaConfig) Reset() {
	*x = Config_LoRaConfig{}
	mi := &file_meshtastic_config_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Config_LoRaConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Config_LoRaConfig) ProtoMessage() {}

func (x *Config_LoRaConfig) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_config_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Config_LoRaConfig.ProtoReflect.Descriptor instead.
func (*Config_LoRaConfig) Descriptor() ([]byte, []int) {
	return file_meshtastic_config_proto_rawDescGZIP(), []int{0, 5}
}

func (x *Config_LoRaConfig) GetUsePreset() bool {
	if x != nil {
		return x.UsePreset
	}
	return false
}

func (x *Config_LoRaConfig) GetModemPreset() Config_LoRaConfig_ModemPreset {
	if x != nil {
		return x.ModemPreset
	}
	return Config_LoRaConfig_LONG_FAST
}

func (x *Config_LoRaConfig) GetBandwidth() uint32 {
	if x != nil {
		return x.Bandwidth
	}
	return 0
}

func (x *Config_LoRaConfig) GetSpreadFactor() uint32 {
	if x != nil {
		return x.SpreadFactor
	}
	return 0
}

func (x *Config_LoRaConfig) GetCodingRate() uint32 {
	if x != nil {
		return x.CodingRate
	}
	return 0
}

func (x *Config_LoRaConfig) GetFrequencyOffset() float32 {
	if x != nil {
		return x.FrequencyOffset
	}
	return 0
}

func (x *Config_LoRaConfig) GetRegion() Config_LoRaConfig_RegionCode {
	if x != nil {
		return x.Region
	}
	return Config_LoRaConfig_UNSET
}

func (x *Config_LoRaConfig) GetHopLimit() uint32 {
	if x != nil {
		return x.HopLimit
	}
	return 0
}

func (x *Config_LoRaConfig) GetTxEnabled() bool {
	if x != nil {
		return x.TxEnabled
	}
	return false
}

func (x *Config_LoRaConfig) GetTxPower() int32 {
	if x != nil {
		return x.TxPower
	}
	return 0
}

func (x *Config_LoRaConfig) GetChannelNum() uint32 {
	if x != nil {
		return x.ChannelNum
	}
	return 0
}

func (x *Config_LoRaConfig) GetOverrideDutyCycle() bool {
	if x != nil {
		return x.OverrideDutyCycle
	}
	return false
}

func (x *Config_LoRaConfig) GetSx126XRxBoostedGain() bool {
	if x != nil {
		return x.Sx126XRxBoostedGain
	}
	return false
}

func (x *Config_LoRaConfig) GetOverrideFrequency() float32 {
	if x != nil {
		return x.OverrideFrequency
	}
	return 0
}

func (x *Config_LoRaConfig) GetPaFanDisabled() bool {
	if x != nil {
		return x.PaFanDisabled
	}
	return false
}

func (x *Config_LoRaConfig) GetIgnoreIncoming() []uint32 {
	if x != nil {
		return x.IgnoreIncoming
	}
	return nil
}

func (x *Config_LoRaConfig) GetIgnoreMqtt() bool {
	if x != nil {
		return x.IgnoreMqtt
	}
	return false
}

func (x *Config_LoRaConfig) GetConfigOkToMqtt() bool {
	if x != nil {
		return x.ConfigOkToMqtt
	}
	return false
}

type Config_BluetoothConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Enable Bluetooth on the device
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Determines the pairing strategy for the device
	Mode Config_BluetoothConfig_PairingMode `protobuf:"varint,2,opt,name=mode,proto3,enum=meshtastic.Config_BluetoothConfig_PairingMode" json:"mode,omitempty"`
	// Specified PIN for PairingMode.FixedPin
	FixedPin      uint32 `protobuf:"varint,3,opt,name=fixed_pin,json=fixedPin,proto3" json:"fixed_pin,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Config_BluetoothConfig) Reset() {
	*x = Config_BluetoothConfig{}
	mi := &file_meshtastic_config_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Config_BluetoothConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Config_BluetoothConfig) ProtoMessage() {}

func (x *Config_BluetoothConfig) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_config_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Config_BluetoothConfig.ProtoReflect.Descriptor instead.
func (*Config_BluetoothConfig) Descriptor() ([]byte, []int) {
	return file_meshtastic_config_proto_rawDescGZIP(), []int{0, 6}
}

func (x *Config_BluetoothConfig) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *Config_BluetoothConfig) GetMode() Config_BluetoothConfig_PairingMode {
	if x != nil {
		return x.Mode
	}
	return Config_BluetoothConfig_RANDOM_PIN
}

func (x *Config_BluetoothConfig) GetFixedPin() uint32 {
	if x != nil {
		return x.FixedPin
	}
	return 0
}

type Config_SecurityConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The public key of the user's device.
	// Sent out to other nodes on the mesh to allow them to compute a shared secret key.
	PublicKey []byte `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// The private key of the device.
	// Used to create a shared key with a remote device.
	PrivateKey []byte `protobuf:"bytes,2,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`
	// The public key authorized to send admin messages to this node.
	AdminKey [][]byte `protobuf:"bytes,3,rep,name=admin_key,json=adminKey,proto3" json:"admin_key,omitempty"`
	// If true, device is considered to be "managed" by a mesh administrator via admin messages
	// Device is managed by a mesh administrator.
	IsManaged bool `protobuf:"varint,4,opt,name=is_managed,json=isManaged,proto3" json:"is_managed,omitempty"`
	// Serial Console over the Stream API."
	SerialEnabled bool `protobuf:"varint,5,opt,name=serial_enabled,json=serialEnabled,proto3" json:"serial_enabled,omitempty"`
	// By default we turn off logging as soon as an API client connects (to keep shared serial link quiet).
	// Output live debug logging over serial or bluetooth is set to true.
	DebugLogApiEnabled bool `protobuf:"varint,6,opt,name=debug_log_api_enabled,json=debugLogApiEnabled,proto3" json:"debug_log_api_enabled,omitempty"`
	// Allow incoming device control over the insecure legacy admin channel.
	AdminChannelEnabled bool `protobuf:"varint,8,opt,name=admin_channel_enabled,json=adminChannelEnabled,proto3" json:"admin_channel_enabled,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *Config_SecurityConfig) Reset() {
	*x = Config_SecurityConfig{}
	mi := &file_meshtastic_config_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Config_SecurityConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Config_SecurityConfig) ProtoMessage() {}

func (x *Config_SecurityConfig) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_config_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Config_SecurityConfig.ProtoReflect.Descriptor instead.
func (*Config_SecurityConfig) Descriptor() ([]byte, []int) {
	return file_meshtastic_config_proto_rawDescGZIP(), []int{0, 7}
}

func (x *Config_SecurityConfig) GetPublicKey() []byte {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

func (x *Config_SecurityConfig) GetPrivateKey() []byte {
	if x != nil {
		return x.PrivateKey
	}
	return nil
}

func (x *Config_SecurityConfig) GetAdminKey() [][]byte {
	if x != nil {
		return x.AdminKey
	}
	return nil
}

func (x *Config_SecurityConfig) GetIsManaged() bool {
	if x != nil {
		return x.IsManaged
	}
	return false
}

func (x *Config_SecurityConfig) GetSerialEnabled() bool {
	if x != nil {
		return x.SerialEnabled
	}
	return false
}

func (x *Config_SecurityConfig) GetDebugLogApiEnabled() bool {
	if x != nil {
		return x.DebugLogApiEnabled
	}
	return false
}

func (x *Config_SecurityConfig) GetAdminChannelEnabled() bool {
	if x != nil {
		return x.AdminChannelEnabled
	}
	return false
}

// Blank config request, strictly for getting the session key
type Config_SessionkeyConfig struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Config_SessionkeyConfig) Reset() {
	*x = Config_SessionkeyConfig{}
	mi := &file_meshtastic_config_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Config_SessionkeyConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Config_SessionkeyConfig) ProtoMessage() {}

func (x *Config_SessionkeyConfig) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_config_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Config_SessionkeyConfig.ProtoReflect.Descriptor instead.
func (*Config_SessionkeyConfig) Descriptor() ([]byte, []int) {
	return file_meshtastic_config_proto_rawDescGZIP(), []int{0, 8}
}

type Config_NetworkConfig_IpV4Config struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Static IP address
	Ip uint32 `protobuf:"fixed32,1,opt,name=ip,proto3" json:"ip,omitempty"`
	// Static gateway address
	Gateway uint32 `protobuf:"fixed32,2,opt,name=gateway,proto3" json:"gateway,omitempty"`
	// Static subnet mask
	Subnet uint32 `protobuf:"fixed32,3,opt,name=subnet,proto3" json:"subnet,omitempty"`
	// Static DNS server address
	Dns           uint32 `protobuf:"fixed32,4,opt,name=dns,proto3" json:"dns,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Config_NetworkConfig_IpV4Config) Reset() {
	*x = Config_NetworkConfig_IpV4Config{}
	mi := &file_meshtastic_config_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Config_NetworkConfig_IpV4Config) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Config_NetworkConfig_IpV4Config) ProtoMessage() {}

func (x *Config_NetworkConfig_IpV4Config) ProtoReflect() protoreflect.Message {
	mi := &file_meshtastic_config_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Config_NetworkConfig_IpV4Config.ProtoReflect.Descriptor instead.
func (*Config_NetworkConfig_IpV4Config) Descriptor() ([]byte, []int) {
	return file_meshtastic_config_proto_rawDescGZIP(), []int{0, 3, 0}
}

func (x *Config_NetworkConfig_IpV4Config) GetIp() uint32 {
	if x != nil {
		return x.Ip
	}
	return 0
}

func (x *Config_NetworkConfig_IpV4Config) GetGateway() uint32 {
	if x != nil {
		return x.Gateway
	}
	return 0
}

func (x *Config_NetworkConfig_IpV4Config) GetSubnet() uint32 {
	if x != nil {
		return x.Subnet
	}
	return 0
}

func (x *Config_NetworkConfig_IpV4Config) GetDns() uint32 {
	if x != nil {
		return x.Dns
	}
	return 0
}

var File_meshtastic_config_proto protoreflect.FileDescriptor

const file_meshtastic_config_proto_rawDesc = "" +
	"\n" +
	"\x17meshtastic/config.proto\x12\n" +
	"meshtastic\x1a\x1ameshtastic/device_ui.proto\"\x893\n" +
	"\x06Config\x129\n" +
	"\x06device\x18\x01 \x01(\v2\x1f.meshtastic.Config.DeviceConfigH\x00R\x06device\x12?\n" +
	"\bposition\x18\x02 \x01(\v2!.meshtastic.Config.PositionConfigH\x00R\bposition\x126\n" +
	"\x05power\x18\x03 \x01(\v2\x1e.meshtastic.Config.PowerConfigH\x00R\x05power\x12<\n" +
	"\anetwork\x18\x04 \x01(\v2 .meshtastic.Config.NetworkConfigH\x00R\anetwork\x12<\n" +
	"\adisplay\x18\x05 \x01(\v2 .meshtastic.Config.DisplayConfigH\x00R\adisplay\x123\n" +
	"\x04lora\x18\x06 \x01(\v2\x1d.meshtastic.Config.LoRaConfigH\x00R\x04lora\x12B\n" +
	"\tbluetooth\x18\a \x01(\v2\".meshtastic.Config.BluetoothConfigH\x00R\tbluetooth\x12?\n" +
	"\bsecurity\x18\b \x01(\v2!.meshtastic.Config.SecurityConfigH\x00R\bsecurity\x12E\n" +
	"\n" +
	"sessionkey\x18\t \x01(\v2#.meshtastic.Config.SessionkeyConfigH\x00R\n" +
	"sessionkey\x129\n" +
	"\tdevice_ui\x18\n" +
	" \x01(\v2\x1a.meshtastic.DeviceUIConfigH\x00R\bdeviceUi\x1a\x81\b\n" +
	"\fDeviceConfig\x128\n" +
	"\x04role\x18\x01 \x01(\x0e2$.meshtastic.Config.DeviceConfig.RoleR\x04role\x12)\n" +
	"\x0eserial_enabled\x18\x02 \x01(\bB\x02\x18\x01R\rserialEnabled\x12\x1f\n" +
	"\vbutton_gpio\x18\x04 \x01(\rR\n" +
	"buttonGpio\x12\x1f\n" +
	"\vbuzzer_gpio\x18\x05 \x01(\rR\n" +
	"buzzerGpio\x12Z\n" +
	"\x10rebroadcast_mode\x18\x06 \x01(\x0e2/.meshtastic.Config.DeviceConfig.RebroadcastModeR\x0frebroadcastMode\x127\n" +
	"\x18node_info_broadcast_secs\x18\a \x01(\rR\x15nodeInfoBroadcastSecs\x12:\n" +
	"\x1adouble_tap_as_button_press\x18\b \x01(\bR\x16doubleTapAsButtonPress\x12!\n" +
	"\n" +
	"is_managed\x18\t \x01(\bB\x02\x18\x01R\tisManaged\x120\n" +
	"\x14disable_triple_click\x18\n" +
	" \x01(\bR\x12disableTripleClick\x12\x14\n" +
	"\x05tzdef\x18\v \x01(\tR\x05tzdef\x124\n" +
	"\x16led_heartbeat_disabled\x18\f \x01(\bR\x14ledHeartbeatDisabled\x12K\n" +
	"\vbuzzer_mode\x18\r \x01(\x0e2*.meshtastic.Config.DeviceConfig.BuzzerModeR\n" +
	"buzzerMode\"\xbf\x01\n" +
	"\x04Role\x12\n" +
	"\n" +
	"\x06CLIENT\x10\x00\x12\x0f\n" +
	"\vCLIENT_MUTE\x10\x01\x12\n" +
	"\n" +
	"\x06ROUTER\x10\x02\x12\x15\n" +
	"\rROUTER_CLIENT\x10\x03\x1a\x02\b\x01\x12\f\n" +
	"\bREPEATER\x10\x04\x12\v\n" +
	"\aTRACKER\x10\x05\x12\n" +
	"\n" +
	"\x06SENSOR\x10\x06\x12\a\n" +
	"\x03TAK\x10\a\x12\x11\n" +
	"\rCLIENT_HIDDEN\x10\b\x12\x12\n" +
	"\x0eLOST_AND_FOUND\x10\t\x12\x0f\n" +
	"\vTAK_TRACKER\x10\n" +
	"\x12\x0f\n" +
	"\vROUTER_LATE\x10\v\"s\n" +
	"\x0fRebroadcastMode\x12\a\n" +
	"\x03ALL\x10\x00\x12\x15\n" +
	"\x11ALL_SKIP_DECODING\x10\x01\x12\x0e\n" +
	"\n" +
	"LOCAL_ONLY\x10\x02\x12\x0e\n" +
	"\n" +
	"KNOWN_ONLY\x10\x03\x12\b\n" +
	"\x04NONE\x10\x04\x12\x16\n" +
	"\x12CORE_PORTNUMS_ONLY\x10\x05\"T\n" +
	"\n" +
	"BuzzerMode\x12\x0f\n" +
	"\vALL_ENABLED\x10\x00\x12\f\n" +
	"\bDISABLED\x10\x01\x12\x16\n" +
	"\x12NOTIFICATIONS_ONLY\x10\x02\x12\x0f\n" +
	"\vSYSTEM_ONLY\x10\x03\x1a\xfa\x06\n" +
	"\x0ePositionConfig\x126\n" +
	"\x17position_broadcast_secs\x18\x01 \x01(\rR\x15positionBroadcastSecs\x12G\n" +
	" position_broadcast_smart_enabled\x18\x02 \x01(\bR\x1dpositionBroadcastSmartEnabled\x12%\n" +
	"\x0efixed_position\x18\x03 \x01(\bR\rfixedPosition\x12#\n" +
	"\vgps_enabled\x18\x04 \x01(\bB\x02\x18\x01R\n" +
	"gpsEnabled\x12.\n" +
	"\x13gps_update_interval\x18\x05 \x01(\rR\x11gpsUpdateInterval\x12,\n" +
	"\x10gps_attempt_time\x18\x06 \x01(\rB\x02\x18\x01R\x0egpsAttemptTime\x12%\n" +
	"\x0eposition_flags\x18\a \x01(\rR\rpositionFlags\x12\x17\n" +
	"\arx_gpio\x18\b \x01(\rR\x06rxGpio\x12\x17\n" +
	"\atx_gpio\x18\t \x01(\rR\x06txGpio\x12G\n" +
	" broadcast_smart_minimum_distance\x18\n" +
	" \x01(\rR\x1dbroadcastSmartMinimumDistance\x12P\n" +
	"%broadcast_smart_minimum_interval_secs\x18\v \x01(\rR!broadcastSmartMinimumIntervalSecs\x12\x1e\n" +
	"\vgps_en_gpio\x18\f \x01(\rR\tgpsEnGpio\x12D\n" +
	"\bgps_mode\x18\r \x01(\x0e2).meshtastic.Config.PositionConfig.GpsModeR\agpsMode\"\xab\x01\n" +
	"\rPositionFlags\x12\t\n" +
	"\x05UNSET\x10\x00\x12\f\n" +
	"\bALTITUDE\x10\x01\x12\x10\n" +
	"\fALTITUDE_MSL\x10\x02\x12\x16\n" +
	"\x12GEOIDAL_SEPARATION\x10\x04\x12\a\n" +
	"\x03DOP\x10\b\x12\t\n" +
	"\x05HVDOP\x10\x10\x12\r\n" +
	"\tSATINVIEW\x10 \x12\n" +
	"\n" +
	"\x06SEQ_NO\x10@\x12\x0e\n" +
	"\tTIMESTAMP\x10\x80\x01\x12\f\n" +
	"\aHEADING\x10\x80\x02\x12\n" +
	"\n" +
	"\x05SPEED\x10\x80\x04\"5\n" +
	"\aGpsMode\x12\f\n" +
	"\bDISABLED\x10\x00\x12\v\n" +
	"\aENABLED\x10\x01\x12\x0f\n" +
	"\vNOT_PRESENT\x10\x02\x1a\xa1\x03\n" +
	"\vPowerConfig\x12&\n" +
	"\x0fis_power_saving\x18\x01 \x01(\bR\risPowerSaving\x12B\n" +
	"\x1eon_battery_shutdown_after_secs\x18\x02 \x01(\rR\x1aonBatteryShutdownAfterSecs\x126\n" +
	"\x17adc_multiplier_override\x18\x03 \x01(\x02R\x15adcMultiplierOverride\x12.\n" +
	"\x13wait_bluetooth_secs\x18\x04 \x01(\rR\x11waitBluetoothSecs\x12\x19\n" +
	"\bsds_secs\x18\x06 \x01(\rR\asdsSecs\x12\x17\n" +
	"\als_secs\x18\a \x01(\rR\x06lsSecs\x12\"\n" +
	"\rmin_wake_secs\x18\b \x01(\rR\vminWakeSecs\x12;\n" +
	"\x1adevice_battery_ina_address\x18\t \x01(\rR\x17deviceBatteryInaAddress\x12)\n" +
	"\x10powermon_enables\x18  \x01(\x04R\x0fpowermonEnables\x1a\xfd\x04\n" +
	"\rNetworkConfig\x12!\n" +
	"\fwifi_enabled\x18\x01 \x01(\bR\vwifiEnabled\x12\x1b\n" +
	"\twifi_ssid\x18\x03 \x01(\tR\bwifiSsid\x12\x19\n" +
	"\bwifi_psk\x18\x04 \x01(\tR\awifiPsk\x12\x1d\n" +
	"\n" +
	"ntp_server\x18\x05 \x01(\tR\tntpServer\x12\x1f\n" +
	"\veth_enabled\x18\x06 \x01(\bR\n" +
	"ethEnabled\x12O\n" +
	"\faddress_mode\x18\a \x01(\x0e2,.meshtastic.Config.NetworkConfig.AddressModeR\vaddressMode\x12L\n" +
	"\vipv4_config\x18\b \x01(\v2+.meshtastic.Config.NetworkConfig.IpV4ConfigR\n" +
	"ipv4Config\x12%\n" +
	"\x0ersyslog_server\x18\t \x01(\tR\rrsyslogServer\x12+\n" +
	"\x11enabled_protocols\x18\n" +
	" \x01(\rR\x10enabledProtocols\x12!\n" +
	"\fipv6_enabled\x18\v \x01(\bR\vipv6Enabled\x1a`\n" +
	"\n" +
	"IpV4Config\x12\x0e\n" +
	"\x02ip\x18\x01 \x01(\aR\x02ip\x12\x18\n" +
	"\agateway\x18\x02 \x01(\aR\agateway\x12\x16\n" +
	"\x06subnet\x18\x03 \x01(\aR\x06subnet\x12\x10\n" +
	"\x03dns\x18\x04 \x01(\aR\x03dns\"#\n" +
	"\vAddressMode\x12\b\n" +
	"\x04DHCP\x10\x00\x12\n" +
	"\n" +
	"\x06STATIC\x10\x01\"4\n" +
	"\rProtocolFlags\x12\x10\n" +
	"\fNO_BROADCAST\x10\x00\x12\x11\n" +
	"\rUDP_BROADCAST\x10\x01\x1a\xa5\t\n" +
	"\rDisplayConfig\x12$\n" +
	"\x0escreen_on_secs\x18\x01 \x01(\rR\fscreenOnSecs\x12S\n" +
	"\n" +
	"gps_format\x18\x02 \x01(\x0e24.meshtastic.Config.DisplayConfig.GpsCoordinateFormatR\tgpsFormat\x129\n" +
	"\x19auto_screen_carousel_secs\x18\x03 \x01(\rR\x16autoScreenCarouselSecs\x12*\n" +
	"\x11compass_north_top\x18\x04 \x01(\bR\x0fcompassNorthTop\x12\x1f\n" +
	"\vflip_screen\x18\x05 \x01(\bR\n" +
	"flipScreen\x12C\n" +
	"\x05units\x18\x06 \x01(\x0e2-.meshtastic.Config.DisplayConfig.DisplayUnitsR\x05units\x12=\n" +
	"\x04oled\x18\a \x01(\x0e2).meshtastic.Config.DisplayConfig.OledTypeR\x04oled\x12N\n" +
	"\vdisplaymode\x18\b \x01(\x0e2,.meshtastic.Config.DisplayConfig.DisplayModeR\vdisplaymode\x12!\n" +
	"\fheading_bold\x18\t \x01(\bR\vheadingBold\x120\n" +
	"\x15wake_on_tap_or_motion\x18\n" +
	" \x01(\bR\x11wakeOnTapOrMotion\x12d\n" +
	"\x13compass_orientation\x18\v \x01(\x0e23.meshtastic.Config.DisplayConfig.CompassOrientationR\x12compassOrientation\x12\"\n" +
	"\ruse_12h_clock\x18\f \x01(\bR\vuse12hClock\"M\n" +
	"\x13GpsCoordinateFormat\x12\a\n" +
	"\x03DEC\x10\x00\x12\a\n" +
	"\x03DMS\x10\x01\x12\a\n" +
	"\x03UTM\x10\x02\x12\b\n" +
	"\x04MGRS\x10\x03\x12\a\n" +
	"\x03OLC\x10\x04\x12\b\n" +
	"\x04OSGR\x10\x05\"(\n" +
	"\fDisplayUnits\x12\n" +
	"\n" +
	"\x06METRIC\x10\x00\x12\f\n" +
	"\bIMPERIAL\x10\x01\"e\n" +
	"\bOledType\x12\r\n" +
	"\tOLED_AUTO\x10\x00\x12\x10\n" +
	"\fOLED_SSD1306\x10\x01\x12\x0f\n" +
	"\vOLED_SH1106\x10\x02\x12\x0f\n" +
	"\vOLED_SH1107\x10\x03\x12\x16\n" +
	"\x12OLED_SH1107_128_64\x10\x04\"A\n" +
	"\vDisplayMode\x12\v\n" +
	"\aDEFAULT\x10\x00\x12\f\n" +
	"\bTWOCOLOR\x10\x01\x12\f\n" +
	"\bINVERTED\x10\x02\x12\t\n" +
	"\x05COLOR\x10\x03\"\xba\x01\n" +
	"\x12CompassOrientation\x12\r\n" +
	"\tDEGREES_0\x10\x00\x12\x0e\n" +
	"\n" +
	"DEGREES_90\x10\x01\x12\x0f\n" +
	"\vDEGREES_180\x10\x02\x12\x0f\n" +
	"\vDEGREES_270\x10\x03\x12\x16\n" +
	"\x12DEGREES_0_INVERTED\x10\x04\x12\x17\n" +
	"\x13DEGREES_90_INVERTED\x10\x05\x12\x18\n" +
	"\x14DEGREES_180_INVERTED\x10\x06\x12\x18\n" +
	"\x14DEGREES_270_INVERTED\x10\a\x1a\xb8\t\n" +
	"\n" +
	"LoRaConfig\x12\x1d\n" +
	"\n" +
	"use_preset\x18\x01 \x01(\bR\tusePreset\x12L\n" +
	"\fmodem_preset\x18\x02 \x01(\x0e2).meshtastic.Config.LoRaConfig.ModemPresetR\vmodemPreset\x12\x1c\n" +
	"\tbandwidth\x18\x03 \x01(\rR\tbandwidth\x12#\n" +
	"\rspread_factor\x18\x04 \x01(\rR\fspreadFactor\x12\x1f\n" +
	"\vcoding_rate\x18\x05 \x01(\rR\n" +
	"codingRate\x12)\n" +
	"\x10frequency_offset\x18\x06 \x01(\x02R\x0ffrequencyOffset\x12@\n" +
	"\x06region\x18\a \x01(\x0e2(.meshtastic.Config.LoRaConfig.RegionCodeR\x06region\x12\x1b\n" +
	"\thop_limit\x18\b \x01(\rR\bhopLimit\x12\x1d\n" +
	"\n" +
	"tx_enabled\x18\t \x01(\bR\ttxEnabled\x12\x19\n" +
	"\btx_power\x18\n" +
	" \x01(\x05R\atxPower\x12\x1f\n" +
	"\vchannel_num\x18\v \x01(\rR\n" +
	"channelNum\x12.\n" +
	"\x13override_duty_cycle\x18\f \x01(\bR\x11overrideDutyCycle\x123\n" +
	"\x16sx126x_rx_boosted_gain\x18\r \x01(\bR\x13sx126xRxBoostedGain\x12-\n" +
	"\x12override_frequency\x18\x0e \x01(\x02R\x11overrideFrequency\x12&\n" +
	"\x0fpa_fan_disabled\x18\x0f \x01(\bR\rpaFanDisabled\x12'\n" +
	"\x0fignore_incoming\x18g \x03(\rR\x0eignoreIncoming\x12\x1f\n" +
	"\vignore_mqtt\x18h \x01(\bR\n" +
	"ignoreMqtt\x12)\n" +
	"\x11config_ok_to_mqtt\x18i \x01(\bR\x0econfigOkToMqtt\"\x96\x02\n" +
	"\n" +
	"RegionCode\x12\t\n" +
	"\x05UNSET\x10\x00\x12\x06\n" +
	"\x02US\x10\x01\x12\n" +
	"\n" +
	"\x06EU_433\x10\x02\x12\n" +
	"\n" +
	"\x06EU_868\x10\x03\x12\x06\n" +
	"\x02CN\x10\x04\x12\x06\n" +
	"\x02JP\x10\x05\x12\a\n" +
	"\x03ANZ\x10\x06\x12\x06\n" +
	"\x02KR\x10\a\x12\x06\n" +
	"\x02TW\x10\b\x12\x06\n" +
	"\x02RU\x10\t\x12\x06\n" +
	"\x02IN\x10\n" +
	"\x12\n" +
	"\n" +
	"\x06NZ_865\x10\v\x12\x06\n" +
	"\x02TH\x10\f\x12\v\n" +
	"\aLORA_24\x10\r\x12\n" +
	"\n" +
	"\x06UA_433\x10\x0e\x12\n" +
	"\n" +
	"\x06UA_868\x10\x0f\x12\n" +
	"\n" +
	"\x06MY_433\x10\x10\x12\n" +
	"\n" +
	"\x06MY_919\x10\x11\x12\n" +
	"\n" +
	"\x06SG_923\x10\x12\x12\n" +
	"\n" +
	"\x06PH_433\x10\x13\x12\n" +
	"\n" +
	"\x06PH_868\x10\x14\x12\n" +
	"\n" +
	"\x06PH_915\x10\x15\x12\v\n" +
	"\aANZ_433\x10\x16\x12\n" +
	"\n" +
	"\x06KZ_433\x10\x17\x12\n" +
	"\n" +
	"\x06KZ_863\x10\x18\"\xa9\x01\n" +
	"\vModemPreset\x12\r\n" +
	"\tLONG_FAST\x10\x00\x12\r\n" +
	"\tLONG_SLOW\x10\x01\x12\x16\n" +
	"\x0eVERY_LONG_SLOW\x10\x02\x1a\x02\b\x01\x12\x0f\n" +
	"\vMEDIUM_SLOW\x10\x03\x12\x0f\n" +
	"\vMEDIUM_FAST\x10\x04\x12\x0e\n" +
	"\n" +
	"SHORT_SLOW\x10\x05\x12\x0e\n" +
	"\n" +
	"SHORT_FAST\x10\x06\x12\x11\n" +
	"\rLONG_MODERATE\x10\a\x12\x0f\n" +
	"\vSHORT_TURBO\x10\b\x1a\xc6\x01\n" +
	"\x0fBluetoothConfig\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12B\n" +
	"\x04mode\x18\x02 \x01(\x0e2..meshtastic.Config.BluetoothConfig.PairingModeR\x04mode\x12\x1b\n" +
	"\tfixed_pin\x18\x03 \x01(\rR\bfixedPin\"8\n" +
	"\vPairingMode\x12\x0e\n" +
	"\n" +
	"RANDOM_PIN\x10\x00\x12\r\n" +
	"\tFIXED_PIN\x10\x01\x12\n" +
	"\n" +
	"\x06NO_PIN\x10\x02\x1a\x9a\x02\n" +
	"\x0eSecurityConfig\x12\x1d\n" +
	"\n" +
	"public_key\x18\x01 \x01(\fR\tpublicKey\x12\x1f\n" +
	"\vprivate_key\x18\x02 \x01(\fR\n" +
	"privateKey\x12\x1b\n" +
	"\tadmin_key\x18\x03 \x03(\fR\badminKey\x12\x1d\n" +
	"\n" +
	"is_managed\x18\x04 \x01(\bR\tisManaged\x12%\n" +
	"\x0eserial_enabled\x18\x05 \x01(\bR\rserialEnabled\x121\n" +
	"\x15debug_log_api_enabled\x18\x06 \x01(\bR\x12debugLogApiEnabled\x122\n" +
	"\x15admin_channel_enabled\x18\b \x01(\bR\x13adminChannelEnabled\x1a\x12\n" +
	"\x10SessionkeyConfigB\x11\n" +
	"\x0fpayload_variantBa\n" +
	"\x13com.geeksville.meshB\fConfigProtosZ\"github.com/meshtastic/go/generated\xaa\x02\x14Meshtastic.Protobufs\xba\x02\x00b\x06proto3"

var (
	file_meshtastic_config_proto_rawDescOnce sync.Once
	file_meshtastic_config_proto_rawDescData []byte
)

func file_meshtastic_config_proto_rawDescGZIP() []byte {
	file_meshtastic_config_proto_rawDescOnce.Do(func() {
		file_meshtastic_config_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_meshtastic_config_proto_rawDesc), len(file_meshtastic_config_proto_rawDesc)))
	})
	return file_meshtastic_config_proto_rawDescData
}

var file_meshtastic_config_proto_enumTypes = make([]protoimpl.EnumInfo, 15)
var file_meshtastic_config_proto_msgTypes = make([]protoimpl.MessageInfo, 11)
var file_meshtastic_config_proto_goTypes = []any{
	(Config_DeviceConfig_Role)(0),                 // 0: meshtastic.Config.DeviceConfig.Role
	(Config_DeviceConfig_RebroadcastMode)(0),      // 1: meshtastic.Config.DeviceConfig.RebroadcastMode
	(Config_DeviceConfig_BuzzerMode)(0),           // 2: meshtastic.Config.DeviceConfig.BuzzerMode
	(Config_PositionConfig_PositionFlags)(0),      // 3: meshtastic.Config.PositionConfig.PositionFlags
	(Config_PositionConfig_GpsMode)(0),            // 4: meshtastic.Config.PositionConfig.GpsMode
	(Config_NetworkConfig_AddressMode)(0),         // 5: meshtastic.Config.NetworkConfig.AddressMode
	(Config_NetworkConfig_ProtocolFlags)(0),       // 6: meshtastic.Config.NetworkConfig.ProtocolFlags
	(Config_DisplayConfig_GpsCoordinateFormat)(0), // 7: meshtastic.Config.DisplayConfig.GpsCoordinateFormat
	(Config_DisplayConfig_DisplayUnits)(0),        // 8: meshtastic.Config.DisplayConfig.DisplayUnits
	(Config_DisplayConfig_OledType)(0),            // 9: meshtastic.Config.DisplayConfig.OledType
	(Config_DisplayConfig_DisplayMode)(0),         // 10: meshtastic.Config.DisplayConfig.DisplayMode
	(Config_DisplayConfig_CompassOrientation)(0),  // 11: meshtastic.Config.DisplayConfig.CompassOrientation
	(Config_LoRaConfig_RegionCode)(0),             // 12: meshtastic.Config.LoRaConfig.RegionCode
	(Config_LoRaConfig_ModemPreset)(0),            // 13: meshtastic.Config.LoRaConfig.ModemPreset
	(Config_BluetoothConfig_PairingMode)(0),       // 14: meshtastic.Config.BluetoothConfig.PairingMode
	(*Config)(nil),                                // 15: meshtastic.Config
	(*Config_DeviceConfig)(nil),                   // 16: meshtastic.Config.DeviceConfig
	(*Config_PositionConfig)(nil),                 // 17: meshtastic.Config.PositionConfig
	(*Config_PowerConfig)(nil),                    // 18: meshtastic.Config.PowerConfig
	(*Config_NetworkConfig)(nil),                  // 19: meshtastic.Config.NetworkConfig
	(*Config_DisplayConfig)(nil),                  // 20: meshtastic.Config.DisplayConfig
	(*Config_LoRaConfig)(nil),                     // 21: meshtastic.Config.LoRaConfig
	(*Config_BluetoothConfig)(nil),                // 22: meshtastic.Config.BluetoothConfig
	(*Config_SecurityConfig)(nil),                 // 23: meshtastic.Config.SecurityConfig
	(*Config_SessionkeyConfig)(nil),               // 24: meshtastic.Config.SessionkeyConfig
	(*Config_NetworkConfig_IpV4Config)(nil),       // 25: meshtastic.Config.NetworkConfig.IpV4Config
	(*DeviceUIConfig)(nil),                        // 26: meshtastic.DeviceUIConfig
}
var file_meshtastic_config_proto_depIdxs = []int32{
	16, // 0: meshtastic.Config.device:type_name -> meshtastic.Config.DeviceConfig
	17, // 1: meshtastic.Config.position:type_name -> meshtastic.Config.PositionConfig
	18, // 2: meshtastic.Config.power:type_name -> meshtastic.Config.PowerConfig
	19, // 3: meshtastic.Config.network:type_name -> meshtastic.Config.NetworkConfig
	20, // 4: meshtastic.Config.display:type_name -> meshtastic.Config.DisplayConfig
	21, // 5: meshtastic.Config.lora:type_name -> meshtastic.Config.LoRaConfig
	22, // 6: meshtastic.Config.bluetooth:type_name -> meshtastic.Config.BluetoothConfig
	23, // 7: meshtastic.Config.security:type_name -> meshtastic.Config.SecurityConfig
	24, // 8: meshtastic.Config.sessionkey:type_name -> meshtastic.Config.SessionkeyConfig
	26, // 9: meshtastic.Config.device_ui:type_name -> meshtastic.DeviceUIConfig
	0,  // 10: meshtastic.Config.DeviceConfig.role:type_name -> meshtastic.Config.DeviceConfig.Role
	1,  // 11: meshtastic.Config.DeviceConfig.rebroadcast_mode:type_name -> meshtastic.Config.DeviceConfig.RebroadcastMode
	2,  // 12: meshtastic.Config.DeviceConfig.buzzer_mode:type_name -> meshtastic.Config.DeviceConfig.BuzzerMode
	4,  // 13: meshtastic.Config.PositionConfig.gps_mode:type_name -> meshtastic.Config.PositionConfig.GpsMode
	5,  // 14: meshtastic.Config.NetworkConfig.address_mode:type_name -> meshtastic.Config.NetworkConfig.AddressMode
	25, // 15: meshtastic.Config.NetworkConfig.ipv4_config:type_name -> meshtastic.Config.NetworkConfig.IpV4Config
	7,  // 16: meshtastic.Config.DisplayConfig.gps_format:type_name -> meshtastic.Config.DisplayConfig.GpsCoordinateFormat
	8,  // 17: meshtastic.Config.DisplayConfig.units:type_name -> meshtastic.Config.DisplayConfig.DisplayUnits
	9,  // 18: meshtastic.Config.DisplayConfig.oled:type_name -> meshtastic.Config.DisplayConfig.OledType
	10, // 19: meshtastic.Config.DisplayConfig.displaymode:type_name -> meshtastic.Config.DisplayConfig.DisplayMode
	11, // 20: meshtastic.Config.DisplayConfig.compass_orientation:type_name -> meshtastic.Config.DisplayConfig.CompassOrientation
	13, // 21: meshtastic.Config.LoRaConfig.modem_preset:type_name -> meshtastic.Config.LoRaConfig.ModemPreset
	12, // 22: meshtastic.Config.LoRaConfig.region:type_name -> meshtastic.Config.LoRaConfig.RegionCode
	14, // 23: meshtastic.Config.BluetoothConfig.mode:type_name -> meshtastic.Config.BluetoothConfig.PairingMode
	24, // [24:24] is the sub-list for method output_type
	24, // [24:24] is the sub-list for method input_type
	24, // [24:24] is the sub-list for extension type_name
	24, // [24:24] is the sub-list for extension extendee
	0,  // [0:24] is the sub-list for field type_name
}

func init() { file_meshtastic_config_proto_init() }
func file_meshtastic_config_proto_init() {
	if File_meshtastic_config_proto != nil {
		return
	}
	file_meshtastic_device_ui_proto_init()
	file_meshtastic_config_proto_msgTypes[0].OneofWrappers = []any{
		(*Config_Device)(nil),
		(*Config_Position)(nil),
		(*Config_Power)(nil),
		(*Config_Network)(nil),
		(*Config_Display)(nil),
		(*Config_Lora)(nil),
		(*Config_Bluetooth)(nil),
		(*Config_Security)(nil),
		(*Config_Sessionkey)(nil),
		(*Config_DeviceUi)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_meshtastic_config_proto_rawDesc), len(file_meshtastic_config_proto_rawDesc)),
			NumEnums:      15,
			NumMessages:   11,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_meshtastic_config_proto_goTypes,
		DependencyIndexes: file_meshtastic_config_proto_depIdxs,
		EnumInfos:         file_meshtastic_config_proto_enumTypes,
		MessageInfos:      file_meshtastic_config_proto_msgTypes,
	}.Build()
	File_meshtastic_config_proto = out.File
	file_meshtastic_config_proto_goTypes = nil
	file_meshtastic_config_proto_depIdxs = nil
}
