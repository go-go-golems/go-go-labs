---
Title: QuickJS Migration Implementation Guide and Test Strategy
Ticket: WEBVM-002-QUICKJS-MIGRATION
Status: active
Topics:
    - architecture
    - plugin
    - state-management
    - testing
    - quickjs
    - playwright
DocType: design-doc
Intent: long-term
Owners: []
RelatedFiles:
    - Path: cmd/experiments/2026-02-08--simulated-communication/plugin-playground/client/src/lib/pluginManager.ts
      Note: Current in-process runtime baseline to be removed
    - Path: cmd/experiments/2026-02-08--simulated-communication/plugin-playground/client/src/lib/uiTypes.ts
      Note: Canonical kind-based UINode contract
    - Path: cmd/experiments/2026-02-08--simulated-communication/plugin-playground/client/src/pages/Playground.tsx
      Note: Current runtime entrypoint for migration cutover
    - Path: cmd/experiments/2026-02-08--simulated-communication/plugin-playground/client/src/store/store.ts
      Note: DispatchId and scoped action host behavior
    - Path: cmd/experiments/2026-02-08--simulated-communication/plugin-playground/package.json
      Note: Dependency and test scripts surface
    - Path: ttmp/2026/02/08/WEBVM-001-SCOPE-PLUGIN-ACTIONS--scope-plugin-actions-and-state-for-webvm/design-doc/02-quickjs-isolation-architecture-and-mock-runtime-removal-plan.md
      Note: Parent architecture rationale
ExternalSources: []
Summary: Execution-level migration plan and test strategy for replacing in-process plugin execution with a QuickJS worker runtime, including Playwright gates.
LastUpdated: 2026-02-08T18:59:00-05:00
WhatFor: Provide a concrete, file-by-file implementation runbook and acceptance gates for the QuickJS cutover.
WhenToUse: Use while implementing WEBVM-002 tasks, reviewing migration PRs, and validating runtime safety/performance behavior.
---


# QuickJS Migration Implementation Guide and Test Strategy

## Executive Summary

This document is the implementation runbook for migrating the active plugin-playground runtime from in-process `new Function(...)` execution to a real QuickJS runtime in a dedicated Web Worker. It is intentionally execution-focused and pairs each phase with concrete files, acceptance criteria, and tests.

The migration is scoped to the active project path:

- `cmd/experiments/2026-02-08--simulated-communication/plugin-playground`

It assumes the architecture decisions already documented in WEBVM-001 doc 02 are accepted and stable.

## Problem Statement

The active runtime path currently executes plugin code on the browser main thread via `pluginManager.ts` and `new Function(...)`. That creates three immediate problems:

1. Isolation is not real.
2. UI can be frozen by runaway plugin code.
3. Runtime behavior is hard to harden/test because plugin code and host code share one JS environment.

There is also contract drift in documentation/history: references exist to `pluginSandboxClient.ts` and `pluginSandbox.worker.ts`, but these files are not present in the current active project path. The migration therefore requires new runtime files, not just cleanup.

## Scope and Non-Goals

### In Scope

1. Introduce a QuickJS runtime service in a dedicated worker.
2. Replace main-thread plugin execution in `Playground.tsx` with RPC calls to worker runtime.
3. Keep `UINode` contract canonical and kind-based.
4. Enforce resource controls (memory, stack, timeout/interrupt).
5. Add unit/integration/e2e test gates, including Playwright.
6. Remove `pluginManager.ts` from active runtime path after cutover.

### Out of Scope

1. Multi-tenant trust tiers or remote sandbox execution.
2. Full plugin module graph loading (`import`) beyond current single-script model.
3. Runtime pooling optimization in v1 (one runtime per plugin remains default).

## Baseline Snapshot (As-Is)

### Current Runtime Flow

```text
Playground.tsx
  -> pluginManager.loadPlugin(code)
    -> new Function("definePlugin", code)
  -> pluginManager.renderWidget(...)
  -> pluginManager.callHandler(...)
```

### Existing Contracts To Preserve

1. `UINode` tree shape with `kind` discriminant.
2. Plugin/global action split (`dispatchPluginAction`, `dispatchGlobalAction`).
3. Dispatch metadata including `dispatchId` generated by host-side store pipeline.

## Target Runtime Architecture (To-Be)

### Main Thread

1. `QuickJSSandboxClient` handles RPC to worker.
2. `Playground.tsx` becomes orchestration UI only.
3. Store remains host authority for dispatch validation and stamping.

### Worker Thread

1. `quickjsRuntime.worker.ts` owns QuickJS module/runtime/context lifecycle.
2. Plugin code is evaluated only inside QuickJS context.
3. Worker returns serializable render tree and dispatch intents.
4. Worker enforces memory/stack/deadline limits.

## Proposed File Changes

### New Files

1. `cmd/experiments/2026-02-08--simulated-communication/plugin-playground/client/src/lib/quickjsContracts.ts`
2. `cmd/experiments/2026-02-08--simulated-communication/plugin-playground/client/src/lib/quickjsSandboxClient.ts`
3. `cmd/experiments/2026-02-08--simulated-communication/plugin-playground/client/src/workers/quickjsRuntime.worker.ts`
4. `cmd/experiments/2026-02-08--simulated-communication/plugin-playground/client/src/lib/uiSchema.ts`
5. `cmd/experiments/2026-02-08--simulated-communication/plugin-playground/client/src/lib/dispatchIntent.ts`
6. `cmd/experiments/2026-02-08--simulated-communication/plugin-playground/playwright.config.ts`
7. `cmd/experiments/2026-02-08--simulated-communication/plugin-playground/tests/e2e/quickjs-runtime.spec.ts`

### Modified Files

1. `cmd/experiments/2026-02-08--simulated-communication/plugin-playground/client/src/pages/Playground.tsx`
2. `cmd/experiments/2026-02-08--simulated-communication/plugin-playground/client/src/lib/uiTypes.ts`
3. `cmd/experiments/2026-02-08--simulated-communication/plugin-playground/client/src/store/store.ts`
4. `cmd/experiments/2026-02-08--simulated-communication/plugin-playground/package.json`

### Removed Files

1. `cmd/experiments/2026-02-08--simulated-communication/plugin-playground/client/src/lib/pluginManager.ts`

## Implementation Steps

## Step 0: Establish Guardrails and Branch Safety

### Actions

1. Freeze new `new Function` additions in plugin runtime code paths.
2. Add a temporary lint/test check to fail if `new Function(` appears in runtime files.
3. Capture a baseline smoke video/screenshot run of current presets.

### Acceptance Criteria

1. No new runtime code can add `new Function` without failing checks.
2. Baseline behavior for preset loading documented before migration.

## Step 1: Define Contracts and Validation Utilities

### Actions

1. Add `quickjsContracts.ts` with RPC request/response/event types.
2. Add runtime error envelope type (`code`, `message`, `details`).
3. Add `uiSchema.ts` runtime validator for returned `UINode` trees.
4. Add `dispatchIntent.ts` with `scope: plugin|global`, `actionType`, `payload`, `pluginId`.

### Acceptance Criteria

1. Worker/client compile against the same contract source.
2. Invalid UI tree payloads produce deterministic errors.
3. Dispatch intents are validated before host dispatch.

## Step 2: Build QuickJS Worker Runtime Skeleton

### Actions

1. Create `quickjsRuntime.worker.ts` and load QuickJS with `getQuickJS()`.
2. Add runtime registry keyed by `pluginId`.
3. Implement RPC dispatcher for `loadPlugin`, `render`, `event`, `disposePlugin`, `health`.
4. Add lifecycle helpers to dispose context/runtime deterministically.

### Acceptance Criteria

1. Worker can start and respond to `health`.
2. `loadPlugin` creates runtime/context and stores instance.
3. `disposePlugin` always releases handles and registry entries.

## Step 3: Implement VM Bootstrap and Plugin Capture

### Actions

1. Define bootstrap source that sets `definePlugin(...)` and internal plugin holder.
2. Evaluate bootstrap before plugin code.
3. Evaluate plugin code in QuickJS context.
4. Extract and validate plugin metadata (`title`, `widgets`, `initialState`).

### Acceptance Criteria

1. Preset plugin can load with metadata returned to host.
2. Missing `definePlugin` call returns structured load error.
3. VM exceptions are mapped to host error envelope.

## Step 4: Implement Render and Event Execution

### Actions

1. Add render path: host sends `pluginState` + `globalState`; worker executes widget render.
2. Add event path: host sends event descriptor; worker invokes handler in VM.
3. Collect dispatch intents during event call and emit to host.
4. Validate render output against `UINode` schema before returning.

### Acceptance Criteria

1. Render returns serializable `UINode` tree matching current renderer contract.
2. Event handling can trigger plugin/global intents.
3. Invalid return data is rejected with clear errors.

## Step 5: Enforce Runtime Limits and Fault Policy

### Actions

1. Set memory and stack limits for each runtime.
2. Add interrupt/deadline logic for render/event calls.
3. Return timeout/interrupted codes for runaway code.
4. Mark plugin status degraded/error in host state on repeated failures.

### Acceptance Criteria

1. Infinite loops do not freeze UI thread.
2. Stack overflow/memory errors are surfaced as typed runtime failures.
3. Worker remains responsive after recoverable plugin errors.

## Step 6: Add Main-Thread Client and Cut Over Playground

### Actions

1. Add `quickjsSandboxClient.ts` wrapping worker RPC.
2. Replace `pluginManager` usage in `Playground.tsx` with sandbox client methods.
3. Keep plugin registry in React/store using worker-returned metadata.
4. Route all events through worker and host dispatch pipeline.

### Acceptance Criteria

1. Preset + custom plugin load path works without `pluginManager`.
2. Button/input handlers update state through worker intents and store reducers.
3. UI behavior is functionally equivalent for core presets.

## Step 7: Remove Legacy Runtime and Dead References

### Actions

1. Delete `pluginManager.ts` and any imports/usages.
2. Remove stale docs/comments claiming QuickJS isolation where not implemented.
3. Update index docs and architecture docs with migration completion notes.

### Acceptance Criteria

1. No runtime path imports `pluginManager`.
2. Search for `new Function(` in runtime files returns no matches.
3. Build/check passes after cleanup.

## Step 8: Test Gates and CI Integration

### Actions

1. Add `test:unit`, `test:e2e`, and `test:migration` scripts in `package.json`.
2. Add Playwright config with deterministic `webServer` command.
3. Add e2e specs focused on runtime isolation and state dispatch behavior.
4. Add CI job order: typecheck -> unit -> e2e.

### Acceptance Criteria

1. `pnpm test:unit` passes locally and in CI.
2. `pnpm test:e2e` passes headless on clean install.
3. Migration checklist includes all must-pass gates before merge.

## Test Strategy

## Unit Tests (Vitest)

Target path: `client/src/lib/**/*.test.ts`

1. Contract validators:
- Accept valid `UINode` trees.
- Reject trees missing `kind` or with invalid structure.

2. Dispatch intent validation:
- Reject missing `scope`/`actionType`.
- Reject global action types not on allowlist.

3. Error mapping:
- QuickJS exceptions map to stable host envelope codes.

4. Interrupt policy:
- Deadline checker returns interrupted status when exceeded.

### Suggested Commands

```bash
cd cmd/experiments/2026-02-08--simulated-communication/plugin-playground
pnpm test:unit
```

## Integration Tests (Vitest + Worker)

Target path: `client/src/workers/**/*.integration.test.ts`

1. `loadPlugin` + `render` happy path with counter preset.
2. Event handler dispatch intent path for plugin scoped action.
3. Global action dispatch intent allowlist path.
4. Runtime dispose path after unload.

### Suggested Commands

```bash
cd cmd/experiments/2026-02-08--simulated-communication/plugin-playground
pnpm test:integration
```

## E2E Tests (Playwright)

Target path: `tests/e2e/quickjs-runtime.spec.ts`

1. Preset load and widget render:
- Load Counter preset.
- Verify widget appears and initial value is shown.

2. Event-to-state loop:
- Click increment button.
- Verify counter text updates.
- Verify dispatch trace indicators update if visible.

3. Isolation behavior:
- Load custom plugin attempting `window`/`document` access.
- Verify runtime error shown and host app remains usable.

4. Timeout behavior:
- Load custom plugin with `while(true){}` in render handler.
- Verify plugin enters error state and UI remains responsive.

5. Multi-plugin coexistence:
- Load Counter + Status plugins.
- Verify shared global indicators and individual widget behavior.

### Suggested Commands

```bash
cd cmd/experiments/2026-02-08--simulated-communication/plugin-playground
pnpm add -D @playwright/test
pnpm exec playwright install --with-deps chromium
pnpm test:e2e
```

## Suggested package.json Script Additions

```json
{
  "scripts": {
    "test:unit": "vitest run",
    "test:integration": "vitest run --config vitest.integration.config.ts",
    "test:e2e": "playwright test",
    "test:migration": "pnpm check && pnpm test:unit && pnpm test:integration && pnpm test:e2e"
  }
}
```

## Playwright Configuration Notes

1. Use one deterministic local host/port for test startup.
2. Set explicit timeout for long-running load scenarios.
3. Keep screenshots/videos on failure for migration debugging.
4. Avoid brittle CSS selectors; prefer text/test-id anchors.

## Design Decisions

1. One runtime/context per plugin instance in v1.
2. Worker is mandatory, no main-thread fallback.
3. Host remains dispatch authority; VM emits intents only.
4. Schema validation occurs before render tree hits React renderer.
5. Tests are required as merge gates, not optional follow-up.

## Alternatives Considered

## A) Keep `pluginManager` and only wrap calls with try/catch

Rejected because it keeps unsafe execution model and no true isolation.

## B) Use native worker without QuickJS

Rejected because plugin code still runs in browser engine with weaker control guarantees.

## C) Build Playwright tests first, migrate later

Deferred because baseline lacks worker contracts; first tests would encode wrong architecture shape.

## Risks and Mitigations

1. Risk: Serialization overhead for every render/event.
- Mitigation: Keep payloads small; profile before optimization.

2. Risk: QuickJS handle leaks causing memory growth.
- Mitigation: Centralize dispose helpers and add repeated load/unload tests.

3. Risk: Flaky e2e tests due to async runtime init.
- Mitigation: Wait on visible runtime-ready indicators, not arbitrary sleeps.

4. Risk: Preset plugin API incompatibility.
- Mitigation: Create migration shim in bootstrap; migrate presets incrementally with tests.

## Review and Validation Checklist

1. `rg -n "new Function\(" client/src` returns no runtime-path hits.
2. Preset load/render/event flows pass manually and in automated tests.
3. Infinite-loop plugin test proves UI thread remains responsive.
4. Store dispatch metadata still includes `dispatchId` for plugin/global actions.
5. Worker teardown on unload is verified by integration test.

## References

1. `ttmp/2026/02/08/WEBVM-001-SCOPE-PLUGIN-ACTIONS--scope-plugin-actions-and-state-for-webvm/design-doc/02-quickjs-isolation-architecture-and-mock-runtime-removal-plan.md`
2. `cmd/experiments/2026-02-08--simulated-communication/plugin-playground/client/src/lib/pluginManager.ts`
3. `cmd/experiments/2026-02-08--simulated-communication/plugin-playground/client/src/pages/Playground.tsx`
4. `cmd/experiments/2026-02-08--simulated-communication/plugin-playground/client/src/lib/uiTypes.ts`
5. `cmd/experiments/2026-02-08--simulated-communication/plugin-playground/client/src/store/store.ts`
6. `cmd/experiments/2026-02-08--simulated-communication/plugin-playground/package.json`
